     Z* CRTBNDRPG
     Z* DFTACTGRP(*NO) BNDDIR(YBNDDIR) DBGVIEW(*SOURCE)
     Z* CVTOPT(*DATETIME) ACTGRP(*CALLER) OPTIMIZE(*BASIC)
      *****************  RPG PROGRAM HEADING  ************************
      *
      * ENVIRONMENT:  J.D. Edwards
      * PROGRAM:      SELSUB
      * TITLE:        Select JDE Subsidiary for Cost Center and Object Passed in for Enterprise 1
      * AUTHOR:       Bead Baden   SDN465   TFS# P16969
      * CREATED:       3/13/2020
      *
      * FUNCTION: This is a select function window display of the J.D. Edwards
      *           Account Master file.  All valid subcodes will be displayed for the
      *           cost center/object that was passed in.
      *
      *           A record is selected by positioning the cursor on the line
      *           and pressing enter.
      *
      *           Restrictors:  Cost Center and Object
      *
      *           Positioners:  none
      *
      *           Selectors:    subsidiary
      *
      *
      * NOTE:    This is a pop-up window program.  Please note that in window
      *          programs the record format containing the window definition
      *          must be written first.
      *
      ****************************************************************
      * MODIFICATIONS:
      ****************************************************************
      *  3/13/2020 JBB P16169 - JDE World to JDE Enterprise 1
      *                SDN465   Copied source from SELSUB in JFOODCUST
      *                         to SELSUBE1 in E1IDEVGEN for Enterprise 1
      *
      /EJECT
      ****************************************************************
      * FILE SPECIFICATIONS
      ****************************************************************
      *
     F*seldsub   cf   e             workstn
     Fseldsube1 cf   e             workstn
     F                                     sfile(subsels1:hdrrn1)
     F                                     infds(iofeed)
      *
     F*f0901lb   if   e           k disk
     f*e10901lb  if   e           k disk
     fe10901le  if   e           k disk
      *    account master  Key: co, mcu, obj, sub
      *
      ****************************************************************
      * DEFINITION SPECIFICATIONS
      ****************************************************************
      *
      ****************************************************************
      * CONSTANTS
      ****************************************************************
      *
     D yes             c                   'Y'
     D no              c                   'N'
     D set1            c                   'SET1  '
     D edit1           c                   'EDIT1 '
     D scrn1           c                   'SCRN1 '
     D exit            c                   'EXIT  '
      *
     D upper           c                   'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
     D lower           c                   'abcdefghijklmnopqrstuvwxyz'
      *
      ****************************************************************
      * ARRAYS AND TABLES
      ****************************************************************
      *
      *
      ****************************************************************
      * STANDALONE FIELDS
      ****************************************************************
      *
      * Standard fields
      *
     D pgm             s             10
     D msgfl           s             10
     D routne          s              6
     D maxrrn          s              4  0
     D norecs          s              1    inz('N')
     D count           s              2  0
     D rtncd           s              2    inz('00')
     D svrrn1          s                   like(hdrrn1)
     D maxmsg          s              2  0  inz(20)
     D wkplin          s              2  0
      *
      *
      *
      * Workfields
      *
     D wkco            s              5
     d wkco3n          s              3  0
     d wkco5n          s              5  0
      *
      *
      * Workfields for description selection
      *
     D procfl          s              1
     D wklong          s              2  0
     D wkdesc          s                   like(c1dl01)
     D wk1desc         s                   like(c1dl01)
     D company         s              5
      *
      * Parm fields
      *
     D xxretrn         s              7
     D xxmcu           s                   like(c1mcu)
     D xxobj           s                   like(c1obj)
     D xxsub           s                   like(c1sub)
     D xxaid           s                   like(gmaid)
     D xxconm          s             30
     D xxchar50        s             50
     D xxco            s              3p 0
      *
      *
      * Save fields for positioners and selectors
      *
     D svmcu           s                   like(d1mcu)
     D svobj           s                   like(d1obj)
     D svsub           s                   like(d1sub)
     D svdl01          s                   like(d1dl01)
      *
      ****************************************************************
      * DATA STRUCTURES
      ****************************************************************
      *
      *---------------------------------------------------------------
      * standard error message handling data structures
      *---------------------------------------------------------------
      *
      * For error message handling, a packed index (3) is required.
      * For program readability, define a corresponding error count
      * field called 'error'
      *
     D                 ds                  inz
     D  error                         2p 0
     D   e                            2p 0 overlay(error)
      *
      *---------------------------------------------------------------
      * Standard program status data structure
      *---------------------------------------------------------------
      *    externally defined as UTPGFR (record format: PGMDSR)
     D pgmds         esds                  extname(utpgfr)
      *
      *
      *---------------------------------------------------------------
      * Standard workstation information data structure
      *---------------------------------------------------------------
      *    externally defined as UTWSFR (record format: UTIDFRR)
     D iofeed        e ds                  extname(utwsfr)
      *
      *
      *---------------------------------------------------------------
      * Standard database file information data structure
      *---------------------------------------------------------------
      *    externally defined as UTDBGR (record format: FDBCKD)
     D dbfeed        e ds                  extname(utdbfr)
      *
      *
      * The following is a dummy C-spec to keep the D-specs from
      * running over into the C-specs on the compile listing. It
      * serves no other purpose and can be deleted at any time.
      *
     C                   if        sdpgm = *blank
     C                   endif
      /EJECT
      ****************************************************************
      * MAINLINE
      ****************************************************************
      *
     C                   eval      routne = set1
      *
     C     *inlr         doweq     *off                                         Main do loop
     C     routne        caseq     set1          $set1
     C     routne        caseq     scrn1         $scrn1
     C     routne        caseq     exit          $exit
     C                   endcs
     C                   enddo                                                  Main do loop
      /EJECT
      *---------------------------------------------------------------
      * $set1 - set environment for screen 1
      *---------------------------------------------------------------
      *
     C     $set1         begsr
      *
      * Clear/fill the subfile
      *
     C                   exsr      $clr1
     C                   exsr      $frsh1
      *
      * Set routine to display screen
      *
     C                   eval      routne = scrn1
      *
     C                   endsr
      /EJECT
      *---------------------------------------------------------------
      * $scrn1 - perform operator I/O for screen 1
      *---------------------------------------------------------------
      *
     C     $scrn1        begsr
      *
      * Write screen 1 to crt
      *
     C                   write     subselw1
     C                   write     subselk1
     C                   exfmt     subselc1
      *
      *
      * Get user's entry and set next routine
      *
     C                   select
     C                   when      *in12 = *on                                  F12-previous
     C                   eval      routne = exit
      *
      * Reposition the subfile if the user has changed any of the
      * positioners or selectors in the control record.
      *
     C                   when      c1sub <> svsub or                            Positioners
     C                             c1dl01 <> svdl01
     C                   exsr      $chksv
      *
     C                   when      *in25 = *on                                  F25-rollup
     C                   exsr      $load1
     C                   eval      routne = scrn1
     C                   other
      *
      * User has pressed enter
      *
     C                   if        norecs = yes                                 If empty sfl
     C                   eval      routne = set1
     C                   else
     C                   exsr      $proc1
     C                   endif                                                  If empty sfl
     C                   endsl
      *
     C                   endsr
      /EJECT
      *----------------------------------------------------------------
      * $proc1 - process user's selection
      *----------------------------------------------------------------
      *
     C     $proc1        begsr
      *
      * If cursor location returned is the rrn of a record in the
      * subfile, chain to the subfile record and load the data into
      * the parms to return to the calling program.
      *
     C                   if        hdrrn <> 0
     C                   eval      hdrrn1 = hdrrn
     C     hdrrn1        chain     subsels1                           92
     C                   eval      xxaid = hdaid
     C                   eval      xxsub = d1sub
     C                   eval      xxchar50 = *blank
      *
      * Build a 50-character fields that consists of:
      *    a) cost center  (ie: business unit)
      *    b) object account
      *    c) subsidiary
      *    d) description
      *
      * Cost center
     C                   eval      d1mcu = %trim(d1mcu)
     C     ' '           checkr    d1mcu         wklong
     C                   eval      %subst(xxchar50: 1: wklong) = d1mcu
      *
      *
      * Object account
      *
     C     ' '           checkr    xxchar50      wklong
     C                   eval      %subst(xxchar50: wklong+3: 6) = d1obj
      *
      * Subsidiary
      *
     C     ' '           checkr    xxchar50      wklong
     C                   eval      %subst(xxchar50: wklong+3: 8) = d1sub
      *
      * Description
     C     ' '           checkr    xxchar50      wklong
     C                   eval      %subst(xxchar50: wklong+3: 50-wklong-3) =
     C                             d1dl01
     C                   endif
      *
      * If the user selected a record, set the routine to exit.  If no record
      * was selected, redisplay the screen.
      *
     C                   if        xxaid = *blank
     C                   eval      hdpag1 = idflow
     c                   eval      routne = scrn1
     C                   else
     c                   eval      routne = exit
     C                   endif
      *
     C                   endsr
      /EJECT
      *----------------------------------------------------------------
      * $chksv - save the control record positioners/selectors
      *----------------------------------------------------------------
      *                                                                        z
     C     $chksv        begsr
      *
     C                   eval      routne = set1
      *
      * Prepare to scan on description
      *  1) trim leading/trailing blanks
      *  2) find first non-blank position from right
      *
     C                   if        c1dl01 <> svdl01
     C                   eval      c1dl01 = %trim(c1dl01)
     C     ' '           checkr    c1dl01        wklong
     C                   endif
      *
     C                   eval      svsub = c1sub
     C                   eval      svdl01 = c1dl01
      *
     C                   endsr
      /EJECT
      *---------------------------------------------------------------
      * $clr1  - clear subfile for screen 1
      *---------------------------------------------------------------
      *
     C     $clr1         begsr
      *
     C                   eval      svrrn1 = 0
      *
     C                   clear                   subsels1
     C                   seton                                        83        sflclr
     C                   write     subselc1
     C                   setoff                                       818283
      *                                                    81=sfldsp
      *                                                    82=sflend
      *                                                    83=sflclr
     C                   endsr
      /EJECT
      *---------------------------------------------------------------
      * $frsh1 - refresh/fill the subfile for screen 1
      *---------------------------------------------------------------
      *
     C     $frsh1        begsr
      *
      *
     C*    key           setll     f0901lb
     c*    key           setll     e10901lb
     c     key           setll     e10901le
      *
      * This program does not have repositioning; just start the subfile over
      *
     C                   eval      maxrrn = wkplin
      *
      * Load the subfile until you have the required number of records.
      * The number will depend on whether uou are repositioning the
      * subfile or not. Stop if you get to the end of the subfile.
      *
     C*                  dou       svrrn1 >= maxrrn or *in82 = *on
     c*                  dou       svrrn1 >= maxrrn or %eof(e10901lb)
     c                   dou       svrrn1 >= maxrrn or %eof(e10901le)
     C                   exsr      $load1
     C                   enddo
      *
     C                   endsr
      /EJECT
      *---------------------------------------------------------------
      * $load1- load subfile for screen 1
      *---------------------------------------------------------------
      *
     C     $load1        begsr
      *
     C                   eval      hdrrn1 = svrrn1
      *
      * Set the count of records on the subfile page to zero.
      *
     C                   eval      count = 0
      *
      * Fill the subfile until the end of the database file or
      * you have filled all the lines on the subfile page.
      *
     C                   setoff                                       82
     C*                  dou       *in82 = *on or count >= wkplin               Do fill
     c*                  dou       %eof(e10901lb) or count >= wkplin            Do fill
     c                   dou       %eof(e10901le) or count >= wkplin            Do fill
      *
     C*    key           reade     f0901lb                                82
     c*    key           reade     e10901lb
     c     key           reade     e10901le
     C*                  if        *in82 = *off and                             If read
     c*                  if        not %eof(e10901lb) and
     c                   if        not %eof(e10901le) and                       if %found(e10901le)
     C                             gmpec <> 'N' and
     C                             gmpec <> 'I'
     C                   eval      procfl = yes
      *
      * Only include records that match the user's selectors
      *
     C                   if        c1dl01  <> *blank                            If desc
     C     lower:upper   xlate     c1dl01        wkdesc
     C     lower:upper   xlate     gmdl01        wk1desc
     C     wkdesc:wklong scan      wk1desc                                92
     C                   if        *in92 = *off
     C                   eval      procfl = no
     C                   endif
     C                   endif                                                  If desc
      *
      *
     C                   if        procfl = yes                                 If process
      *
     C                   if        c1sub <> *blank and                          If subsidiary
     C                             c1sub <> gmsub
     C                   else
      *
      *
     C                   add       1             count
     C                   add       1             hdrrn1
     C                   eval      hdaid = gmaid
     C                   eval      d1mcu = gmmcu
     C                   eval      d1obj = gmobj
     C                   eval      d1sub = gmsub
     C                   eval      d1dl01 = gmdl01
     C                   write     subsels1
     C                   seton                                        81
      *
      * For positioning, place the subfile relative record number into the
      * sflrcdnbr field (HDPAG1)
      *
     C                   eval      hdpag1 = hdrrn1
     C                   endif                                                  If subsidiary
     C                   endif                                                  If process
     C                   endif                                                  fi %found(e10901le)
     C                   enddo                                                  Do fill
      *
     C                   if        hdrrn1 = 0                                   If no recs
     C                   eval      norecs = yes
     C                   else
     C                   eval      norecs = no
     C                   endif                                                  If no recs
      *
     C                   eval      svrrn1 = hdrrn1
      *
     C                   endsr
      /EJECT
      *---------------------------------------------------------------
      * $exit - end job
      *---------------------------------------------------------------
      *
     C     $exit         begsr
     C                   seton                                        LR
     C                   endsr
      /EJECT
      *---------------------------------------------------------------
      * *inzsr - initialization subroutine
      *---------------------------------------------------------------
      *
     C     *inzsr        begsr
      *
      * Key lists
      *
     C*    key           klist
     C*                  kfld                    c1mcu
     C*                  kfld                    c1obj
      *
     C     key           klist
     C                   kfld                    company
     C                   kfld                    c1mcu
     C                   kfld                    c1obj
      *
      * Parm lists
      *
     C     *entry        plist
     C                   parm                    xxretrn
     C     c1mcu         parm                    xxmcu
     C     c1obj         parm                    xxobj
     C                   parm                    xxsub
     C                   parm                    xxaid
     C                   parm                    xxchar50
     C                   parm                    xxco
      *
     C                   eval      svmcu = c1mcu
     C                   eval      svobj = c1obj
      *
     c                   eval      c1co = %char(xxco)
     c                   eval      company = '00' + c1co
      *
      * To support subfile paging in select windows, the program needs
      * the number of lines on a subfile page.
      *
     C                   eval      wkplin = 8                                   sflpag(0008)
      *
      * Set on the indicator to always position cursor to the 'name'
      * selector field in the control record.
      *
     C                   seton                                        84
      *
      * Execute required window format
      *
     C                   write     assume
      *
     C                   endsr
      /EJECT
