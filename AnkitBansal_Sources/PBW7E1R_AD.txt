// ?------------------------------------------------------------------------------------------------
// ?Synon action diagram for PBW7E1R
// ?Date: 14.08.2025 Time: 03:49:37
// ?------------------------------------------------------------------------------------------------

//?USER: Initialize program

//?***** Change log and comments
DO;

//?CSTAR01 AB 05/31/2024 - Removing QRY Access Path PDNEREL6 Dependency
//?- Replaced 'Val Vndr# for Customr RT' function from 'Customer Ext'
//?- file to the function 'Val Vndr# for Customr RT' from 'Customer Master'
//?E7899 JBB 11/03/16 - Fix Adjustment Amount in original CB
//?- The Adjustment Amount in the Chargeback header record was being
//?  updated with an incorrect amount during the exit processing of
//?  this function.  It was adding the Transaction amount to the
//?  amount paid.  It should have been adding the Transaction Amount
//?  to the Adjustment amount on the CB header record.  Fixed and
//?  tested with a single RB, and multiple RB's.  Both ways updated
//?  the original CB correctly, and the Applied Amount and Remaining
//?  Balance on the Display A/R Header Detail screen (PDC0D1R) are
//?  correct.
//?E5262 JJH 05/16/16 - Rebill
//?- Do Not Create A/R Detail for ARC
//?- New function RTV CHG Apply RB CreditRT - A/R Header function so
//?  that it will update either the Adjustment Type.
//?  Due Date and Transaction Date will be set to the *Job date.
//?E5262 JJH 05/05/16 - Rebill
//?- Copy of A/R Detail - EDT Adjust. for CM/OAC E1
//?- This function modified to create RBL for a Chargeback
//?- Adjustment Type Code defaulted to RBL = Rebill
//?- Adjustment Type Code field changed to Output so user cannot chg
//?- Populate the Cost Center, Object Account, and Subsidary
//?** 06/07/2010 LJB C000789   Change Chargeback Ref# to output only.
//?** Create it by appending A/R Detail seq# to end of invoice#.
//?** Create the Chargeback Header record with this new invoice#.
//?** If sequence# exists in A/R Detail, increment until it is uniqye
//?** and update the PAR. & DTL. context with final result.
//?** This way the A/R Detail should stay in sync with the Header CBs.
//?***
//?** 03/04/2010 LJB E000512  Post install changes
//?** Rename G/L Vendor to G/L Sub-Ledger. Add validation of sub-
//?** ledger if post edit code in JDE = "L"
//?***
//?** 02/18/2010 LJB E000512  New parm added to VAL JDE Account
//?** No.s UP, retrieve and recompile
//?***
//?RMC S00977 11/09/09 Add adj type "WO1' to comp with "WO " et al.
//?RMC S00877 7/22/09 Chg RTV Check invc exists  RT to chk invoice sans compa
//?RMC 12/23/05 get g/l posting company
ENDDO;

EXECUTE FUNCTION(VAL Set Inter. Access  IF) TYPE(EXCINTFUN)                     AC1144606;
PARAMETER('A/R');
PARAMETER(WRK.Company_Number);
PARAMETER(PAR.Warehouse_Code);
PARAMETER(PAR.Allow_Multi_Company);
PARAMETER(PAR.Default_Printer);
PARAMETER(PAR.Salesperson_Code);
{
 //?Execute internal function

 // PAR.User Profile Name = JOB.*USER
 PAR.User_Profile_Name = JOB.*USER;

 EXECUTE FUNCTION(VAL User/Application   IF) TYPE(EXCINTFUN)                     AC1144188;
 PARAMETER(PAR.User_Profile_Name);
 PARAMETER(PAR.Application_Code);
 PARAMETER(PAR.Company_Number);
 PARAMETER(PAR.Warehouse_Code);
 PARAMETER(PAR.Allow_Multi_Company);
 PARAMETER(PAR.Default_Printer);
 PARAMETER(PAR.Salesperson_Code);
 {
  //?Execute internal function

  //?RMC 5/11/09 Rtv default company from user profile --
  //?  Override user code model company if it exists
  EXECUTE FUNCTION(RTV Program Setup w/Co RT) TYPE(RTVOBJ) FILE(CADRREP)          AC1935572;
  PARAMETER(PAR.User_Profile_Name);
  PARAMETER(PAR.Allow_Multi_Company);
  PARAMETER(PAR.Default_Printer);
  PARAMETER(PAR.Salesperson_Code);
  PARAMETER(LCL.Company_Number);
  PARAMETER(PAR.User_Code_Model);
  {
   //?USER: Processing if Data record not found

   // PGM.*Return code = CND.*Record does not exist
   PGM.*Return_code = 'Y2U0005';

   //?USER: Process Data record

   MOVE *ALL (To: PAR From: DB1);

  }

  //?User Profile Record Not found
  CASE;

  // IF PGM.*Return code is *Record does not exist
  IF PGM.*Return_code = 'Y2U0005';

  // Execute function SET Message Queue Dest US.
  EXECUTE FUNCTION(SET Message Queue Dest US) TYPE(EXCUSRSRC) ('USNCUFR');
  {
   C                     MOVEL'*PRV '   ZAPGRL           PREVIOUS
  }

  // Send completion message - 'Application access denied for user &1 in application area &2'
  MESSAGE(USR0810 *COMPLETION);
  MSGPARM(PAR.User_Profile_Name);
  MSGPARM(PAR.Application_Code);

  PGM.*Return_code = 'Y2U9999';

  RETURN;

  ENDIF;

  CASE;

  // IF PAR.User Code Model is equal to blank
  IF PAR.User_Code_Model = *BLANK;

  EXECUTE FUNCTION(RTV Appl. Profile      RT) TYPE(RTVOBJ) FILE(CADTREP)          AC1143177;
  PARAMETER(PAR.User_Profile_Name);
  PARAMETER(PAR.Application_Code);
  PARAMETER(PAR.Company_Number);
  PARAMETER(LCL.Warehouse_Code);
  {
   //?USER: Process Data record

   MOVE *ALL (To: PAR From: DB1);

  }

  // IF *OTHERWISE
  IF *OTHERWISE;

  EXECUTE FUNCTION(RTV Appl. Profile      RT) TYPE(RTVOBJ) FILE(CADTREP)          AC1143177;
  PARAMETER(PAR.User_Code_Model);
  PARAMETER(PAR.Application_Code);
  PARAMETER(PAR.Company_Number);
  PARAMETER(LCL.Warehouse_Code);
  {
   //?USER: Process Data record

   MOVE *ALL (To: PAR From: DB1);

  }

  ENDIF;

  // PAR.Warehouse Code = LCL.Warehouse Code
  PAR.Warehouse_Code = LCL.Warehouse_Code;

  //?Return code when not normal for Application Profile
  CASE;

  // IF PGM.*Return code is *Normal
  IF PGM.*Return_code = *BLANK;

  //?Return code when not normal for Application Profile
  // IF *OTHERWISE
  IF *OTHERWISE;

  // Execute function SET Message Queue Dest US.
  EXECUTE FUNCTION(SET Message Queue Dest US) TYPE(EXCUSRSRC) ('USNCUFR');
  {
   C                     MOVEL'*PRV '   ZAPGRL           PREVIOUS
  }

  // Send completion message - 'Application access denied for user &1 in application area &2'
  MESSAGE(USR0810 *COMPLETION);
  MSGPARM(PAR.User_Profile_Name);
  MSGPARM(PAR.Application_Code);

  PGM.*Return_code = 'Y2U9999';

  RETURN;

  ENDIF;

  //?Override company with User profile control's company if found
  CASE;

  // IF LCL.Company Number is not equal to zero
  IF LCL.Company_Number <> *ZERO;

  // PAR.Company Number = LCL.Company Number
  PAR.Company_Number = LCL.Company_Number;

  //?Get prod warehouse, if the appl got a warehouse
  CASE;

  // IF LCL.Warehouse Code is Not Blanks
  IF LCL.Warehouse_Code <> *BLANK;

  // Call program RTV Prod Whse for Co  XF.
  CALL PROGRAM(RTV Prod Whse for Co  XF) ('PNKDXFR');
  PARAMETER(PAR.Warehouse_Code);
  PARAMETER(LCL.Company_Number);

  ENDIF;

  ENDIF;

 }

 EXECUTE FUNCTION(SET Screen Headings    IF) TYPE(EXCINTFUN)                     AC1248058;
 PARAMETER(PAR.Application_Code);
 {
  //?Execute internal function

  EXECUTE FUNCTION(RTV Applic. Group Desc RT) TYPE(RTVOBJ) FILE(CADNREP)          AC1274118;
  PARAMETER(PAR.Application_Code);
  PARAMETER(WRK.Description);
  {
   //?USER: Process Data record

   CASE;

   // IF DB1.Application Group is Blank
   IF DB1.Application_Group = *BLANK;

   MOVE *ALL (To: PAR From: DB1);

   // IF *OTHERWISE
   IF *OTHERWISE;

   EXECUTE FUNCTION(RTV Application Desc   RT) TYPE(RTVOBJ) FILE(CADNREP)          AC1249881;
   PARAMETER(DB1.Application_Group);
   PARAMETER(PAR.Description);
   {
    //?USER: Processing if Data record not found

    MOVE *ALL (To: PAR From: CON);

    // PGM.*Return code = CND.*Record does not exist
    PGM.*Return_code = 'Y2U0005';

    //?USER: Process Data record

    MOVE *ALL (To: PAR From: DB1);

   }

   ENDIF;

  }

  // WRK.USR Description 40 = WRK.Description
  WRK.USR_Description_40 = WRK.Description;

  // Execute function CLC Center Txt Str 40  US.
  EXECUTE FUNCTION(CLC Center Txt Str 40  US) TYPE(EXCUSRSRC) ('PDYJUFR');
  PARAMETER(WRK.USR_Description_40);
  PARAMETER(WRK.USR_Description_40_2);
  {
   E                    UCT        40  1               CENTER TABLE
   C                     MOVEA#IDSC4    UCT              LOAD ARRAY
   C                     Z-ADD40        UX      20       SET COUNTER
   C           UX        DOWGT0
   C           UCT,UX    IFEQ ' '
   C                     SUB  1         UX
   C                     ELSE
   C                     Z-ADDUX        UXH     20
   C                     Z-ADD0         UX
   C                     END
   C                     END
   C           40        SUB  UXH       UX
   C           UX        DIV  2         UX
   C           UX        IFGT 0
   C                     MOVE *BLANKS   UCT
   C                     MOVEA#IDSC4    UCT,UX
   C                     END
   C                     MOVEAUCT       #ODE40           LOAD OUTPUT
  }

  // Execute function MOV Appl Desc-Co Head  US.
  EXECUTE FUNCTION(MOV Appl Desc-Co Head  US) TYPE(EXCUSRSRC) ('PDYKUFR');
  PARAMETER(WRK.USR_Description_40_2);
  {
   C                     MOVE #IDE40    ##CMP
  }

 }

}


//?CSTAR01 - Below initialization was done to avoid decimal data error on F3
// PAR.Remaining Balance Due = CON.*ZERO
PAR.Remaining_Balance_Due = *ZERO;

// PAR.Invoice Number RB = CON.*ZERO
PAR.Invoice_Number_RB = *ZERO;

//?USER: Initialize key screen

// KEY.Company Number = PAR.Company Number
KEY.Company_Number = PAR.Company_Number;

// KEY.Invoice Number = PAR.Invoice Number
KEY.Invoice_Number = PAR.Invoice_Number;

// KEY.Invoice Suffix = PAR.Invoice Suffix
KEY.Invoice_Suffix = PAR.Invoice_Suffix;

EXECUTE FUNCTION(RTV Next Seq. No.      RT) TYPE(RTVOBJ) FILE(ARBECPP)          AC1336580;
PARAMETER(KEY.Company_Number);
PARAMETER(KEY.Invoice_Number);
PARAMETER(KEY.Invoice_Suffix);
PARAMETER(KEY.Sequence_Number);
{
 //?USER: Processing if Data record not found

 // PAR.Sequence Number = CON.1
 PAR.Sequence_Number = 1;

 //?USER: Process Data record

 // PAR.Sequence Number = DB1.Sequence Number
 PAR.Sequence_Number = DB1.Sequence_Number;

 //?USER: Exit processing

 // PAR.Sequence Number = PAR.Sequence Number + CON.1
 PAR.Sequence_Number = PAR.Sequence_Number + 1;

}


// PAR.Access Denied (Y/N) = CND.yes
PAR.Access_Denied_Y_N = 'Y';

//?USER: Initialize detail screen (new record)

// KEY.Accounting Company Number = PAR.Accounting Company Number
KEY.Company_Number = PAR.Company_Number;

EXECUTE FUNCTION(RTV Company Name       RT) TYPE(RTVOBJ) FILE(CAABREP)          AC1255767;
PARAMETER(KEY.Company_Number);
PARAMETER(DTL.Company_Name);
{
 //?USER: Processing if Data record not found

 MOVE *ALL (To: PAR From: CON);

 //?USER: Process Data record

 MOVE *ALL (To: PAR From: DB1);

}


// DTL.Transaction Amount = PAR.Transaction Amount
DTL.Transaction_Amount = PAR.Transaction_Amount;

//?** Put the A/R customer # and name on the screen
// DTL.A/R Customer Number = PAR.A/R Customer Number
DTL.AR_Customer_Number = PAR.AR_Customer_Number;

EXECUTE FUNCTION(Customer Name DRV) TYPE(DRVFLD)                                AC1631131;
PARAMETER(DTL.Customer_Name_DRV);
PARAMETER(DTL.AR_Customer_Number);
{
 //?Calculate derived field

 EXECUTE FUNCTION(RTV Customer Name      RT) TYPE(RTVOBJ) FILE(CABBREP)          AC1108159;
 PARAMETER(PAR.Ship_To_Customer);
 PARAMETER(PAR.Customer_Name_DRV);
 {
  //?USER: Processing if Data record not found

  MOVE *ALL (To: PAR From: CON);

  // PGM.*Return code = CND.*Record does not exist
  PGM.*Return_code = 'Y2U0005';

  //?USER: Process Data record

  MOVE *ALL (To: PAR From: DB1);

 }

}


//?4/26/2008 slm tfs040 CHANGES
//?              Get the exempt flag from the 1st sales history
CASE;

// IF DTL.Invoice Suffix is Credit Memos
IF DTL.Invoice_Suffix = 'CM';

// Call program Rtv TF Exempt By Inv  XF.
CALL PROGRAM(Rtv TF Exempt By Inv  XF) ('PMUJXFR');
PARAMETER(PAR.Invoice_Number);
PARAMETER(DTL.A_R_TF_Exempt_Code);

// IF *OTHERWISE
IF *OTHERWISE;

//?6/02/2008 RMC tfs040 CB and OA wont be in Sales history, so get from Cust
EXECUTE FUNCTION(Rtv Customer ExemptFN/NE) TYPE(RTVOBJ) FILE(PDNEREP)           AC1876697;
PARAMETER(PAR.AR_Customer_Number);
PARAMETER(DTL.A_R_TF_Exempt_Code);
{
 //?USER: Initialize routine

 // PAR.Customer TF Exempt Code = CND.Not Exempt
 PAR.Customer_TF_Exempt_Code = 'NE';

 //?USER: Processing if Data record not found

 // PAR.Customer TF Exempt Code = CND.Not Exempt
 PAR.Customer_TF_Exempt_Code = 'NE';

 //?USER: Process Data record

 CASE;

 // IF DB1.Customer TF Exempt Code is *ALL values
 IF DB1.Customer_TF_Exempt_Code = 'NE'/'PC'/'EC'/'EP';

 // PAR.Customer TF Exempt Code = DB1.Customer TF Exempt Code
 PAR.Customer_TF_Exempt_Code = DB1.Customer_TF_Exempt_Code;

 // IF *OTHERWISE
 IF *OTHERWISE;

 // PAR.Customer TF Exempt Code = CND.Not Exempt
 PAR.Customer_TF_Exempt_Code = 'NE';

 ENDIF;

}


ENDIF;

// LCL.A/R TF Exempt Code = DTL.A/R TF Exempt Code
LCL.A_R_TF_Exempt_Code = DTL.A_R_TF_Exempt_Code;

//?E5262 JJH 05/05/16 - Default Adjustment Type Code = RBL
// DTL.Adjustment Type Code = CND.Rebill
DTL.Adjustment_Type_Code = 'RB';

//?E5262 JJH 05/05/16 - Default Cost Center, Object Account, Subsidary
EXECUTE FUNCTION(RTV A/R Adjustment TypeRT) TYPE(RTVOBJ) FILE(PDJ3CPP)          AC2122193;
PARAMETER(KEY.Company_Number);
PARAMETER(DTL.Adjustment_Type_Code);
PARAMETER(DTL.Adjustment_Description);
PARAMETER(NLL.Effect_on_Account);
PARAMETER(LCL.G_L_ID_Code_JDE);
PARAMETER(NLL.Adjustment_Limit_Amount);
PARAMETER(NLL.Cash_Adj);
PARAMETER(NLL.User_Enter_G_L_Status);
PARAMETER(NLL.System_Control);
PARAMETER(NLL.EDI_Status_1);
PARAMETER(NLL.EDI_Status_2);
PARAMETER(NLL.EDI_Status_3);
PARAMETER(NLL.Record_Status);
{
 //?USER: Processing if Data record not found

 // PGM.*Return code = CND.*Record does not exist
 PGM.*Return_code = 'Y2U0005';

 //?USER: Process Data record

 MOVE *ALL (To: PAR From: DB1);

}


// LCL.G/L ID Code Alpha = CVTVAR(LCL.G/L ID Code JDE)
LCL.G_L_ID_Code_Alpha = CVTVAR(LCL.G_L_ID_Code_JDE);

// Call program VAL Acct ID JDE-8 dgt  UP.
CALL PROGRAM(VAL Acct ID JDE-8 dgt  UP) ('ARACTRET');
PARAMETER(LCL.G_L_ID_Code_Alpha);
PARAMETER(DTL.Cost_Center);
PARAMETER(DTL.Object_Account);
PARAMETER(DTL.Subsidiary);
PARAMETER(DTL.Description);
PARAMETER(DTL.G_L_Posting_Company);
PARAMETER(PAR.JDE_Posting_Edit_Code_USR);
PARAMETER(LCL.Error_Return_text);

//?USER: Validate detail screen fields

// PAR.Error Status = CND.no
PAR.Error_Status = 'N';

//?** Validate Sub Ledger Required                       E000512
// LCL.JDE Posting Edit Code USR = CND.Ledger Required
LCL.JDE_Posting_Edit_Code_USR = 'L';

//?F13=Chart of Accounts
CASE;

// IF DTL.*CMD key is CF13
IF DTL.*CMD_key = '13';

// PAR.Company Number Alpha = CVTVAR(DTL.Company Number)
PAR.Company_Number_Alpha = CVTVAR(DTL.Company_Number);

// Call program SEL Chart of Accounts  UP.
CALL PROGRAM(SEL Chart of Accounts  UP) ('ARACTSEL');
PARAMETER(PAR.Company_Number_Alpha);
PARAMETER(DTL.Cost_Center);
PARAMETER(DTL.Object_Account);
PARAMETER(DTL.Subsidiary);
PARAMETER(DTL.G_L_ID_Code_JDE);
PARAMETER(DTL.Description);
PARAMETER(WRK.Error_Return_text);

// PGM.*Reload subfile = CND.*YES
PGM.*Reload_subfile = 'Y';

ENDIF;

//?F4 = Prompt for G/L Vendor#
CASE;

// IF DTL.*CMD key is *Prompt
IF DTL.*CMD_key = '04';

CASE;

// IF PGM.*Cursor field <IS> DTL.G/L Vendor Number USR
IF PGM.*Cursor_field = DTL.G_L_Vendor_Number_USR;

// Call program SEL A/R Cust W/Vendor# SR.
CALL PROGRAM(SEL A/R Cust W/Vendor# SR) ('PMFRSRR');
PARAMETER(DTL.AR_Customer_Number);
PARAMETER(DTL.G_L_Vendor_Number_USR);

// PGM.*Reload subfile = CND.*YES
PGM.*Reload_subfile = 'Y';

ENDIF;

ENDIF;

//?** Validate G/L Vendor number if entered     E00039
CASE;

// IF DTL.G/L Vendor Number USR is Entered
IF DTL.G_L_Vendor_Number_USR <> *ZERO;

//?CSTAR01 Change St:Replace 'Customer Ext' logical with 'Customer Master's
EXECUTE FUNCTION(Val Vndr# for Customr RT) TYPE(RTVOBJ) FILE(CABBREP)           AC2228000;
PARAMETER(DTL.AR_Customer_Number);
PARAMETER(*ZERO);
PARAMETER(DTL.G_L_Vendor_Number_USR);
{
 //?USER: Initialize routine

 // PGM.*Return code = CND.*Record does not exist
 PGM.*Return_code = 'Y2U0005';

 //?USER: Processing if Data record not found

 // PGM.*Return code = CND.*Record does not exist
 PGM.*Return_code = 'Y2U0005';

 //?USER: Process Data record

 // LCL.Customer G_L Vendor Num = CND.Not Entered
 LCL.Customer_G_L_Vendor_Num = *ZERO;

 EXECUTE FUNCTION(Rtv Broker/ GL Vendor RT) TYPE(RTVOBJ) FILE(PDNEREP)           AC1684471;
 PARAMETER(DB1.Ship_To_Customer);
 PARAMETER(LCL.Customer_G_L_Vendor_Num);
 {
  //?USER: Processing if Data record not found

  MOVE *ALL (To: PAR From: CON);

  //?USER: Process Data record

  MOVE *ALL (To: PAR From: DB1);

 }

 // PGM.*Return code = CND.*Record does not exist
 PGM.*Return_code = 'Y2U0005';

 CASE;

 // IF LCL.Customer G_L Vendor Num EQ PAR.Customer G_L Vendor Num
 IF LCL.Customer_G_L_Vendor_Num = PAR.Customer_G_L_Vendor_Num;

 // PGM.*Return code = CND.*Record already exists
 PGM.*Return_code = 'Y2U0003';

 QUIT;

 ENDIF;

}


//?CSTAR01 Changes End
CASE;

// IF PGM.*Return code is *Record does not exist
IF PGM.*Return_code = 'Y2U0005';

// Send error message - 'G/L Sub-Ledger code (G/L Vendor #) is invalid'
ERROR(USR4118);
MSGPARM(DTL.G_L_Vendor_Number_USR);

// PAR.Error Status = CND.yes
PAR.Error_Status = 'Y';

// IF *OTHERWISE
IF *OTHERWISE;

// DTL.G/L Sub-Ledger Code = DTL.G/L Vendor Number USR
DTL.G_L_Sub_Ledger_Code = DTL.G_L_Vendor_Number_USR;

// PAR.G/L Sub-Ledger Code = DTL.G/L Vendor Number USR
PAR.G_L_Sub_Ledger_Code = DTL.G_L_Vendor_Number_USR;

ENDIF;

ENDIF;

// PAR.Access Denied (Y/N) = CND.no
PAR.Access_Denied_Y_N = 'N';

EXECUTE FUNCTION(RTV Adj Limits         RT) TYPE(RTVOBJ) FILE(PDJ3CPP)          AC1334715;
PARAMETER(DTL.Company_Number);
PARAMETER(DTL.Adjustment_Type_Code);
PARAMETER(DTL.Adjustment_Description);
PARAMETER(DTL.Effect_on_Account);
PARAMETER(DTL.G_L_ID_Code_JDE);
PARAMETER(PAR.Adjustment_Limit_Amount);
PARAMETER(DTL.Cash_Adj);
PARAMETER(PAR.User_Enter_G_L_Status);
{
 //?USER: Processing if Data record not found

 // PGM.*Return code = CND.*Record does not exist
 PGM.*Return_code = 'Y2U0005';

 //?USER: Process Data record

 MOVE *ALL (To: PAR From: DB1);

}


EXECUTE FUNCTION(RTV Company Name       RT) TYPE(RTVOBJ) FILE(CAABREP)          AC1255767;
PARAMETER(DTL.Company_Number);
PARAMETER(DTL.Company_Name);
{
 //?USER: Processing if Data record not found

 MOVE *ALL (To: PAR From: CON);

 //?USER: Process Data record

 MOVE *ALL (To: PAR From: DB1);

}


EXECUTE FUNCTION(RTV Check Active Adj   RT) TYPE(RTVOBJ) FILE(PDJ3CPP)          AC1399560;
PARAMETER(DTL.Company_Number);
PARAMETER(DTL.Adjustment_Type_Code);
PARAMETER(WRK.System_Control);
PARAMETER(WRK.Record_Status);
{
 //?USER: Processing if Data record not found

 // PGM.*Return code = CND.*Record does not exist
 PGM.*Return_code = 'Y2U0005';

 //?USER: Process Data record

 // PGM.*Return code = CND.*Record already exists
 PGM.*Return_code = 'Y2U0003';

 MOVE *ALL (To: PAR From: DB1);

}


//?Adjustment Code N/F
CASE;

// IF PGM.*Return code is *Record does not exist
IF PGM.*Return_code = 'Y2U0005';

// Send error message - 'AR Adjustment Type not found.'
ERROR(USR2041);
MSGPARM(DTL.Adjustment_Type_Code);

// PAR.Error Status = CND.yes
PAR.Error_Status = 'Y';

ENDIF;

//?Transaction amount greater than adjustment limit
CASE;

// IF DTL.Transaction Amount GT PAR.Transaction Amount
IF DTL.Transaction_Amount > PAR.Transaction_Amount;

// Send error message - 'Adjustment Amount cannot be greater than Remaining Due of &1.'
ERROR(USR3443);
MSGPARM(PAR.Transaction_Amount);

// PAR.Error Status = CND.yes
PAR.Error_Status = 'Y';

//?Transaction amount greater than adjustment limit
// IF DTL.Transaction Amount GT PAR.Adjustment Limit Amount
IF DTL.Transaction_Amount > PAR.Adjustment_Limit_Amount;

// AND PAR.Adjustment Limit Amount is Greater than zero
AND PAR.Adjustment_Limit_Amount > *ZERO;

// Send error message - 'Adj. > Adj. Limit Amount'
ERROR(USR2066);
MSGPARM(DTL.Transaction_Amount);

// PAR.Error Status = CND.yes
PAR.Error_Status = 'Y';

ENDIF;

//?Cash Adjustment not allowed
CASE;

// IF DTL.Cash/Adj is Cash Adjustment
IF DTL.Cash_Adj = 'CSH';

// Send error message - 'Cash must be applied thru a bank deposit record not thru the adjustment pro
ERROR(USR2156);
MSGPARM(DTL.Adjustment_Type_Code);

// PAR.Error Status = CND.yes
PAR.Error_Status = 'Y';

ENDIF;

//?Check for Invalid adjustment types
CASE;

// IF DTL.Adjustment Type Code is A/R Entry by Customer
IF DTL.Adjustment_Type_Code = 'ARC';

// OR DTL.Adjustment Type Code is A/R Miscellaneous Acct
OR DTL.Adjustment_Type_Code = 'ARM';

// OR DTL.Adjustment Type Code is ACM Apply Credit Memo
OR DTL.Adjustment_Type_Code = 'ACM';

// OR DTL.Adjustment Type Code is CRM Credit Memo
OR DTL.Adjustment_Type_Code = 'CRM';

// OR DTL.Adjustment Type Code is DBM Debit Memo
OR DTL.Adjustment_Type_Code = 'DBM';

// OR DTL.Adjustment Type Code is INV Invoice
OR DTL.Adjustment_Type_Code = 'INV';

// OR DTL.Adjustment Type Code is OA On Account Cash
OR DTL.Adjustment_Type_Code = 'OA';

// Send error message - 'Adjustment Type is invalid for this operation.'
ERROR(USR2263);
MSGPARM(DTL.Adjustment_Type_Code);

// PAR.Error Status = CND.yes
PAR.Error_Status = 'Y';

ENDIF;

//?User Defined G/L Code
CASE;

// IF PAR.User Enter G/L Status is yes
IF PAR.User_Enter_G_L_Status = 'Y';

CASE;

// IF DTL.Cost Center. . . . . . . is Not Entered
IF DTL.Cost_Center = *BLANK;

// AND DTL.Object Account . . . . . is Not Entered
AND DTL.Object_Account = *BLANK;

// AND DTL.Subsidiary . . . . . . . is Not Entered
AND DTL.Subsidiary = *BLANK;

// Send error message - 'G/L Account Must be entered.'
ERROR(USR2051);
MSGPARM(DTL.Cost_Center);
MSGPARM(DTL.Object_Account);
MSGPARM(DTL.Subsidiary);

// PAR.Error Status = CND.yes
PAR.Error_Status = 'Y';

// PAR.Access Denied (Y/N) = CND.yes
PAR.Access_Denied_Y_N = 'Y';

// IF *OTHERWISE
IF *OTHERWISE;

EXECUTE FUNCTION(RTV Salesperson        RT) TYPE(RTVOBJ) FILE(ARBDCPP)          AC1354262;
PARAMETER(PAR.Company_Number);
PARAMETER(PAR.Invoice_Number);
PARAMETER(PAR.Invoice_Suffix);
PARAMETER(PAR.Salesperson_Code);
{
 //?USER: Process Data record

 MOVE *ALL (To: PAR From: DB1);

}


// PAR.Company Number Alpha = CVTVAR(PAR.Accounting Company Number)
PAR.Company_Number_Alpha = CVTVAR(PAR.Company_Number);

// Call program VAL JDE Account No.s   UP.
CALL PROGRAM(VAL JDE Account No.s   UP) ('ARACTEDT');
PARAMETER(PAR.Company_Number_Alpha);
PARAMETER(DTL.Cost_Center);
PARAMETER(DTL.Object_Account);
PARAMETER(DTL.Subsidiary);
PARAMETER(DTL.G_L_ID_Code_JDE);
PARAMETER(PAR.JDE_Posting_Edit_Code_USR);
PARAMETER(DTL.Description);
PARAMETER(WRK.Error_Return_text);

//?G/L Account Code Error
CASE;

// IF WRK.Error Return text is Error Return
IF WRK.Error_Return_text = 'ERR';

// Send error message - 'G/L Account Code is in Error'
ERROR(USR2070);
MSGPARM(WRK.G_L_Alpha_Code);

// PAR.Error Status = CND.yes
PAR.Error_Status = 'Y';

// PAR.Access Denied (Y/N) = CND.yes
PAR.Access_Denied_Y_N = 'Y';

ENDIF;

//?** If G/L Posting Code = "L" then Sub Ledger is required  E000512
CASE;

// IF PAR.JDE Posting Edit Code USR EQ LCL.JDE Posting Edit Code USR
IF PAR.JDE_Posting_Edit_Code_USR = LCL.JDE_Posting_Edit_Code_USR;

//?** Error if Sub Ledger is zeros and required          E000512
CASE;

// IF DTL.G/L Vendor Number USR is Not Entered
IF DTL.G_L_Vendor_Number_USR = *ZERO;

// Send error message - 'G/L Sub-Ledger code (G/L Vendor #) is Required'
ERROR(USR4263);
MSGPARM(DTL.G_L_Vendor_Number_USR);

ENDIF;

//?** If G/L Posting Code = "L" then Sub Ledger is required  E000512
// IF *OTHERWISE
IF *OTHERWISE;

//?** Error if Sub Ledger is entered & not required      E000512
CASE;

// IF DTL.G/L Vendor Number USR is Entered
IF DTL.G_L_Vendor_Number_USR <> *ZERO;

// Send error message - 'G/L SubLedger Not Req'd, should be zeros'
ERROR(USR4264);
MSGPARM(DTL.G_L_Vendor_Number_USR);

ENDIF;

ENDIF;

ENDIF;

//?User Defined G/L Code
// IF *OTHERWISE
IF *OTHERWISE;

//?** prompting filled in added g/l posting co-not part of E00039
// Call program VAL Acct ID JDE-8 dgt  UP.
CALL PROGRAM(VAL Acct ID JDE-8 dgt  UP) ('ARACTRET');
PARAMETER(DTL.G_L_ID_Code_JDE);
PARAMETER(WRK.Cost_Center);
PARAMETER(WRK.Object_Account);
PARAMETER(WRK.Subsidiary);
PARAMETER(DTL.Description);
PARAMETER(DTL.G_L_Posting_Company);
PARAMETER(PAR.JDE_Posting_Edit_Code_USR);
PARAMETER(LCL.Error_Return_text);

//?** If G/L Posting Code = "L" then Sub Ledger is required  E000512
CASE;

// IF PAR.JDE Posting Edit Code USR EQ LCL.JDE Posting Edit Code USR
IF PAR.JDE_Posting_Edit_Code_USR = LCL.JDE_Posting_Edit_Code_USR;

//?** Error if Sub Ledger is zeros and required          E000512
CASE;

// IF DTL.G/L Vendor Number USR is Not Entered
IF DTL.G_L_Vendor_Number_USR = *ZERO;

// Send error message - 'G/L Sub-Ledger code (G/L Vendor #) is Required'
ERROR(USR4263);
MSGPARM(DTL.G_L_Vendor_Number_USR);

ENDIF;

//?** If G/L Posting Code = "L" then Sub Ledger is required  E000512
// IF *OTHERWISE
IF *OTHERWISE;

//?** Error if Sub Ledger is entered & not required      E000512
CASE;

// IF DTL.G/L Vendor Number USR is Entered
IF DTL.G_L_Vendor_Number_USR <> *ZERO;

// Send error message - 'G/L SubLedger Not Req'd, should be zeros'
ERROR(USR4264);
MSGPARM(DTL.G_L_Vendor_Number_USR);

ENDIF;

ENDIF;

ENDIF;

//?** Create Chargeback Ref#. If it exists, increment til valid. C000789
//?** Create Reference Number for Chargebacks
CASE;

// IF WRK.Company Organization is Daily's
IF WRK.Company_Organization = 'D';

//?** Create Reference Number for Chargebacks            C000789
CASE;

// IF DTL.Adjustment Type Code is Chargeback
IF ( DTL.Adjustment_Type_Code = 'CB';

// OR DTL.Adjustment Type Code is Accrual Chargeback
OR DTL.Adjustment_Type_Code = 'ACB' );

//?** Convert invoice# to 5 character field
// WRK.Invoice Number Alpha USR = CVTVAR(DTL.Invoice Number)
WRK.Invoice_Number_Alpha_USR = CVTVAR(DTL.Invoice_Number);

// WRK.Text USR 5 = SUBSTRING(WRK.Invoice Number Alpha USR,CON.3,CON.5)
WRK.Text_USR_5 = SUBSTRING(WRK.Invoice_Number_Alpha_USR:3:5);

//?** Is sequence#: 1 or 2 digits. Convert to character
// WRK.Sequence Number = DTL.Sequence Number
WRK.Sequence_Number = DTL.Sequence_Number;

// WRK.Text 3 Length USR = CVTVAR(WRK.Sequence Number)
WRK.Text_3_Length_USR = CVTVAR(WRK.Sequence_Number);

// WRK.Byte = SUBSTRING(WRK.Text 3 Length USR,CON.2,CON.1)
WRK.Byte = SUBSTRING(WRK.Text_3_Length_USR:2:1);

// WRK.Number 1.0 USR = CVTVAR(WRK.Byte)
WRK.Number_1_0_USR = CVTVAR(WRK.Byte);

//?** Format the A/R Header CB Invoice Number
CASE;

// IF WRK.Number 1.0 USR is EQ 0
IF WRK.Number_1_0_USR = *ZERO;

//?** If sequence number is only 1 digit, format 6 digits + 1 leading zero
// WRK.Number 1.0 USR = WRK.Sequence Number
WRK.Number_1_0_USR = WRK.Sequence_Number;

// WRK.Text 1 Length USR = CVTVAR(WRK.Number 1.0 USR)
WRK.Text_1_Length_USR = CVTVAR(WRK.Number_1_0_USR);

// WRK.Text USR 6 = CONCAT(WRK.Text USR 5,WRK.Text 1 Length USR,CON.*ZERO)
WRK.Text_USR_6 = WRK.Text_USR_5 + WRK.Text_1_Length_USR (*ZERO);

// WRK.USR number = CVTVAR(WRK.Text USR 6)
WRK.USR_number = CVTVAR(WRK.Text_USR_6);

//?** Put the 6.0 into a 7.0 before converting
// WRK.Number Value - 7 = WRK.USR number
WRK.Number_Value_7 = WRK.USR_number;

// WRK.Invoice Number Alpha USR = CVTVAR(WRK.Number Value - 7)
WRK.Invoice_Number_Alpha_USR = CVTVAR(WRK.Number_Value_7);

//?** Format the A/R Header CB Invoice Number
// IF *OTHERWISE
IF *OTHERWISE;

//?** If sequence number is 2 digits, format total of 7 digits
// WRK.USR Number 2.0 = WRK.Sequence Number
WRK.USR_Number_2_0 = WRK.Sequence_Number;

// WRK.Text 2 Length USR = CVTVAR(WRK.USR Number 2.0)
WRK.Text_2_Length_USR = CVTVAR(WRK.USR_Number_2_0);

//?** Concat sequence# to end of invoice number
// WRK.Invoice Number Alpha USR = CONCAT(WRK.Text USR 5,WRK.Text 2 Length USR,CON.*ZERO)
WRK.Invoice_Number_Alpha_USR = WRK.Text_USR_5 + WRK.Text_2_Length_USR (*ZERO);

ENDIF;

//?** Convert back to numerical and put into Chargeback Ref#
// DTL.USR Reference number = CVTVAR(WRK.Invoice Number Alpha USR)
DTL.USR_Reference_number = CVTVAR(WRK.Invoice_Number_Alpha_USR);

EXECUTE FUNCTION(RTV Check invc exists  RT) TYPE(RTVOBJ) FILE(ARBDCPP)          AC1263564;
PARAMETER(DTL.USR_Reference_number);
{
 //?USER: Processing if Data record not found

 // PGM.*Return code = CND.*Record does not exist
 PGM.*Return_code = 'Y2U0005';

 //?USER: Process Data record

 // PGM.*Return code = CND.*Record already exists
 PGM.*Return_code = 'Y2U0003';

}


//?** If CB # is a duplicate, increment till valid.
// DOW PGM.*Return code is *Record already exists
DOW PGM.*Return_code = 'Y2U0003';

//?** Add 1 to sequence number
// WRK.Sequence Number = WRK.Sequence Number + CON.1
WRK.Sequence_Number = WRK.Sequence_Number + 1;

// WRK.Text 3 Length USR = CVTVAR(WRK.Sequence Number)
WRK.Text_3_Length_USR = CVTVAR(WRK.Sequence_Number);

// WRK.Byte = SUBSTRING(WRK.Text 3 Length USR,CON.2,CON.1)
WRK.Byte = SUBSTRING(WRK.Text_3_Length_USR:2:1);

// WRK.Number 1.0 USR = CVTVAR(WRK.Byte)
WRK.Number_1_0_USR = CVTVAR(WRK.Byte);

//?** Format the A/R Header CB Invoice Number
CASE;

// IF WRK.Number 1.0 USR is EQ 0
IF WRK.Number_1_0_USR = *ZERO;

//?** If sequence number is only 1 digit, format invoice + sequence
// WRK.Number 1.0 USR = WRK.Sequence Number
WRK.Number_1_0_USR = WRK.Sequence_Number;

// WRK.Text 1 Length USR = CVTVAR(WRK.Number 1.0 USR)
WRK.Text_1_Length_USR = CVTVAR(WRK.Number_1_0_USR);

// WRK.Text USR 6 = CONCAT(WRK.Text USR 5,WRK.Text 1 Length USR,CON.*ZERO)
WRK.Text_USR_6 = WRK.Text_USR_5 + WRK.Text_1_Length_USR (*ZERO);

// WRK.USR number = CVTVAR(WRK.Text USR 6)
WRK.USR_number = CVTVAR(WRK.Text_USR_6);

//?** Put the 6.0 into a 7.0 before converting
// WRK.Number Value - 7 = WRK.USR number
WRK.Number_Value_7 = WRK.USR_number;

// WRK.Invoice Number Alpha USR = CVTVAR(WRK.Number Value - 7)
WRK.Invoice_Number_Alpha_USR = CVTVAR(WRK.Number_Value_7);

//?** Convert back to numerical and put into Chargeback Ref#
//?** Update PAR context so A/R Detail stays in sync
// DTL.USR Reference number = CVTVAR(WRK.Invoice Number Alpha USR)
DTL.USR_Reference_number = CVTVAR(WRK.Invoice_Number_Alpha_USR);

//?** Format the A/R Header CB Invoice Number
// IF *OTHERWISE
IF *OTHERWISE;

//?** If sequence number is 2 digits, format total of 7 digits
// WRK.USR Number 2.0 = WRK.Sequence Number
WRK.USR_Number_2_0 = WRK.Sequence_Number;

// WRK.Text 2 Length USR = CVTVAR(WRK.USR Number 2.0)
WRK.Text_2_Length_USR = CVTVAR(WRK.USR_Number_2_0);

//?** Concat sequence# to end of invoice number
// WRK.Invoice Number Alpha USR = CONCAT(WRK.Text USR 5,WRK.Text 2 Length USR,CON.*ZERO)
WRK.Invoice_Number_Alpha_USR = WRK.Text_USR_5 + WRK.Text_2_Length_USR (*ZERO);

//?** Convert back to numerical and put into Chargeback Ref#
//?** Update
// DTL.USR Reference number = CVTVAR(WRK.Invoice Number Alpha USR)
DTL.USR_Reference_number = CVTVAR(WRK.Invoice_Number_Alpha_USR);

ENDIF;

//?** Update  sequence
// DTL.Sequence Number = WRK.Sequence Number
DTL.Sequence_Number = WRK.Sequence_Number;

EXECUTE FUNCTION(RTV Check invc exists  RT) TYPE(RTVOBJ) FILE(ARBDCPP)          AC1263564;
PARAMETER(DTL.USR_Reference_number);
{
 //?USER: Processing if Data record not found

 // PGM.*Return code = CND.*Record does not exist
 PGM.*Return_code = 'Y2U0005';

 //?USER: Process Data record

 // PGM.*Return code = CND.*Record already exists
 PGM.*Return_code = 'Y2U0003';

}


ENDDO;

ENDIF;

//?** Create Reference Number for Chargebacks
// IF *OTHERWISE
IF *OTHERWISE;

//?** Otherwise, if Seaboard or HPB:
//?** Create Reference Number for Chargebacks            C000789
CASE;

// IF DTL.Adjustment Type Code is Chargeback
IF ( DTL.Adjustment_Type_Code = 'CB';

// OR DTL.Adjustment Type Code is Accrual Chargeback
OR DTL.Adjustment_Type_Code = 'ACB' );

//?** Convert invoice# to 6 character field
// WRK.Invoice Number Alpha USR = CVTVAR(DTL.Invoice Number)
WRK.Invoice_Number_Alpha_USR = CVTVAR(DTL.Invoice_Number);

// WRK.Invoice Number 6 USR = SUBSTRING(WRK.Invoice Number Alpha USR,CON.2,CON.6)
WRK.Invoice_Number_6_USR = SUBSTRING(WRK.Invoice_Number_Alpha_USR:2:6);

//?** Convert sequence# to 1 character field
// WRK.Sequence Number = DTL.Sequence Number
WRK.Sequence_Number = DTL.Sequence_Number;

// WRK.Number 1.0 USR = WRK.Sequence Number
WRK.Number_1_0_USR = WRK.Sequence_Number;

// WRK.Text 1 Length USR = CVTVAR(WRK.Number 1.0 USR)
WRK.Text_1_Length_USR = CVTVAR(WRK.Number_1_0_USR);

//?** Concat sequence# to end of invoice number
// WRK.Invoice Number Alpha USR = CONCAT(WRK.Invoice Number 6 USR,WRK.Text 1 Length USR,CON.*ZERO)
WRK.Invoice_Number_Alpha_USR = WRK.Invoice_Number_6_USR + WRK.Text_1_Length_USR (*ZERO);

//?** Convert back to numerical and put into Chargeback Ref#
// DTL.USR Reference number = CVTVAR(WRK.Invoice Number Alpha USR)
DTL.USR_Reference_number = CVTVAR(WRK.Invoice_Number_Alpha_USR);

EXECUTE FUNCTION(RTV Check invc exists  RT) TYPE(RTVOBJ) FILE(ARBDCPP)          AC1263564;
PARAMETER(DTL.USR_Reference_number);
{
 //?USER: Processing if Data record not found

 // PGM.*Return code = CND.*Record does not exist
 PGM.*Return_code = 'Y2U0005';

 //?USER: Process Data record

 // PGM.*Return code = CND.*Record already exists
 PGM.*Return_code = 'Y2U0003';

}


//?** If CB # is a duplicate, increment till valid.
// DOW PGM.*Return code is *Record already exists
DOW PGM.*Return_code = 'Y2U0003';

//?** Add 1 to sequence number
// WRK.Sequence Number = WRK.Sequence Number + CON.1
WRK.Sequence_Number = WRK.Sequence_Number + 1;

// WRK.Number 1.0 USR = WRK.Sequence Number
WRK.Number_1_0_USR = WRK.Sequence_Number;

// WRK.Text 1 Length USR = CVTVAR(WRK.Number 1.0 USR)
WRK.Text_1_Length_USR = CVTVAR(WRK.Number_1_0_USR);

//?** Concat sequence# to end of invoice number
// WRK.Invoice Number Alpha USR = CON.*BLANK
WRK.Invoice_Number_Alpha_USR = *BLANK;

// WRK.Invoice Number Alpha USR = CONCAT(WRK.Invoice Number 6 USR,WRK.Text 1 Length USR,CON.*ZERO)
WRK.Invoice_Number_Alpha_USR = WRK.Invoice_Number_6_USR + WRK.Text_1_Length_USR (*ZERO);

//?** Convert back to numerical and put into Chargeback Ref#
//?** Update PAR context so A/R Detail stays in sync
// DTL.USR Reference number = CVTVAR(WRK.Invoice Number Alpha USR)
DTL.USR_Reference_number = CVTVAR(WRK.Invoice_Number_Alpha_USR);

// DTL.Sequence Number = WRK.Sequence Number
DTL.Sequence_Number = WRK.Sequence_Number;

EXECUTE FUNCTION(RTV Check invc exists  RT) TYPE(RTVOBJ) FILE(ARBDCPP)          AC1263564;
PARAMETER(DTL.USR_Reference_number);
{
 //?USER: Processing if Data record not found

 // PGM.*Return code = CND.*Record does not exist
 PGM.*Return_code = 'Y2U0005';

 //?USER: Process Data record

 // PGM.*Return code = CND.*Record already exists
 PGM.*Return_code = 'Y2U0003';

}


ENDDO;

ENDIF;

ENDIF;

// WRK.Transaction Amount = DTL.Transaction Amount
WRK.Transaction_Amount = DTL.Transaction_Amount;

// LCL.Transaction Amount = DTL.Transaction Amount
LCL.Transaction_Amount = DTL.Transaction_Amount;

// LCL.Transaction Amount RB = DTL.Transaction Amount
LCL.Transaction_Amount_RB = DTL.Transaction_Amount;

// WRK.Adjustment Type Code = DTL.Adjustment Type Code
WRK.Adjustment_Type_Code = DTL.Adjustment_Type_Code;

// WRK.USR Invoice Number = DTL.USR Reference number
WRK.USR_Invoice_Number = DTL.USR_Reference_number;

//?OMS036 - RMC 5/9/05
//?OMS036 - If clearing a a Credit Memo or On Acct - reverse the amt
CASE;

// IF DTL.Invoice Suffix is CM or OA
IF DTL.Invoice_Suffix = 'CM'/'OA';

//?Reverse the amount so it will be taken out of the 360-1410 acct
//?and added to the Acct entered on this screen, could be the 360-3120 acct
//?RMC also do for REFund per Tim 8/31/05
//?RMC also do for STP stop paym per Tim 12/29/05
//?RMC also do for WO1 write off>100 per Tim 11/09/09   S00984
CASE;

// IF DTL.Adjustment Type Code is Inter Company
IF DTL.Adjustment_Type_Code = 'ITC';

// OR DTL.Adjustment Type Code is Write Off Under $100
OR DTL.Adjustment_Type_Code = 'WO';

// OR DTL.Adjustment Type Code is Write Off Under $50
OR DTL.Adjustment_Type_Code = ' WO';

// OR DTL.Adjustment Type Code is Refund
OR DTL.Adjustment_Type_Code = 'REF';

// OR DTL.Adjustment Type Code is Stop Payment
OR DTL.Adjustment_Type_Code = 'STP';

// OR DTL.Adjustment Type Code is Write off over $100
OR DTL.Adjustment_Type_Code = 'WO1';

// LCL.Transaction Amount = CON.*ZERO - LCL.Transaction Amount
LCL.Transaction_Amount = *ZERO - LCL.Transaction_Amount;

ENDIF;

ENDIF;

//?**************
//?RMC 12/23/05 get g/l posting company
// Call program VAL Acct ID JDE-8 dgt  UP.
CALL PROGRAM(VAL Acct ID JDE-8 dgt  UP) ('ARACTRET');
PARAMETER(DTL.G_L_ID_Code_JDE);
PARAMETER(NLL.Cost_Center);
PARAMETER(NLL.Object_Account);
PARAMETER(NLL.Subsidiary);
PARAMETER(NLL.Description);
PARAMETER(DTL.G_L_Posting_Company);
PARAMETER(NLL.JDE_Posting_Edit_Code_USR);
PARAMETER(NLL.Error_Return_text);

//?CALC: Detail screen function fields

EXECUTE FUNCTION(Customer Name DRV) TYPE(DRVFLD)                                AC1631131;
PARAMETER(DTL.Customer_Name_DRV);
PARAMETER(DTL.AR_Customer_Number);
{
 //?Calculate derived field

 EXECUTE FUNCTION(RTV Customer Name      RT) TYPE(RTVOBJ) FILE(CABBREP)          AC1108159;
 PARAMETER(PAR.Ship_To_Customer);
 PARAMETER(PAR.Customer_Name_DRV);
 {
  //?USER: Processing if Data record not found

  MOVE *ALL (To: PAR From: CON);

  // PGM.*Return code = CND.*Record does not exist
  PGM.*Return_code = 'Y2U0005';

  //?USER: Process Data record

  MOVE *ALL (To: PAR From: DB1);

 }

}


//?** Save sub-ledger code for the reverse entry       E00039
// PAR.G/L Sub-Ledger Code = DTL.G/L Vendor Number USR
PAR.G_L_Sub_Ledger_Code = DTL.G_L_Vendor_Number_USR;

//?USER: Create DBF record

EXECUTE FUNCTION(CRT A/R Detail CB+Offs IF) TYPE(EXCINTFUN) FILE(ARBECPP)       AC2127908;
PARAMETER(DTL.Company_Number);
PARAMETER(DTL.Invoice_Number);
PARAMETER(DTL.Invoice_Suffix);
PARAMETER(DTL.Sequence_Number);
PARAMETER(DTL.Adjustment_Type_Code);
PARAMETER(LCL.Transaction_Amount);
PARAMETER(DTL.A_R_Check_Number);
PARAMETER(DTL.Explanation);
PARAMETER(JOB.*Job_date);
PARAMETER(JOB.*Job_date);
PARAMETER(*ZERO);
PARAMETER(DTL.G_L_Post_Date);
PARAMETER(*BLANK);
PARAMETER(DTL.GL_Document_Number);
PARAMETER(DTL.Cash_Adj);
PARAMETER('E');
PARAMETER(JOB.*PROGRAM);
PARAMETER(DTL.Effect_on_Account);
PARAMETER(DTL.G_L_Posting_Company);
PARAMETER(DTL.G_L_ID_Code_JDE);
PARAMETER('Y');
PARAMETER(DTL.A_R_TF_Exempt_Code);
PARAMETER(DTL.A_R_Dtl_UnUsed_Sts_1_1);
PARAMETER(DTL.A_R_Dtl_UnUsed_Sts_2_1);
PARAMETER(DTL.A_R_Dtl_UnUsed_Sts_3_1);
PARAMETER(DTL.A_R_Dtl_UnUsed_Sts_4_2);
PARAMETER(DTL.A_R_Dtl_UnUsed_Sts_5_2);
PARAMETER(DTL.TFS_Adj_Week_Ending_Date);
PARAMETER(DTL.A_R_Orig_Inv_for_CB);
PARAMETER(DTL.A_R_Invoice_Number_CB);
PARAMETER(DTL.A_R_Dtl_UnUsed_Date_4);
PARAMETER(DTL.A_R_Dtl_UnUsed_Date_5);
PARAMETER(DTL.G_L_Vendor_Number_USR);
PARAMETER(DTL.A_R_Dtl_UnUsed_AMT_2);
PARAMETER(DTL.A_R_Dtl_UnUsed_AMT_3);
PARAMETER(DTL.A_R_Dtl_UnUsed_AMT_4);
PARAMETER(DTL.A_R_Dtl_UnUsed_AMT_5);
PARAMETER(DTL.EDI_Status_1);
PARAMETER(DTL.EDI_Status_2);
PARAMETER(DTL.EDI_Status_3);
PARAMETER(DTL.AR_Customer_Number);
PARAMETER(PAR.Access_Denied_Y_N);
{
 //?Execute internal function

 //?First create the Rebill Detail record for the Charge Back
 EXECUTE FUNCTION(CRT A/R Detail Appl    CR) TYPE(CRTOBJ) FILE(ARBECPP)          AC1338635;
 PARAMETER(PAR.Company_Number);
 PARAMETER(PAR.Invoice_Number);
 PARAMETER(PAR.Invoice_Suffix);
 PARAMETER(PAR.Sequence_Number);
 PARAMETER(PAR.Adjustment_Type_Code);
 PARAMETER(PAR.Transaction_Amount);
 PARAMETER(PAR.A_R_Check_Number);
 PARAMETER(PAR.Explanation);
 PARAMETER(PAR.Transaction_Date_Code);
 PARAMETER(PAR.Payment_Deposit_Date);
 PARAMETER(PAR.Deposit_Time);
 PARAMETER(PAR.G_L_Post_Date);
 PARAMETER(PAR.Bank_Code);
 PARAMETER(PAR.GL_Document_Number);
 PARAMETER(PAR.Cash_Adj);
 PARAMETER(PAR.A_R_Processing_Status);
 PARAMETER(PAR.Originating_Program_Name);
 PARAMETER(PAR.Effect_on_Account);
 PARAMETER(PAR.G_L_Posting_Company);
 PARAMETER(PAR.G_L_ID_Code_JDE);
 PARAMETER(PAR.Post_Adjustments);
 PARAMETER(PAR.A_R_TF_Exempt_Code);
 PARAMETER(PAR.A_R_Dtl_UnUsed_Sts_1_1);
 PARAMETER(PAR.A_R_Dtl_UnUsed_Sts_2_1);
 PARAMETER(PAR.A_R_Dtl_UnUsed_Sts_3_1);
 PARAMETER(PAR.A_R_Dtl_UnUsed_Sts_4_2);
 PARAMETER(PAR.A_R_Dtl_UnUsed_Sts_5_2);
 PARAMETER(PAR.TFS_Adj_Week_Ending_Date);
 PARAMETER(PAR.A_R_Orig_Inv_for_CB);
 PARAMETER(PAR.A_R_Invoice_Number_CB);
 PARAMETER(PAR.A_R_Dtl_UnUsed_Date_4);
 PARAMETER(PAR.A_R_Dtl_UnUsed_Date_5);
 PARAMETER(PAR.G_L_Sub_Ledger_Code);
 PARAMETER(PAR.A_R_Dtl_UnUsed_AMT_2);
 PARAMETER(PAR.A_R_Dtl_UnUsed_AMT_3);
 PARAMETER(PAR.A_R_Dtl_UnUsed_AMT_4);
 PARAMETER(PAR.A_R_Dtl_UnUsed_AMT_5);
 PARAMETER(PAR.EDI_Status_1);
 PARAMETER(PAR.EDI_Status_2);
 PARAMETER(PAR.EDI_Status_3);
 PARAMETER(PAR.AR_Customer_Number);
 PARAMETER(PAR.Access_Denied_Y_N);
 {
  //?USER: Processing before Data update

  EXECUTE FUNCTION(Set Date/Time Stamp   IF) TYPE(EXCINTFUN)                      AC1142219;
  PARAMETER(DB1.Job_Time);
  PARAMETER(DB1.User_Id);
  PARAMETER(DB1.Job_Name);
  PARAMETER(DB1.Job_Date);
  {
   //?Execute internal function

   // PAR.Job Time = JOB.*Job time
   PAR.Job_Time = JOB.*Job_time;

   // PAR.User Id = JOB.*USER
   PAR.User_Id = JOB.*USER;

   // PAR.Job Name = JOB.*JOB
   PAR.Job_Name = JOB.*JOB;

   // PAR.Job Date = JOB.*Job date
   PAR.Job_Date = JOB.*Job_date;

  }

  //?USER: Processing after Data update

  // PAR.Access Denied (Y/N) = CND.no
  PAR.Access_Denied_Y_N = 'N';

 }

 //?Next create the offset record as an ARC credit for the Charge Back
 // PAR.Sequence Number = PAR.Sequence Number + CON.1
 PAR.Sequence_Number = PAR.Sequence_Number + 1;

 // LCL.Transaction Amount = CON.*ZERO - PAR.Transaction Amount
 LCL.Transaction_Amount = *ZERO - PAR.Transaction_Amount;

 EXECUTE FUNCTION(CRT A/R Detail Appl    CR) TYPE(CRTOBJ) FILE(ARBECPP)          AC1338635;
 PARAMETER(PAR.Company_Number);
 PARAMETER(PAR.Invoice_Number);
 PARAMETER(PAR.Invoice_Suffix);
 PARAMETER(PAR.Sequence_Number);
 PARAMETER('ARC');
 PARAMETER(LCL.Transaction_Amount);
 PARAMETER(*BLANK);
 PARAMETER('Credit A/R');
 PARAMETER(PAR.Transaction_Date_Code);
 PARAMETER(PAR.Payment_Deposit_Date);
 PARAMETER(PAR.Deposit_Time);
 PARAMETER(PAR.G_L_Post_Date);
 PARAMETER(PAR.Bank_Code);
 PARAMETER(PAR.GL_Document_Number);
 PARAMETER(PAR.Cash_Adj);
 PARAMETER(PAR.A_R_Processing_Status);
 PARAMETER(PAR.Originating_Program_Name);
 PARAMETER(PAR.Effect_on_Account);
 PARAMETER(PAR.G_L_Posting_Company);
 PARAMETER(PAR.G_L_ID_Code_JDE);
 PARAMETER(PAR.Post_Adjustments);
 PARAMETER(PAR.A_R_TF_Exempt_Code);
 PARAMETER(PAR.A_R_Dtl_UnUsed_Sts_1_1);
 PARAMETER(PAR.A_R_Dtl_UnUsed_Sts_2_1);
 PARAMETER(PAR.A_R_Dtl_UnUsed_Sts_3_1);
 PARAMETER(PAR.A_R_Dtl_UnUsed_Sts_4_2);
 PARAMETER(PAR.A_R_Dtl_UnUsed_Sts_5_2);
 PARAMETER(PAR.TFS_Adj_Week_Ending_Date);
 PARAMETER(PAR.A_R_Orig_Inv_for_CB);
 PARAMETER(PAR.A_R_Invoice_Number_CB);
 PARAMETER(PAR.A_R_Dtl_UnUsed_Date_4);
 PARAMETER(PAR.A_R_Dtl_UnUsed_Date_5);
 PARAMETER(PAR.G_L_Sub_Ledger_Code);
 PARAMETER(PAR.A_R_Dtl_UnUsed_AMT_2);
 PARAMETER(PAR.A_R_Dtl_UnUsed_AMT_3);
 PARAMETER(PAR.A_R_Dtl_UnUsed_AMT_4);
 PARAMETER(PAR.A_R_Dtl_UnUsed_AMT_5);
 PARAMETER(PAR.EDI_Status_1);
 PARAMETER(PAR.EDI_Status_2);
 PARAMETER(PAR.EDI_Status_3);
 PARAMETER(PAR.AR_Customer_Number);
 PARAMETER(PAR.Access_Denied_Y_N);
 {
  //?USER: Processing before Data update

  EXECUTE FUNCTION(Set Date/Time Stamp   IF) TYPE(EXCINTFUN)                      AC1142219;
  PARAMETER(DB1.Job_Time);
  PARAMETER(DB1.User_Id);
  PARAMETER(DB1.Job_Name);
  PARAMETER(DB1.Job_Date);
  {
   //?Execute internal function

   // PAR.Job Time = JOB.*Job time
   PAR.Job_Time = JOB.*Job_time;

   // PAR.User Id = JOB.*USER
   PAR.User_Id = JOB.*USER;

   // PAR.Job Name = JOB.*JOB
   PAR.Job_Name = JOB.*JOB;

   // PAR.Job Date = JOB.*Job date
   PAR.Job_Date = JOB.*Job_date;

  }

  //?USER: Processing after Data update

  // PAR.Access Denied (Y/N) = CND.no
  PAR.Access_Denied_Y_N = 'N';

 }

}


//?USER: Process command keys

//?Save CB key values for update in Exit Processing
// LCL.Invoice Number - CB = DTL.Invoice Number
LCL.Invoice_Number_CB = DTL.Invoice_Number;

// LCL.Invoice Suffix 5 = DTL.Invoice Suffix
LCL.Invoice_Suffix_5 = DTL.Invoice_Suffix;

//?USER: Exit program processing

CASE;

// IF PAR.Error Status is yes
IF PAR.Error_Status = 'Y';

// PAR.Access Denied (Y/N) = CND.yes
PAR.Access_Denied_Y_N = 'Y';

ENDIF;

//?New 12/17/01
CASE;

// IF DTL.*CMD key is *Exit
IF DTL.*CMD_key = '03';

// PAR.Access Denied (Y/N) = CND.yes
PAR.Access_Denied_Y_N = 'Y';

ENDIF;

//?E5262 JJH 05/16/16 - Do Not Create A/R Detail for ARC.
//?Perform additional file updates  -- Create RB ar header
CASE;

// IF PAR.Access Denied (Y/N) is no
IF PAR.Access_Denied_Y_N = 'N';

//?Create the new RB A/R Header from the CB A/R Header
//?Create A/R Header for Rebill Transaction.
DO;

// LCL.Record Created        USR = CND.No
LCL.Record_Created_USR = 'N';

// DOW LCL.Record Created        USR is No
DOW LCL.Record_Created_USR = 'N';

//?*** Create a Rebill record in the A/R Header file. ***
DO;

//?*** Convert the invoice nbr into a Chargeback Reference nbr. ***
EXECUTE FUNCTION(RTV Next CB Number     RT) TYPE(RTVOBJ) FILE(CAASREP)          AC2082405;
PARAMETER(*ZERO);
PARAMETER(LCL.Next_Charge_Back_Number);
{
 //?USER: Processing if Data record not found

 MOVE *ALL (To: PAR From: CON);

 //?USER: Process Data record

 MOVE *ALL (To: PAR From: DB1);

}


// LCL.Next Charge Back Number = LCL.Next Charge Back Number + CON.1
LCL.Next_Charge_Back_Number = LCL.Next_Charge_Back_Number + 1;

EXECUTE FUNCTION(RTV Check invc exists  RT) TYPE(RTVOBJ) FILE(ARBDCPP)          AC1263564;
PARAMETER(LCL.Next_Charge_Back_Number);
{
 //?USER: Processing if Data record not found

 // PGM.*Return code = CND.*Record does not exist
 PGM.*Return_code = 'Y2U0005';

 //?USER: Process Data record

 // PGM.*Return code = CND.*Record already exists
 PGM.*Return_code = 'Y2U0003';

}


//?Repeat until unique Charge Back# found
// DOW PGM.*Return code is *Record already exists
DOW PGM.*Return_code = 'Y2U0003';

// LCL.Next Charge Back Number = LCL.Next Charge Back Number + CON.1
LCL.Next_Charge_Back_Number = LCL.Next_Charge_Back_Number + 1;

EXECUTE FUNCTION(RTV Check invc exists  RT) TYPE(RTVOBJ) FILE(ARBDCPP)          AC1263564;
PARAMETER(LCL.Next_Charge_Back_Number);
{
 //?USER: Processing if Data record not found

 // PGM.*Return code = CND.*Record does not exist
 PGM.*Return_code = 'Y2U0005';

 //?USER: Process Data record

 // PGM.*Return code = CND.*Record already exists
 PGM.*Return_code = 'Y2U0003';

}


ENDDO;

EXECUTE FUNCTION(RTV Next Charge Back# CH) TYPE(CHGOBJ) FILE(CAASREP)           AC2082404;
PARAMETER(*ZERO);
PARAMETER(LCL.Next_Charge_Back_Number);
{
 //?USER: Processing before Data update

 EXECUTE FUNCTION(Set Date/Time Stamp   IF) TYPE(EXCINTFUN)                      AC1142219;
 {
  //?Execute internal function

  // PAR.Job Time = JOB.*Job time
  PAR.Job_Time = JOB.*Job_time;

  // PAR.User Id = JOB.*USER
  PAR.User_Id = JOB.*USER;

  // PAR.Job Name = JOB.*JOB
  PAR.Job_Name = JOB.*JOB;

  // PAR.Job Date = JOB.*Job date
  PAR.Job_Date = JOB.*Job_date;

 }

}


// LCL.Invoice Number        USR = LCL.Next Charge Back Number
LCL.Invoice_Number_USR = LCL.Next_Charge_Back_Number;

// LCL.Original Inv for CB = LCL.Invoice Number
LCL.Original_Inv_for_CB = LCL.Invoice_Number;

//?*** Create a Rebill record in the A/R Header file. ***
EXECUTE FUNCTION(RTV A/R Hdr by Co,Inv# RT) TYPE(RTVOBJ) FILE(ARBDCPP)          AC1953578;
PARAMETER(PAR.Company_Number);
PARAMETER(PAR.Invoice_Number);
PARAMETER(PAR.Invoice_Suffix);
PARAMETER(LCL.Adjustment_Type_Code);
PARAMETER(LCL.Transaction_Amount);
PARAMETER(LCL.Adjustment_Amount);
PARAMETER(LCL.Amount_Paid);
PARAMETER(LCL.Remaining_Balance_Due);
PARAMETER(LCL.A_R_Processing_Status);
PARAMETER(LCL.Purge_Status);
PARAMETER(LCL.Bank_Code);
PARAMETER(LCL.GL_Document_Number);
PARAMETER(LCL.Order_Number_Ref);
PARAMETER(LCL.Ship_To_Customer);
PARAMETER(LCL.Salesperson_Code);
PARAMETER(LCL.Sales_Route_Code);
PARAMETER(LCL.Transaction_Date_Code);
PARAMETER(LCL.Due_Date);
PARAMETER(LCL.Last_Payment_Date);
PARAMETER(LCL.Original_Inv_for_CB);
PARAMETER(LCL.Paid_in_Full_Date);
PARAMETER(LCL.Last_G_L_Post_Date);
PARAMETER(LCL.AR_Customer_Number);
PARAMETER(LCL.A_R_Check_Number);
PARAMETER(LCL.Days_to_Pay);
PARAMETER(LCL.EDI_Status_1);
PARAMETER(LCL.EDI_Status_2);
PARAMETER(LCL.EDI_Status_3);
{
 //?USER: Processing if Data record not found

 MOVE *ALL (To: PAR From: CON);

 //?USER: Process Data record

 MOVE *ALL (To: PAR From: DB1);

}


EXECUTE FUNCTION(CRT A/R Detail (Lckbx) CR) TYPE(CRTOBJ) FILE(ARBDCPP)          AC1515456;
PARAMETER(PAR.Company_Number);
PARAMETER(LCL.Invoice_Number_USR);
PARAMETER('RB');
PARAMETER('RB');
PARAMETER(LCL.Transaction_Amount_RB);
PARAMETER(*ZERO);
PARAMETER(*ZERO);
PARAMETER(LCL.Transaction_Amount_RB);
PARAMETER(LCL.A_R_Processing_Status);
PARAMETER(LCL.Purge_Status);
PARAMETER(*BLANK);
PARAMETER(LCL.GL_Document_Number);
PARAMETER(LCL.Order_Number_Ref);
PARAMETER(LCL.Ship_To_Customer);
PARAMETER(LCL.Salesperson_Code);
PARAMETER(LCL.Sales_Route_Code);
PARAMETER(JOB.*Job_date);
PARAMETER(JOB.*Job_date);
PARAMETER(LCL.Last_Payment_Date);
PARAMETER(LCL.Original_Inv_for_CB);
PARAMETER(*ZERO);
PARAMETER(LCL.Last_G_L_Post_Date);
PARAMETER(LCL.AR_Customer_Number);
PARAMETER(*BLANK);
PARAMETER(LCL.Days_to_Pay);
PARAMETER(LCL.EDI_Status_1);
PARAMETER(LCL.EDI_Status_2);
PARAMETER(LCL.EDI_Status_3);
PARAMETER(JOB.*Job_time);
PARAMETER(JOB.*USER);
PARAMETER(JOB.*PROGRAM);
PARAMETER(JOB.*Job_date);
PARAMETER(LCL.Record_Created_USR);
{
 //?USER: Processing before Data update

 // PAR.Record Created        USR = CND.No
 PAR.Record_Created_USR = 'N';

 //?USER: Processing after Data update

 // PAR.Record Created        USR = CND.Yes
 PAR.Record_Created_USR = 'Y';

 //?E6933 DN  08/12/16 - Create A/R Header Ext record.
 // Call program Crt A/R Header Ext    XF.
 CALL PROGRAM(Crt A/R Header Ext    XF) ('PBX3XFR');
 PARAMETER(DB1.Company_Number);
 PARAMETER(DB1.Invoice_Number);
 PARAMETER(DB1.Invoice_Suffix);
 PARAMETER(DB1.Remaining_Balance_Due);
 PARAMETER(DB1.Order_Number_Ref);
 PARAMETER(DB1.Original_Inv_for_CB);

}


EXECUTE FUNCTION(UPD Rebill/Invc Ref#  RT) TYPE(RTVOBJ) FILE(ARBECPP)           AC2127919;
PARAMETER(PAR.Company_Number);
PARAMETER(LCL.Invoice_Number_CB);
PARAMETER(LCL.Invoice_Suffix_5);
PARAMETER(LCL.Original_Inv_for_CB);
PARAMETER(LCL.Invoice_Number_USR);
{
 //?USER: Process Data record

 EXECUTE FUNCTION(CHG Rebill Reference #) TYPE(CHGOBJ) FILE(ARBECPP)             AC2127606;
 PARAMETER(DB1.Company_Number);
 PARAMETER(DB1.Invoice_Number);
 PARAMETER(DB1.Invoice_Suffix);
 PARAMETER(DB1.Sequence_Number);
 PARAMETER(PAR.A_R_Orig_Inv_for_CB);
 PARAMETER(PAR.A_R_Invoice_Number_CB);
 {
  //?USER: Processing before Data update

  EXECUTE FUNCTION(Set Date/Time Stamp   IF) TYPE(EXCINTFUN)                      AC1255766;
  PARAMETER(DB1.Job_Time);
  PARAMETER(DB1.User_Id);
  PARAMETER(DB1.Job_Name);
  PARAMETER(DB1.Job_Date);
  {
   //?Execute internal function

   // PAR.Job Time = JOB.*Job time
   PAR.Job_Time = JOB.*Job_time;

   // PAR.User Id = JOB.*USER
   PAR.User_Id = JOB.*USER;

   // PAR.Job Name = JOB.*JOB
   PAR.Job_Name = JOB.*JOB;

   // PAR.Job Date = JOB.*Job date
   PAR.Job_Date = JOB.*Job_date;

  }

 }

}


ENDDO;

ENDDO;

ENDDO;

//?Update the existing A/R Header to close out the CB
EXECUTE FUNCTION(RTV CHG Apply RB       RT) TYPE(RTVOBJ) FILE(ARBDCPP)          AC2122923;
PARAMETER(PAR.Company_Number);
PARAMETER(PAR.Invoice_Number);
PARAMETER(PAR.Invoice_Suffix);
PARAMETER(LCL.Transaction_Amount_RB);
PARAMETER(PAR.AR_Customer_Number);
{
 //?USER: Process Data record

 //?Calculate remaining balance
 // PAR.USR Amount Applied = PAR.Amount Paid + DB1.Amount Paid
 PAR.USR_Amount_Applied = PAR.Amount_Paid + DB1.Amount_Paid;

 // PAR.USR Cash Appl Amount = PAR.USR Amount Applied + DB1.Adjustment Amount
 PAR.USR_Cash_Appl_Amount = PAR.USR_Amount_Applied + DB1.Adjustment_Amount;

 // PAR.USR Remaining Balance = DB1.Transaction Amount - PAR.USR Cash Appl Amount
 PAR.USR_Remaining_Balance = DB1.Transaction_Amount - PAR.USR_Cash_Appl_Amount;

 //?Calculate adjustment amount
 // PAR.Adjustment Amount = DB1.Adjustment Amount + PAR.Amount Paid
 PAR.Adjustment_Amount = DB1.Adjustment_Amount + PAR.Amount_Paid;

 //?Days to Pay calculation removed 6/13/96 per ARS026
 //?      Documentation for project detail is on AR26DSN.DOC
 //?    I put it back in when I worked on call 1723 because it needs to be in.
 //?Paid in full date
 CASE;

 // IF PAR.USR Remaining Balance is Zero
 IF PAR.USR_Remaining_Balance = *ZERO;

 // WRK.Paid in Full Date = JOB.*Job date
 WRK.Paid_in_Full_Date = JOB.*Job_date;

 EXECUTE FUNCTION(CLC Days Paid          IF) TYPE(EXCINTFUN)                     AC1351456;
 PARAMETER(DB1.Company_Number);
 PARAMETER(DB1.Transaction_Date_Code);
 PARAMETER(DB1.Last_Payment_Date);
 PARAMETER(PAR.Days_to_Pay);
 {
  //?Execute internal function

  //?  Transaction Date (Invoice Date) will be used instead of Due Date.
  //?     PER Request ARS038
  //?  The Paid in Full Date has been Changed to the Deposit Date
  //?     Which is the Last Payment Date
  // PAR.Number of Days = PAR.Last Payment Date - PAR.Transaction Date Code *DAYS
  PAR.Number_of_Days = DURATION(PAR.Last_Payment_Date PAR.Transaction_Date_Code 'DY'
  1111111 'NONE' 'N' 1);

  //?Handle Negative Days to Pay
  CASE;

  // IF PAR.Number of Days is Less Than Zero
  IF PAR.Number_of_Days < *ZERO;

  // PAR.Days to Pay = CND.equal to zero
  PAR.Days_to_Pay = *ZERO;

  //?Handle Negative Days to Pay
  // IF *OTHERWISE
  IF *OTHERWISE;

  // PAR.Days to Pay = PAR.Number of Days
  PAR.Days_to_Pay = PAR.Number_of_Days;

  ENDIF;

 }

 //?Days to Pay is Negative
 CASE;

 // IF PAR.Days to Pay is less than zero
 IF PAR.Days_to_Pay < *ZERO;

 // PAR.Days to Pay = CND.equal to zero
 PAR.Days_to_Pay = *ZERO;

 ENDIF;

 //?Paid in full date
 // IF *OTHERWISE
 IF *OTHERWISE;

 // PAR.Days to Pay = CND.equal to zero
 PAR.Days_to_Pay = *ZERO;

 // WRK.Paid in Full Date = CND.not entered
 WRK.Paid_in_Full_Date = *ZERO;

 ENDIF;

 EXECUTE FUNCTION(CHG for Apply RB CreditCH) TYPE(CHGOBJ) FILE(ARBDCPP)          AC2122452;
 PARAMETER(DB1.Company_Number);
 PARAMETER(DB1.Invoice_Number);
 PARAMETER(DB1.Invoice_Suffix);
 PARAMETER(PAR.Adjustment_Amount);
 PARAMETER(PAR.USR_Remaining_Balance);
 PARAMETER(DB1.Last_Payment_Date);
 PARAMETER(WRK.Paid_in_Full_Date);
 PARAMETER(PAR.Days_to_Pay);
 {
  //?USER: Processing before Data update

  EXECUTE FUNCTION(Set Date/Time Stamp   IF) TYPE(EXCINTFUN)                      AC1255766;
  PARAMETER(DB1.Job_Time);
  PARAMETER(DB1.User_Id);
  PARAMETER(DB1.Job_Name);
  PARAMETER(DB1.Job_Date);
  {
   //?Execute internal function

   // PAR.Job Time = JOB.*Job time
   PAR.Job_Time = JOB.*Job_time;

   // PAR.User Id = JOB.*USER
   PAR.User_Id = JOB.*USER;

   // PAR.Job Name = JOB.*JOB
   PAR.Job_Name = JOB.*JOB;

   // PAR.Job Date = JOB.*Job date
   PAR.Job_Date = JOB.*Job_date;

  }

 }

}


//?Output Invoice Number created for Rebill
// PAR.Invoice Number RB = LCL.Invoice Number        USR
PAR.Invoice_Number_RB = LCL.Invoice_Number_USR;

// PAR.Remaining Balance Due = PAR.Transaction Amount - LCL.Transaction Amount RB
PAR.Remaining_Balance_Due = PAR.Transaction_Amount - LCL.Transaction_Amount_RB;

ENDIF;

