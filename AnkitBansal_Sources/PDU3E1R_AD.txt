// ?------------------------------------------------------------------------------------------------
// ?Synon action diagram for PDU3E1R
// ?Date: 14.08.2025 Time: 03:30:07
// ?------------------------------------------------------------------------------------------------

//?USER: Initialize program

//?***** Change log and comments
DO;

//?CSTAR01 AB 05/31/2024 - Removing QRY Access Path PDNEREL6 Dependency
//?- Replaced 'Val Vndr# for Customr RT' function from 'Customer Ext'
//?- file to the function 'Val Vndr# for Customr RT' from 'Customer Master'
//?E5262 JBB 07/06/16 - Charge Back and Rebills project
//?- Add Adjustment Type RB to list of invalid Adjustment Types
//?E6458 JBB 07/13/16 - Fix Duplicate Charge Back Explanations
//?- When creating the A/R Detail record for the Charge Back, write
//?  the Charge Back Reference Number to the Unused Date 3 field.
//?E5262 JJH 05/24/16 - Rebill
//?- Modified the RTV CHG Apply CM or OA RT - A/R Header function for
//?  new logic dealing with Rebills.   Decision was made to leave this
//?  function as is so the function was changed back to original code.
//?  This program is just recompiled to put back as it was originally.
//?** 06/07/2010 LJB C000789   Change Chargeback Ref# to output only.
//?** Create it by appending A/R Detail seq# to end of invoice#.
//?** Create the Chargeback Header record with this new invoice#.
//?** If sequence# exists in A/R Detail, increment until it is uniqye
//?** and update the PAR. & DTL. context with final result.
//?** This way the A/R Detail should stay in sync with the Header CBs.
//?***
//?** 03/04/2010 LJB E000512  Post install changes
//?** Rename G/L Vendor to G/L Sub-Ledger. Add validation of sub-
//?** ledger if post edit code in JDE = "L"
//?***
//?** 02/18/2010 LJB E000512  New parm added to VAL JDE Account
//?** No.s UP, retrieve and recompile
//?***
//?RMC S00977 11/09/09 Add adj type "WO1' to comp with "WO " et al.
//?RMC S00877 7/22/09 Chg RTV Check invc exists  RT to chk invoice sans compa
//?RMC 12/23/05 get g/l posting company
ENDDO;

EXECUTE FUNCTION(VAL Set Inter. Access  IF) TYPE(EXCINTFUN)                     AC1144606;
PARAMETER('A/R');
PARAMETER(WRK.Company_Number);
PARAMETER(PAR.Warehouse_Code);
PARAMETER(PAR.Allow_Multi_Company);
PARAMETER(PAR.Default_Printer);
PARAMETER(PAR.Salesperson_Code);
{
 //?Execute internal function

 // PAR.User Profile Name = JOB.*USER
 PAR.User_Profile_Name = JOB.*USER;

 EXECUTE FUNCTION(VAL User/Application   IF) TYPE(EXCINTFUN)                     AC1144188;
 PARAMETER(PAR.User_Profile_Name);
 PARAMETER(PAR.Application_Code);
 PARAMETER(PAR.Company_Number);
 PARAMETER(PAR.Warehouse_Code);
 PARAMETER(PAR.Allow_Multi_Company);
 PARAMETER(PAR.Default_Printer);
 PARAMETER(PAR.Salesperson_Code);
 {
  //?Execute internal function

  //?RMC 5/11/09 Rtv default company from user profile --
  //?  Override user code model company if it exists
  EXECUTE FUNCTION(RTV Program Setup w/Co RT) TYPE(RTVOBJ) FILE(CADRREP)          AC1935572;
  PARAMETER(PAR.User_Profile_Name);
  PARAMETER(PAR.Allow_Multi_Company);
  PARAMETER(PAR.Default_Printer);
  PARAMETER(PAR.Salesperson_Code);
  PARAMETER(LCL.Company_Number);
  PARAMETER(PAR.User_Code_Model);
  {
   //?USER: Processing if Data record not found

   // PGM.*Return code = CND.*Record does not exist
   PGM.*Return_code = 'Y2U0005';

   //?USER: Process Data record

   MOVE *ALL (To: PAR From: DB1);

  }

  //?User Profile Record Not found
  CASE;

  // IF PGM.*Return code is *Record does not exist
  IF PGM.*Return_code = 'Y2U0005';

  // Execute function SET Message Queue Dest US.
  EXECUTE FUNCTION(SET Message Queue Dest US) TYPE(EXCUSRSRC) ('USNCUFR');
  {
   C                     MOVEL'*PRV '   ZAPGRL           PREVIOUS
  }

  // Send completion message - 'Application access denied for user &1 in application area &2'
  MESSAGE(USR0810 *COMPLETION);
  MSGPARM(PAR.User_Profile_Name);
  MSGPARM(PAR.Application_Code);

  PGM.*Return_code = 'Y2U9999';

  RETURN;

  ENDIF;

  CASE;

  // IF PAR.User Code Model is equal to blank
  IF PAR.User_Code_Model = *BLANK;

  EXECUTE FUNCTION(RTV Appl. Profile      RT) TYPE(RTVOBJ) FILE(CADTREP)          AC1143177;
  PARAMETER(PAR.User_Profile_Name);
  PARAMETER(PAR.Application_Code);
  PARAMETER(PAR.Company_Number);
  PARAMETER(LCL.Warehouse_Code);
  {
   //?USER: Process Data record

   MOVE *ALL (To: PAR From: DB1);

  }

  // IF *OTHERWISE
  IF *OTHERWISE;

  EXECUTE FUNCTION(RTV Appl. Profile      RT) TYPE(RTVOBJ) FILE(CADTREP)          AC1143177;
  PARAMETER(PAR.User_Code_Model);
  PARAMETER(PAR.Application_Code);
  PARAMETER(PAR.Company_Number);
  PARAMETER(LCL.Warehouse_Code);
  {
   //?USER: Process Data record

   MOVE *ALL (To: PAR From: DB1);

  }

  ENDIF;

  // PAR.Warehouse Code = LCL.Warehouse Code
  PAR.Warehouse_Code = LCL.Warehouse_Code;

  //?Return code when not normal for Application Profile
  CASE;

  // IF PGM.*Return code is *Normal
  IF PGM.*Return_code = *BLANK;

  //?Return code when not normal for Application Profile
  // IF *OTHERWISE
  IF *OTHERWISE;

  // Execute function SET Message Queue Dest US.
  EXECUTE FUNCTION(SET Message Queue Dest US) TYPE(EXCUSRSRC) ('USNCUFR');
  {
   C                     MOVEL'*PRV '   ZAPGRL           PREVIOUS
  }

  // Send completion message - 'Application access denied for user &1 in application area &2'
  MESSAGE(USR0810 *COMPLETION);
  MSGPARM(PAR.User_Profile_Name);
  MSGPARM(PAR.Application_Code);

  PGM.*Return_code = 'Y2U9999';

  RETURN;

  ENDIF;

  //?Override company with User profile control's company if found
  CASE;

  // IF LCL.Company Number is not equal to zero
  IF LCL.Company_Number <> *ZERO;

  // PAR.Company Number = LCL.Company Number
  PAR.Company_Number = LCL.Company_Number;

  //?Get prod warehouse, if the appl got a warehouse
  CASE;

  // IF LCL.Warehouse Code is Not Blanks
  IF LCL.Warehouse_Code <> *BLANK;

  // Call program RTV Prod Whse for Co  XF.
  CALL PROGRAM(RTV Prod Whse for Co  XF) ('PNKDXFR');
  PARAMETER(PAR.Warehouse_Code);
  PARAMETER(LCL.Company_Number);

  ENDIF;

  ENDIF;

 }

 EXECUTE FUNCTION(SET Screen Headings    IF) TYPE(EXCINTFUN)                     AC1248058;
 PARAMETER(PAR.Application_Code);
 {
  //?Execute internal function

  EXECUTE FUNCTION(RTV Applic. Group Desc RT) TYPE(RTVOBJ) FILE(CADNREP)          AC1274118;
  PARAMETER(PAR.Application_Code);
  PARAMETER(WRK.Description);
  {
   //?USER: Process Data record

   CASE;

   // IF DB1.Application Group is Blank
   IF DB1.Application_Group = *BLANK;

   MOVE *ALL (To: PAR From: DB1);

   // IF *OTHERWISE
   IF *OTHERWISE;

   EXECUTE FUNCTION(RTV Application Desc   RT) TYPE(RTVOBJ) FILE(CADNREP)          AC1249881;
   PARAMETER(DB1.Application_Group);
   PARAMETER(PAR.Description);
   {
    //?USER: Processing if Data record not found

    MOVE *ALL (To: PAR From: CON);

    // PGM.*Return code = CND.*Record does not exist
    PGM.*Return_code = 'Y2U0005';

    //?USER: Process Data record

    MOVE *ALL (To: PAR From: DB1);

   }

   ENDIF;

  }

  // WRK.USR Description 40 = WRK.Description
  WRK.USR_Description_40 = WRK.Description;

  // Execute function CLC Center Txt Str 40  US.
  EXECUTE FUNCTION(CLC Center Txt Str 40  US) TYPE(EXCUSRSRC) ('PDYJUFR');
  PARAMETER(WRK.USR_Description_40);
  PARAMETER(WRK.USR_Description_40_2);
  {
   E                    UCT        40  1               CENTER TABLE
   C                     MOVEA#IDSC4    UCT              LOAD ARRAY
   C                     Z-ADD40        UX      20       SET COUNTER
   C           UX        DOWGT0
   C           UCT,UX    IFEQ ' '
   C                     SUB  1         UX
   C                     ELSE
   C                     Z-ADDUX        UXH     20
   C                     Z-ADD0         UX
   C                     END
   C                     END
   C           40        SUB  UXH       UX
   C           UX        DIV  2         UX
   C           UX        IFGT 0
   C                     MOVE *BLANKS   UCT
   C                     MOVEA#IDSC4    UCT,UX
   C                     END
   C                     MOVEAUCT       #ODE40           LOAD OUTPUT
  }

  // Execute function MOV Appl Desc-Co Head  US.
  EXECUTE FUNCTION(MOV Appl Desc-Co Head  US) TYPE(EXCUSRSRC) ('PDYKUFR');
  PARAMETER(WRK.USR_Description_40_2);
  {
   C                     MOVE #IDE40    ##CMP
  }

 }

}


//?USER: Initialize key screen

EXECUTE FUNCTION(RTV Next Seq. No.      RT) TYPE(RTVOBJ) FILE(ARBECPP)          AC1336580;
PARAMETER(KEY.Company_Number);
PARAMETER(KEY.Invoice_Number);
PARAMETER(KEY.Invoice_Suffix);
PARAMETER(KEY.Sequence_Number);
{
 //?USER: Processing if Data record not found

 // PAR.Sequence Number = CON.1
 PAR.Sequence_Number = 1;

 //?USER: Process Data record

 // PAR.Sequence Number = DB1.Sequence Number
 PAR.Sequence_Number = DB1.Sequence_Number;

 //?USER: Exit processing

 // PAR.Sequence Number = PAR.Sequence Number + CON.1
 PAR.Sequence_Number = PAR.Sequence_Number + 1;

}


// KEY.Company Number = PAR.Company Number
KEY.Company_Number = PAR.Company_Number;

// KEY.Invoice Number = PAR.Invoice Number
KEY.Invoice_Number = PAR.Invoice_Number;

// KEY.Invoice Suffix = PAR.Invoice Suffix
KEY.Invoice_Suffix = PAR.Invoice_Suffix;

// PAR.Access Denied (Y/N) = CND.yes
PAR.Access_Denied_Y_N = 'Y';

//?USER: Initialize detail screen (new record)

// KEY.Accounting Company Number = PAR.Accounting Company Number
KEY.Company_Number = PAR.Company_Number;

EXECUTE FUNCTION(RTV Company Name       RT) TYPE(RTVOBJ) FILE(CAABREP)          AC1255767;
PARAMETER(KEY.Company_Number);
PARAMETER(DTL.Company_Name);
{
 //?USER: Processing if Data record not found

 MOVE *ALL (To: PAR From: CON);

 //?USER: Process Data record

 MOVE *ALL (To: PAR From: DB1);

}


// DTL.Transaction Amount = PAR.Transaction Amount
DTL.Transaction_Amount = PAR.Transaction_Amount;

//?** Put the A/R customer # and name on the screen
// DTL.A/R Customer Number = PAR.A/R Customer Number
DTL.AR_Customer_Number = PAR.AR_Customer_Number;

EXECUTE FUNCTION(Customer Name DRV) TYPE(DRVFLD)                                AC1631131;
PARAMETER(DTL.Customer_Name_DRV);
PARAMETER(DTL.AR_Customer_Number);
{
 //?Calculate derived field

 EXECUTE FUNCTION(RTV Customer Name      RT) TYPE(RTVOBJ) FILE(CABBREP)          AC1108159;
 PARAMETER(PAR.Ship_To_Customer);
 PARAMETER(PAR.Customer_Name_DRV);
 {
  //?USER: Processing if Data record not found

  MOVE *ALL (To: PAR From: CON);

  // PGM.*Return code = CND.*Record does not exist
  PGM.*Return_code = 'Y2U0005';

  //?USER: Process Data record

  MOVE *ALL (To: PAR From: DB1);

 }

}


//?4/26/2008 slm tfs040 CHANGES
//?              Get the exempt flag from the 1st sales history
CASE;

// IF DTL.Invoice Suffix is Credit Memos
IF DTL.Invoice_Suffix = 'CM';

// Call program Rtv TF Exempt By Inv  XF.
CALL PROGRAM(Rtv TF Exempt By Inv  XF) ('PMUJXFR');
PARAMETER(PAR.Invoice_Number);
PARAMETER(DTL.A_R_TF_Exempt_Code);

// IF *OTHERWISE
IF *OTHERWISE;

//?6/02/2008 RMC tfs040 CB and OA wont be in Sales history, so get from Cust
EXECUTE FUNCTION(Rtv Customer ExemptFN/NE) TYPE(RTVOBJ) FILE(PDNEREP)           AC1876697;
PARAMETER(PAR.AR_Customer_Number);
PARAMETER(DTL.A_R_TF_Exempt_Code);
{
 //?USER: Initialize routine

 // PAR.Customer TF Exempt Code = CND.Not Exempt
 PAR.Customer_TF_Exempt_Code = 'NE';

 //?USER: Processing if Data record not found

 // PAR.Customer TF Exempt Code = CND.Not Exempt
 PAR.Customer_TF_Exempt_Code = 'NE';

 //?USER: Process Data record

 CASE;

 // IF DB1.Customer TF Exempt Code is *ALL values
 IF DB1.Customer_TF_Exempt_Code = 'NE'/'PC'/'EC'/'EP';

 // PAR.Customer TF Exempt Code = DB1.Customer TF Exempt Code
 PAR.Customer_TF_Exempt_Code = DB1.Customer_TF_Exempt_Code;

 // IF *OTHERWISE
 IF *OTHERWISE;

 // PAR.Customer TF Exempt Code = CND.Not Exempt
 PAR.Customer_TF_Exempt_Code = 'NE';

 ENDIF;

}


ENDIF;

// LCL.A/R TF Exempt Code = DTL.A/R TF Exempt Code
LCL.A_R_TF_Exempt_Code = DTL.A_R_TF_Exempt_Code;

//?USER: Validate detail screen fields

// PAR.Error Status = CND.no
PAR.Error_Status = 'N';

//?** Validate Sub Ledger Required                       E000512
// LCL.JDE Posting Edit Code USR = CND.Ledger Required
LCL.JDE_Posting_Edit_Code_USR = 'L';

//?F13=Chart of Accounts
CASE;

// IF DTL.*CMD key is CF13
IF DTL.*CMD_key = '13';

// PAR.Company Number Alpha = CVTVAR(DTL.Company Number)
PAR.Company_Number_Alpha = CVTVAR(DTL.Company_Number);

// Call program SEL Chart of Accounts  UP.
CALL PROGRAM(SEL Chart of Accounts  UP) ('ARACTSEL');
PARAMETER(PAR.Company_Number_Alpha);
PARAMETER(DTL.Cost_Center);
PARAMETER(DTL.Object_Account);
PARAMETER(DTL.Subsidiary);
PARAMETER(DTL.G_L_ID_Code_JDE);
PARAMETER(DTL.Description);
PARAMETER(WRK.Error_Return_text);

// PGM.*Reload subfile = CND.*YES
PGM.*Reload_subfile = 'Y';

ENDIF;

//?F4 = Prompt for G/L Vendor#
CASE;

// IF DTL.*CMD key is *Prompt
IF DTL.*CMD_key = '04';

CASE;

// IF PGM.*Cursor field <IS> DTL.G/L Vendor Number USR
IF PGM.*Cursor_field = DTL.G_L_Vendor_Number_USR;

// Call program SEL A/R Cust W/Vendor# SR.
CALL PROGRAM(SEL A/R Cust W/Vendor# SR) ('PMFRSRR');
PARAMETER(DTL.AR_Customer_Number);
PARAMETER(DTL.G_L_Vendor_Number_USR);

// PGM.*Reload subfile = CND.*YES
PGM.*Reload_subfile = 'Y';

ENDIF;

ENDIF;

//?** Validate G/L Vendor number if entered     E00039
CASE;

// IF DTL.G/L Vendor Number USR is Entered
IF DTL.G_L_Vendor_Number_USR <> *ZERO;

//?CSTAR01 Change St:Replace 'Customer Ext' logical with 'Customer Master's
EXECUTE FUNCTION(Val Vndr# for Customr RT) TYPE(RTVOBJ) FILE(CABBREP)           AC2228000;
PARAMETER(DTL.AR_Customer_Number);
PARAMETER(*ZERO);
PARAMETER(DTL.G_L_Vendor_Number_USR);
{
 //?USER: Initialize routine

 // PGM.*Return code = CND.*Record does not exist
 PGM.*Return_code = 'Y2U0005';

 //?USER: Processing if Data record not found

 // PGM.*Return code = CND.*Record does not exist
 PGM.*Return_code = 'Y2U0005';

 //?USER: Process Data record

 // LCL.Customer G_L Vendor Num = CND.Not Entered
 LCL.Customer_G_L_Vendor_Num = *ZERO;

 EXECUTE FUNCTION(Rtv Broker/ GL Vendor RT) TYPE(RTVOBJ) FILE(PDNEREP)           AC1684471;
 PARAMETER(DB1.Ship_To_Customer);
 PARAMETER(LCL.Customer_G_L_Vendor_Num);
 {
  //?USER: Processing if Data record not found

  MOVE *ALL (To: PAR From: CON);

  //?USER: Process Data record

  MOVE *ALL (To: PAR From: DB1);

 }

 // PGM.*Return code = CND.*Record does not exist
 PGM.*Return_code = 'Y2U0005';

 CASE;

 // IF LCL.Customer G_L Vendor Num EQ PAR.Customer G_L Vendor Num
 IF LCL.Customer_G_L_Vendor_Num = PAR.Customer_G_L_Vendor_Num;

 // PGM.*Return code = CND.*Record already exists
 PGM.*Return_code = 'Y2U0003';

 QUIT;

 ENDIF;

}


//?CSTAR01 Changes End
CASE;

// IF PGM.*Return code is *Record does not exist
IF PGM.*Return_code = 'Y2U0005';

// Send error message - 'G/L Sub-Ledger code (G/L Vendor #) is invalid'
ERROR(USR4118);
MSGPARM(DTL.G_L_Vendor_Number_USR);

// PAR.Error Status = CND.yes
PAR.Error_Status = 'Y';

// IF *OTHERWISE
IF *OTHERWISE;

// DTL.G/L Sub-Ledger Code = DTL.G/L Vendor Number USR
DTL.G_L_Sub_Ledger_Code = DTL.G_L_Vendor_Number_USR;

// PAR.G/L Sub-Ledger Code = DTL.G/L Vendor Number USR
PAR.G_L_Sub_Ledger_Code = DTL.G_L_Vendor_Number_USR;

ENDIF;

ENDIF;

// PAR.Access Denied (Y/N) = CND.no
PAR.Access_Denied_Y_N = 'N';

EXECUTE FUNCTION(RTV Adj Limits         RT) TYPE(RTVOBJ) FILE(PDJ3CPP)          AC1334715;
PARAMETER(DTL.Company_Number);
PARAMETER(DTL.Adjustment_Type_Code);
PARAMETER(DTL.Adjustment_Description);
PARAMETER(DTL.Effect_on_Account);
PARAMETER(DTL.G_L_ID_Code_JDE);
PARAMETER(PAR.Adjustment_Limit_Amount);
PARAMETER(DTL.Cash_Adj);
PARAMETER(PAR.User_Enter_G_L_Status);
{
 //?USER: Processing if Data record not found

 // PGM.*Return code = CND.*Record does not exist
 PGM.*Return_code = 'Y2U0005';

 //?USER: Process Data record

 MOVE *ALL (To: PAR From: DB1);

}


EXECUTE FUNCTION(RTV Company Name       RT) TYPE(RTVOBJ) FILE(CAABREP)          AC1255767;
PARAMETER(DTL.Company_Number);
PARAMETER(DTL.Company_Name);
{
 //?USER: Processing if Data record not found

 MOVE *ALL (To: PAR From: CON);

 //?USER: Process Data record

 MOVE *ALL (To: PAR From: DB1);

}


EXECUTE FUNCTION(RTV Check Active Adj   RT) TYPE(RTVOBJ) FILE(PDJ3CPP)          AC1399560;
PARAMETER(DTL.Company_Number);
PARAMETER(DTL.Adjustment_Type_Code);
PARAMETER(WRK.System_Control);
PARAMETER(WRK.Record_Status);
{
 //?USER: Processing if Data record not found

 // PGM.*Return code = CND.*Record does not exist
 PGM.*Return_code = 'Y2U0005';

 //?USER: Process Data record

 // PGM.*Return code = CND.*Record already exists
 PGM.*Return_code = 'Y2U0003';

 MOVE *ALL (To: PAR From: DB1);

}


//?Adjustment Code N/F
CASE;

// IF PGM.*Return code is *Record does not exist
IF PGM.*Return_code = 'Y2U0005';

// Send error message - 'AR Adjustment Type not found.'
ERROR(USR2041);
MSGPARM(DTL.Adjustment_Type_Code);

// PAR.Error Status = CND.yes
PAR.Error_Status = 'Y';

ENDIF;

//?Transaction amount greater than adjustment limit
CASE;

// IF DTL.Transaction Amount GT PAR.Adjustment Limit Amount
IF DTL.Transaction_Amount > PAR.Adjustment_Limit_Amount;

// AND PAR.Adjustment Limit Amount is Greater than zero
AND PAR.Adjustment_Limit_Amount > *ZERO;

// Send error message - 'Adj. > Adj. Limit Amount'
ERROR(USR2066);
MSGPARM(DTL.Transaction_Amount);

// PAR.Error Status = CND.yes
PAR.Error_Status = 'Y';

ENDIF;

//?Cash Adjustment not allowed
CASE;

// IF DTL.Cash/Adj is Cash Adjustment
IF DTL.Cash_Adj = 'CSH';

// Send error message - 'Cash must be applied thru a bank deposit record not thru the adjustment pro
ERROR(USR2156);
MSGPARM(DTL.Adjustment_Type_Code);

// PAR.Error Status = CND.yes
PAR.Error_Status = 'Y';

ENDIF;

//?07/06/2016 JBB E5262 - Added RBL to invalid Adjustment Type
//?Check for Invalid adjustment types
CASE;

// IF DTL.Adjustment Type Code is A/R Entry by Customer
IF DTL.Adjustment_Type_Code = 'ARC';

// OR DTL.Adjustment Type Code is A/R Miscellaneous Acct
OR DTL.Adjustment_Type_Code = 'ARM';

// OR DTL.Adjustment Type Code is ACM Apply Credit Memo
OR DTL.Adjustment_Type_Code = 'ACM';

// OR DTL.Adjustment Type Code is CRM Credit Memo
OR DTL.Adjustment_Type_Code = 'CRM';

// OR DTL.Adjustment Type Code is DBM Debit Memo
OR DTL.Adjustment_Type_Code = 'DBM';

// OR DTL.Adjustment Type Code is INV Invoice
OR DTL.Adjustment_Type_Code = 'INV';

// OR DTL.Adjustment Type Code is OA On Account Cash
OR DTL.Adjustment_Type_Code = 'OA';

// OR DTL.Adjustment Type Code is Rebill
OR DTL.Adjustment_Type_Code = 'RB';

// Send error message - 'Adjustment Type is invalid for this operation.'
ERROR(USR2263);
MSGPARM(DTL.Adjustment_Type_Code);

// PAR.Error Status = CND.yes
PAR.Error_Status = 'Y';

ENDIF;

//?User Defined G/L Code
CASE;

// IF PAR.User Enter G/L Status is yes
IF PAR.User_Enter_G_L_Status = 'Y';

CASE;

// IF DTL.Cost Center. . . . . . . is Not Entered
IF DTL.Cost_Center = *BLANK;

// AND DTL.Object Account . . . . . is Not Entered
AND DTL.Object_Account = *BLANK;

// AND DTL.Subsidiary . . . . . . . is Not Entered
AND DTL.Subsidiary = *BLANK;

// Send error message - 'G/L Account Must be entered.'
ERROR(USR2051);
MSGPARM(DTL.Cost_Center);
MSGPARM(DTL.Object_Account);
MSGPARM(DTL.Subsidiary);

// PAR.Error Status = CND.yes
PAR.Error_Status = 'Y';

// PAR.Access Denied (Y/N) = CND.yes
PAR.Access_Denied_Y_N = 'Y';

// IF *OTHERWISE
IF *OTHERWISE;

EXECUTE FUNCTION(RTV Salesperson        RT) TYPE(RTVOBJ) FILE(ARBDCPP)          AC1354262;
PARAMETER(PAR.Company_Number);
PARAMETER(PAR.Invoice_Number);
PARAMETER(PAR.Invoice_Suffix);
PARAMETER(PAR.Salesperson_Code);
{
 //?USER: Process Data record

 MOVE *ALL (To: PAR From: DB1);

}


// PAR.Company Number Alpha = CVTVAR(PAR.Accounting Company Number)
PAR.Company_Number_Alpha = CVTVAR(PAR.Company_Number);

// Call program VAL JDE Account No.s   UP.
CALL PROGRAM(VAL JDE Account No.s   UP) ('ARACTEDT');
PARAMETER(PAR.Company_Number_Alpha);
PARAMETER(DTL.Cost_Center);
PARAMETER(DTL.Object_Account);
PARAMETER(DTL.Subsidiary);
PARAMETER(DTL.G_L_ID_Code_JDE);
PARAMETER(PAR.JDE_Posting_Edit_Code_USR);
PARAMETER(DTL.Description);
PARAMETER(WRK.Error_Return_text);

//?G/L Account Code Error
CASE;

// IF WRK.Error Return text is Error Return
IF WRK.Error_Return_text = 'ERR';

// Send error message - 'G/L Account Code is in Error'
ERROR(USR2070);
MSGPARM(WRK.G_L_Alpha_Code);

// PAR.Error Status = CND.yes
PAR.Error_Status = 'Y';

// PAR.Access Denied (Y/N) = CND.yes
PAR.Access_Denied_Y_N = 'Y';

ENDIF;

//?** If G/L Posting Code = "L" then Sub Ledger is required  E000512
CASE;

// IF PAR.JDE Posting Edit Code USR EQ LCL.JDE Posting Edit Code USR
IF PAR.JDE_Posting_Edit_Code_USR = LCL.JDE_Posting_Edit_Code_USR;

//?** Error if Sub Ledger is zeros and required          E000512
CASE;

// IF DTL.G/L Vendor Number USR is Not Entered
IF DTL.G_L_Vendor_Number_USR = *ZERO;

// Send error message - 'G/L Sub-Ledger code (G/L Vendor #) is Required'
ERROR(USR4263);
MSGPARM(DTL.G_L_Vendor_Number_USR);

ENDIF;

//?** If G/L Posting Code = "L" then Sub Ledger is required  E000512
// IF *OTHERWISE
IF *OTHERWISE;

//?** Error if Sub Ledger is entered & not required      E000512
CASE;

// IF DTL.G/L Vendor Number USR is Entered
IF DTL.G_L_Vendor_Number_USR <> *ZERO;

// Send error message - 'G/L SubLedger Not Req'd, should be zeros'
ERROR(USR4264);
MSGPARM(DTL.G_L_Vendor_Number_USR);

ENDIF;

ENDIF;

ENDIF;

//?User Defined G/L Code
// IF *OTHERWISE
IF *OTHERWISE;

//?** prompting filled in added g/l posting co-not part of E00039
// Call program VAL Acct ID JDE-8 dgt  UP.
CALL PROGRAM(VAL Acct ID JDE-8 dgt  UP) ('ARACTRET');
PARAMETER(DTL.G_L_ID_Code_JDE);
PARAMETER(WRK.Cost_Center);
PARAMETER(WRK.Object_Account);
PARAMETER(WRK.Subsidiary);
PARAMETER(DTL.Description);
PARAMETER(DTL.G_L_Posting_Company);
PARAMETER(PAR.JDE_Posting_Edit_Code_USR);
PARAMETER(LCL.Error_Return_text);

//?** If G/L Posting Code = "L" then Sub Ledger is required  E000512
CASE;

// IF PAR.JDE Posting Edit Code USR EQ LCL.JDE Posting Edit Code USR
IF PAR.JDE_Posting_Edit_Code_USR = LCL.JDE_Posting_Edit_Code_USR;

//?** Error if Sub Ledger is zeros and required          E000512
CASE;

// IF DTL.G/L Vendor Number USR is Not Entered
IF DTL.G_L_Vendor_Number_USR = *ZERO;

// Send error message - 'G/L Sub-Ledger code (G/L Vendor #) is Required'
ERROR(USR4263);
MSGPARM(DTL.G_L_Vendor_Number_USR);

ENDIF;

//?** If G/L Posting Code = "L" then Sub Ledger is required  E000512
// IF *OTHERWISE
IF *OTHERWISE;

//?** Error if Sub Ledger is entered & not required      E000512
CASE;

// IF DTL.G/L Vendor Number USR is Entered
IF DTL.G_L_Vendor_Number_USR <> *ZERO;

// Send error message - 'G/L SubLedger Not Req'd, should be zeros'
ERROR(USR4264);
MSGPARM(DTL.G_L_Vendor_Number_USR);

ENDIF;

ENDIF;

ENDIF;

//?** Create Chargeback Ref#. If it exists, increment til valid. C000789
//?** Create Reference Number for Chargebacks
CASE;

// IF WRK.Company Organization is Daily's
IF WRK.Company_Organization = 'D';

//?** Create Reference Number for Chargebacks            C000789
CASE;

// IF DTL.Adjustment Type Code is Chargeback
IF ( DTL.Adjustment_Type_Code = 'CB';

// OR DTL.Adjustment Type Code is Accrual Chargeback
OR DTL.Adjustment_Type_Code = 'ACB' );

//?** Convert invoice# to 5 character field
// WRK.Invoice Number Alpha USR = CVTVAR(DTL.Invoice Number)
WRK.Invoice_Number_Alpha_USR = CVTVAR(DTL.Invoice_Number);

// WRK.Text USR 5 = SUBSTRING(WRK.Invoice Number Alpha USR,CON.3,CON.5)
WRK.Text_USR_5 = SUBSTRING(WRK.Invoice_Number_Alpha_USR:3:5);

//?** Is sequence#: 1 or 2 digits. Convert to character
// WRK.Sequence Number = DTL.Sequence Number
WRK.Sequence_Number = DTL.Sequence_Number;

// WRK.Text 3 Length USR = CVTVAR(WRK.Sequence Number)
WRK.Text_3_Length_USR = CVTVAR(WRK.Sequence_Number);

// WRK.Byte = SUBSTRING(WRK.Text 3 Length USR,CON.2,CON.1)
WRK.Byte = SUBSTRING(WRK.Text_3_Length_USR:2:1);

// WRK.Number 1.0 USR = CVTVAR(WRK.Byte)
WRK.Number_1_0_USR = CVTVAR(WRK.Byte);

//?** Format the A/R Header CB Invoice Number
CASE;

// IF WRK.Number 1.0 USR is EQ 0
IF WRK.Number_1_0_USR = *ZERO;

//?** If sequence number is only 1 digit, format 6 digits + 1 leading zero
// WRK.Number 1.0 USR = WRK.Sequence Number
WRK.Number_1_0_USR = WRK.Sequence_Number;

// WRK.Text 1 Length USR = CVTVAR(WRK.Number 1.0 USR)
WRK.Text_1_Length_USR = CVTVAR(WRK.Number_1_0_USR);

// WRK.Text USR 6 = CONCAT(WRK.Text USR 5,WRK.Text 1 Length USR,CON.*ZERO)
WRK.Text_USR_6 = WRK.Text_USR_5 + WRK.Text_1_Length_USR (*ZERO);

// WRK.USR number = CVTVAR(WRK.Text USR 6)
WRK.USR_number = CVTVAR(WRK.Text_USR_6);

//?** Put the 6.0 into a 7.0 before converting
// WRK.Number Value - 7 = WRK.USR number
WRK.Number_Value_7 = WRK.USR_number;

// WRK.Invoice Number Alpha USR = CVTVAR(WRK.Number Value - 7)
WRK.Invoice_Number_Alpha_USR = CVTVAR(WRK.Number_Value_7);

//?** Format the A/R Header CB Invoice Number
// IF *OTHERWISE
IF *OTHERWISE;

//?** If sequence number is 2 digits, format total of 7 digits
// WRK.USR Number 2.0 = WRK.Sequence Number
WRK.USR_Number_2_0 = WRK.Sequence_Number;

// WRK.Text 2 Length USR = CVTVAR(WRK.USR Number 2.0)
WRK.Text_2_Length_USR = CVTVAR(WRK.USR_Number_2_0);

//?** Concat sequence# to end of invoice number
// WRK.Invoice Number Alpha USR = CONCAT(WRK.Text USR 5,WRK.Text 2 Length USR,CON.*ZERO)
WRK.Invoice_Number_Alpha_USR = WRK.Text_USR_5 + WRK.Text_2_Length_USR (*ZERO);

ENDIF;

//?** Convert back to numerical and put into Chargeback Ref#
// DTL.USR Reference number = CVTVAR(WRK.Invoice Number Alpha USR)
DTL.USR_Reference_number = CVTVAR(WRK.Invoice_Number_Alpha_USR);

EXECUTE FUNCTION(RTV Check invc exists  RT) TYPE(RTVOBJ) FILE(ARBDCPP)          AC1263564;
PARAMETER(DTL.USR_Reference_number);
{
 //?USER: Processing if Data record not found

 // PGM.*Return code = CND.*Record does not exist
 PGM.*Return_code = 'Y2U0005';

 //?USER: Process Data record

 // PGM.*Return code = CND.*Record already exists
 PGM.*Return_code = 'Y2U0003';

}


//?** If CB # is a duplicate, increment till valid.
// DOW PGM.*Return code is *Record already exists
DOW PGM.*Return_code = 'Y2U0003';

//?** Add 1 to sequence number
// WRK.Sequence Number = WRK.Sequence Number + CON.1
WRK.Sequence_Number = WRK.Sequence_Number + 1;

// WRK.Text 3 Length USR = CVTVAR(WRK.Sequence Number)
WRK.Text_3_Length_USR = CVTVAR(WRK.Sequence_Number);

// WRK.Byte = SUBSTRING(WRK.Text 3 Length USR,CON.2,CON.1)
WRK.Byte = SUBSTRING(WRK.Text_3_Length_USR:2:1);

// WRK.Number 1.0 USR = CVTVAR(WRK.Byte)
WRK.Number_1_0_USR = CVTVAR(WRK.Byte);

//?** Format the A/R Header CB Invoice Number
CASE;

// IF WRK.Number 1.0 USR is EQ 0
IF WRK.Number_1_0_USR = *ZERO;

//?** If sequence number is only 1 digit, format invoice + sequence
// WRK.Number 1.0 USR = WRK.Sequence Number
WRK.Number_1_0_USR = WRK.Sequence_Number;

// WRK.Text 1 Length USR = CVTVAR(WRK.Number 1.0 USR)
WRK.Text_1_Length_USR = CVTVAR(WRK.Number_1_0_USR);

// WRK.Text USR 6 = CONCAT(WRK.Text USR 5,WRK.Text 1 Length USR,CON.*ZERO)
WRK.Text_USR_6 = WRK.Text_USR_5 + WRK.Text_1_Length_USR (*ZERO);

// WRK.USR number = CVTVAR(WRK.Text USR 6)
WRK.USR_number = CVTVAR(WRK.Text_USR_6);

//?** Put the 6.0 into a 7.0 before converting
// WRK.Number Value - 7 = WRK.USR number
WRK.Number_Value_7 = WRK.USR_number;

// WRK.Invoice Number Alpha USR = CVTVAR(WRK.Number Value - 7)
WRK.Invoice_Number_Alpha_USR = CVTVAR(WRK.Number_Value_7);

//?** Convert back to numerical and put into Chargeback Ref#
//?** Update PAR context so A/R Detail stays in sync
// DTL.USR Reference number = CVTVAR(WRK.Invoice Number Alpha USR)
DTL.USR_Reference_number = CVTVAR(WRK.Invoice_Number_Alpha_USR);

//?** Format the A/R Header CB Invoice Number
// IF *OTHERWISE
IF *OTHERWISE;

//?** If sequence number is 2 digits, format total of 7 digits
// WRK.USR Number 2.0 = WRK.Sequence Number
WRK.USR_Number_2_0 = WRK.Sequence_Number;

// WRK.Text 2 Length USR = CVTVAR(WRK.USR Number 2.0)
WRK.Text_2_Length_USR = CVTVAR(WRK.USR_Number_2_0);

//?** Concat sequence# to end of invoice number
// WRK.Invoice Number Alpha USR = CONCAT(WRK.Text USR 5,WRK.Text 2 Length USR,CON.*ZERO)
WRK.Invoice_Number_Alpha_USR = WRK.Text_USR_5 + WRK.Text_2_Length_USR (*ZERO);

//?** Convert back to numerical and put into Chargeback Ref#
//?** Update
// DTL.USR Reference number = CVTVAR(WRK.Invoice Number Alpha USR)
DTL.USR_Reference_number = CVTVAR(WRK.Invoice_Number_Alpha_USR);

ENDIF;

//?** Update  sequence
// DTL.Sequence Number = WRK.Sequence Number
DTL.Sequence_Number = WRK.Sequence_Number;

EXECUTE FUNCTION(RTV Check invc exists  RT) TYPE(RTVOBJ) FILE(ARBDCPP)          AC1263564;
PARAMETER(DTL.USR_Reference_number);
{
 //?USER: Processing if Data record not found

 // PGM.*Return code = CND.*Record does not exist
 PGM.*Return_code = 'Y2U0005';

 //?USER: Process Data record

 // PGM.*Return code = CND.*Record already exists
 PGM.*Return_code = 'Y2U0003';

}


ENDDO;

ENDIF;

//?** Create Reference Number for Chargebacks
// IF *OTHERWISE
IF *OTHERWISE;

//?** Otherwise, if Seaboard or HPB:
//?** Create Reference Number for Chargebacks            C000789
CASE;

// IF DTL.Adjustment Type Code is Chargeback
IF ( DTL.Adjustment_Type_Code = 'CB';

// OR DTL.Adjustment Type Code is Accrual Chargeback
OR DTL.Adjustment_Type_Code = 'ACB' );

//?** Convert invoice# to 6 character field
// WRK.Invoice Number Alpha USR = CVTVAR(DTL.Invoice Number)
WRK.Invoice_Number_Alpha_USR = CVTVAR(DTL.Invoice_Number);

// WRK.Invoice Number 6 USR = SUBSTRING(WRK.Invoice Number Alpha USR,CON.2,CON.6)
WRK.Invoice_Number_6_USR = SUBSTRING(WRK.Invoice_Number_Alpha_USR:2:6);

//?** Convert sequence# to 1 character field
// WRK.Sequence Number = DTL.Sequence Number
WRK.Sequence_Number = DTL.Sequence_Number;

// WRK.Number 1.0 USR = WRK.Sequence Number
WRK.Number_1_0_USR = WRK.Sequence_Number;

// WRK.Text 1 Length USR = CVTVAR(WRK.Number 1.0 USR)
WRK.Text_1_Length_USR = CVTVAR(WRK.Number_1_0_USR);

//?** Concat sequence# to end of invoice number
// WRK.Invoice Number Alpha USR = CONCAT(WRK.Invoice Number 6 USR,WRK.Text 1 Length USR,CON.*ZERO)
WRK.Invoice_Number_Alpha_USR = WRK.Invoice_Number_6_USR + WRK.Text_1_Length_USR (*ZERO);

//?** Convert back to numerical and put into Chargeback Ref#
// DTL.USR Reference number = CVTVAR(WRK.Invoice Number Alpha USR)
DTL.USR_Reference_number = CVTVAR(WRK.Invoice_Number_Alpha_USR);

EXECUTE FUNCTION(RTV Check invc exists  RT) TYPE(RTVOBJ) FILE(ARBDCPP)          AC1263564;
PARAMETER(DTL.USR_Reference_number);
{
 //?USER: Processing if Data record not found

 // PGM.*Return code = CND.*Record does not exist
 PGM.*Return_code = 'Y2U0005';

 //?USER: Process Data record

 // PGM.*Return code = CND.*Record already exists
 PGM.*Return_code = 'Y2U0003';

}


//?** If CB # is a duplicate, increment till valid.
// DOW PGM.*Return code is *Record already exists
DOW PGM.*Return_code = 'Y2U0003';

//?** Add 1 to sequence number
// WRK.Sequence Number = WRK.Sequence Number + CON.1
WRK.Sequence_Number = WRK.Sequence_Number + 1;

// WRK.Number 1.0 USR = WRK.Sequence Number
WRK.Number_1_0_USR = WRK.Sequence_Number;

// WRK.Text 1 Length USR = CVTVAR(WRK.Number 1.0 USR)
WRK.Text_1_Length_USR = CVTVAR(WRK.Number_1_0_USR);

//?** Concat sequence# to end of invoice number
// WRK.Invoice Number Alpha USR = CON.*BLANK
WRK.Invoice_Number_Alpha_USR = *BLANK;

// WRK.Invoice Number Alpha USR = CONCAT(WRK.Invoice Number 6 USR,WRK.Text 1 Length USR,CON.*ZERO)
WRK.Invoice_Number_Alpha_USR = WRK.Invoice_Number_6_USR + WRK.Text_1_Length_USR (*ZERO);

//?** Convert back to numerical and put into Chargeback Ref#
//?** Update PAR context so A/R Detail stays in sync
// DTL.USR Reference number = CVTVAR(WRK.Invoice Number Alpha USR)
DTL.USR_Reference_number = CVTVAR(WRK.Invoice_Number_Alpha_USR);

// DTL.Sequence Number = WRK.Sequence Number
DTL.Sequence_Number = WRK.Sequence_Number;

EXECUTE FUNCTION(RTV Check invc exists  RT) TYPE(RTVOBJ) FILE(ARBDCPP)          AC1263564;
PARAMETER(DTL.USR_Reference_number);
{
 //?USER: Processing if Data record not found

 // PGM.*Return code = CND.*Record does not exist
 PGM.*Return_code = 'Y2U0005';

 //?USER: Process Data record

 // PGM.*Return code = CND.*Record already exists
 PGM.*Return_code = 'Y2U0003';

}


ENDDO;

ENDIF;

ENDIF;

// WRK.Transaction Amount = DTL.Transaction Amount
WRK.Transaction_Amount = DTL.Transaction_Amount;

// LCL.Transaction Amount = DTL.Transaction Amount
LCL.Transaction_Amount = DTL.Transaction_Amount;

// WRK.Adjustment Type Code = DTL.Adjustment Type Code
WRK.Adjustment_Type_Code = DTL.Adjustment_Type_Code;

// WRK.USR Invoice Number = DTL.USR Reference number
WRK.USR_Invoice_Number = DTL.USR_Reference_number;

//?OMS036 - RMC 5/9/05
//?OMS036 - If clearing a a Credit Memo or On Acct - reverse the amt
CASE;

// IF DTL.Invoice Suffix is CM or OA
IF DTL.Invoice_Suffix = 'CM'/'OA';

//?Reverse the amount so it will be taken out of the 360-1410 acct
//?and added to the Acct entered on this screen, could be the 360-3120 acct
//?RMC also do for REFund per Tim 8/31/05
//?RMC also do for STP stop paym per Tim 12/29/05
//?RMC also do for WO1 write off>100 per Tim 11/09/09   S00984
CASE;

// IF DTL.Adjustment Type Code is Inter Company
IF DTL.Adjustment_Type_Code = 'ITC';

// OR DTL.Adjustment Type Code is Write Off Under $100
OR DTL.Adjustment_Type_Code = 'WO';

// OR DTL.Adjustment Type Code is Write Off Under $50
OR DTL.Adjustment_Type_Code = ' WO';

// OR DTL.Adjustment Type Code is Refund
OR DTL.Adjustment_Type_Code = 'REF';

// OR DTL.Adjustment Type Code is Stop Payment
OR DTL.Adjustment_Type_Code = 'STP';

// OR DTL.Adjustment Type Code is Write off over $100
OR DTL.Adjustment_Type_Code = 'WO1';

// LCL.Transaction Amount = CON.*ZERO - LCL.Transaction Amount
LCL.Transaction_Amount = *ZERO - LCL.Transaction_Amount;

ENDIF;

ENDIF;

//?**************
//?RMC 12/23/05 get g/l posting company
// Call program VAL Acct ID JDE-8 dgt  UP.
CALL PROGRAM(VAL Acct ID JDE-8 dgt  UP) ('ARACTRET');
PARAMETER(DTL.G_L_ID_Code_JDE);
PARAMETER(NLL.Cost_Center);
PARAMETER(NLL.Object_Account);
PARAMETER(NLL.Subsidiary);
PARAMETER(NLL.Description);
PARAMETER(DTL.G_L_Posting_Company);
PARAMETER(NLL.JDE_Posting_Edit_Code_USR);
PARAMETER(NLL.Error_Return_text);

//?CALC: Detail screen function fields

EXECUTE FUNCTION(Customer Name DRV) TYPE(DRVFLD)                                AC1631131;
PARAMETER(DTL.Customer_Name_DRV);
PARAMETER(DTL.AR_Customer_Number);
{
 //?Calculate derived field

 EXECUTE FUNCTION(RTV Customer Name      RT) TYPE(RTVOBJ) FILE(CABBREP)          AC1108159;
 PARAMETER(PAR.Ship_To_Customer);
 PARAMETER(PAR.Customer_Name_DRV);
 {
  //?USER: Processing if Data record not found

  MOVE *ALL (To: PAR From: CON);

  // PGM.*Return code = CND.*Record does not exist
  PGM.*Return_code = 'Y2U0005';

  //?USER: Process Data record

  MOVE *ALL (To: PAR From: DB1);

 }

}


//?** Save sub-ledger code for the reverse entry       E00039
// PAR.G/L Sub-Ledger Code = DTL.G/L Vendor Number USR
PAR.G_L_Sub_Ledger_Code = DTL.G_L_Vendor_Number_USR;

//?USER: Create DBF record

EXECUTE FUNCTION(CRT A/R Detail Appl    CR) TYPE(CRTOBJ) FILE(ARBECPP)          AC1338635;
PARAMETER(DTL.Company_Number);
PARAMETER(DTL.Invoice_Number);
PARAMETER(DTL.Invoice_Suffix);
PARAMETER(DTL.Sequence_Number);
PARAMETER(DTL.Adjustment_Type_Code);
PARAMETER(LCL.Transaction_Amount);
PARAMETER(DTL.A_R_Check_Number);
PARAMETER(DTL.Explanation);
PARAMETER(JOB.*Job_date);
PARAMETER(JOB.*Job_date);
PARAMETER(*ZERO);
PARAMETER(DTL.G_L_Post_Date);
PARAMETER(*BLANK);
PARAMETER(DTL.GL_Document_Number);
PARAMETER(DTL.Cash_Adj);
PARAMETER('E');
PARAMETER(JOB.*PROGRAM);
PARAMETER(DTL.Effect_on_Account);
PARAMETER(DTL.G_L_Posting_Company);
PARAMETER(DTL.G_L_ID_Code_JDE);
PARAMETER('Y');
PARAMETER(DTL.A_R_TF_Exempt_Code);
PARAMETER(DTL.A_R_Dtl_UnUsed_Sts_1_1);
PARAMETER(DTL.A_R_Dtl_UnUsed_Sts_2_1);
PARAMETER(DTL.A_R_Dtl_UnUsed_Sts_3_1);
PARAMETER(DTL.A_R_Dtl_UnUsed_Sts_4_2);
PARAMETER(DTL.A_R_Dtl_UnUsed_Sts_5_2);
PARAMETER(DTL.TFS_Adj_Week_Ending_Date);
PARAMETER(DTL.A_R_Orig_Inv_for_CB);
PARAMETER(DTL.USR_Reference_number);
PARAMETER(DTL.A_R_Dtl_UnUsed_Date_4);
PARAMETER(DTL.A_R_Dtl_UnUsed_Date_5);
PARAMETER(DTL.G_L_Vendor_Number_USR);
PARAMETER(DTL.A_R_Dtl_UnUsed_AMT_2);
PARAMETER(DTL.A_R_Dtl_UnUsed_AMT_3);
PARAMETER(DTL.A_R_Dtl_UnUsed_AMT_4);
PARAMETER(DTL.A_R_Dtl_UnUsed_AMT_5);
PARAMETER(DTL.EDI_Status_1);
PARAMETER(DTL.EDI_Status_2);
PARAMETER(DTL.EDI_Status_3);
PARAMETER(DTL.AR_Customer_Number);
PARAMETER(PAR.Access_Denied_Y_N);
{
 //?USER: Processing before Data update

 EXECUTE FUNCTION(Set Date/Time Stamp   IF) TYPE(EXCINTFUN)                      AC1142219;
 PARAMETER(DB1.Job_Time);
 PARAMETER(DB1.User_Id);
 PARAMETER(DB1.Job_Name);
 PARAMETER(DB1.Job_Date);
 {
  //?Execute internal function

  // PAR.Job Time = JOB.*Job time
  PAR.Job_Time = JOB.*Job_time;

  // PAR.User Id = JOB.*USER
  PAR.User_Id = JOB.*USER;

  // PAR.Job Name = JOB.*JOB
  PAR.Job_Name = JOB.*JOB;

  // PAR.Job Date = JOB.*Job date
  PAR.Job_Date = JOB.*Job_date;

 }

 //?USER: Processing after Data update

 // PAR.Access Denied (Y/N) = CND.no
 PAR.Access_Denied_Y_N = 'N';

}


//?USER: Exit program processing

CASE;

// IF PAR.Error Status is yes
IF PAR.Error_Status = 'Y';

// PAR.Access Denied (Y/N) = CND.yes
PAR.Access_Denied_Y_N = 'Y';

ENDIF;

//?New 12/17/01
CASE;

// IF DTL.*CMD key is *Exit
IF DTL.*CMD_key = '03';

// PAR.Access Denied (Y/N) = CND.yes
PAR.Access_Denied_Y_N = 'Y';

ENDIF;

//?perform file updates
CASE;

// IF PAR.Access Denied (Y/N) is no
IF PAR.Access_Denied_Y_N = 'N';

CASE;

// IF PAR.Invoice Suffix is CM, OA, or CB
IF PAR.Invoice_Suffix = 'CB'/'CM'/'OA'/'RB';

EXECUTE FUNCTION(RTV CHG Apply CM or OA RT) TYPE(RTVOBJ) FILE(ARBDCPP)          AC1339587;
PARAMETER(PAR.Company_Number);
PARAMETER(PAR.Invoice_Number);
PARAMETER(PAR.Invoice_Suffix);
PARAMETER(WRK.Transaction_Amount);
PARAMETER(PAR.AR_Customer_Number);
{
 //?USER: Process Data record

 // PAR.USR Amount Applied = PAR.Amount Paid + DB1.Amount Paid
 PAR.USR_Amount_Applied = PAR.Amount_Paid + DB1.Amount_Paid;

 // PAR.USR Cash Appl Amount = PAR.USR Amount Applied + DB1.Adjustment Amount
 PAR.USR_Cash_Appl_Amount = PAR.USR_Amount_Applied + DB1.Adjustment_Amount;

 // PAR.USR Remaining Balance = DB1.Transaction Amount - PAR.USR Cash Appl Amount
 PAR.USR_Remaining_Balance = DB1.Transaction_Amount - PAR.USR_Cash_Appl_Amount;

 //?Days to Pay calculation removed 6/13/96 per ARS026
 //?      Documentation for project detail is on AR26DSN.DOC
 //?    I put it back in when I worked on call 1723 because it needs to be in.
 //?Paid in full date
 CASE;

 // IF PAR.USR Remaining Balance is Zero
 IF PAR.USR_Remaining_Balance = *ZERO;

 // WRK.Paid in Full Date = JOB.*Job date
 WRK.Paid_in_Full_Date = JOB.*Job_date;

 EXECUTE FUNCTION(CLC Days Paid          IF) TYPE(EXCINTFUN)                     AC1351456;
 PARAMETER(DB1.Company_Number);
 PARAMETER(DB1.Transaction_Date_Code);
 PARAMETER(DB1.Last_Payment_Date);
 PARAMETER(PAR.Days_to_Pay);
 {
  //?Execute internal function

  //?  Transaction Date (Invoice Date) will be used instead of Due Date.
  //?     PER Request ARS038
  //?  The Paid in Full Date has been Changed to the Deposit Date
  //?     Which is the Last Payment Date
  // PAR.Number of Days = PAR.Last Payment Date - PAR.Transaction Date Code *DAYS
  PAR.Number_of_Days = DURATION(PAR.Last_Payment_Date PAR.Transaction_Date_Code 'DY'
  1111111 'NONE' 'N' 1);

  //?Handle Negative Days to Pay
  CASE;

  // IF PAR.Number of Days is Less Than Zero
  IF PAR.Number_of_Days < *ZERO;

  // PAR.Days to Pay = CND.equal to zero
  PAR.Days_to_Pay = *ZERO;

  //?Handle Negative Days to Pay
  // IF *OTHERWISE
  IF *OTHERWISE;

  // PAR.Days to Pay = PAR.Number of Days
  PAR.Days_to_Pay = PAR.Number_of_Days;

  ENDIF;

 }

 //?Days to Pay is Negative
 CASE;

 // IF PAR.Days to Pay is less than zero
 IF PAR.Days_to_Pay < *ZERO;

 // PAR.Days to Pay = CND.equal to zero
 PAR.Days_to_Pay = *ZERO;

 ENDIF;

 //?Paid in full date
 // IF *OTHERWISE
 IF *OTHERWISE;

 // PAR.Days to Pay = CND.equal to zero
 PAR.Days_to_Pay = *ZERO;

 // WRK.Paid in Full Date = CND.not entered
 WRK.Paid_in_Full_Date = *ZERO;

 ENDIF;

 EXECUTE FUNCTION(CHG for Apply Credit   CH) TYPE(CHGOBJ) FILE(ARBDCPP)          AC1339595;
 PARAMETER(DB1.Company_Number);
 PARAMETER(DB1.Invoice_Number);
 PARAMETER(DB1.Invoice_Suffix);
 PARAMETER(PAR.USR_Amount_Applied);
 PARAMETER(PAR.USR_Remaining_Balance);
 PARAMETER(DB1.Last_Payment_Date);
 PARAMETER(WRK.Paid_in_Full_Date);
 PARAMETER(PAR.Days_to_Pay);
 {
  //?USER: Processing before Data update

  EXECUTE FUNCTION(Set Date/Time Stamp   IF) TYPE(EXCINTFUN)                      AC1255766;
  PARAMETER(DB1.Job_Time);
  PARAMETER(DB1.User_Id);
  PARAMETER(DB1.Job_Name);
  PARAMETER(DB1.Job_Date);
  {
   //?Execute internal function

   // PAR.Job Time = JOB.*Job time
   PAR.Job_Time = JOB.*Job_time;

   // PAR.User Id = JOB.*USER
   PAR.User_Id = JOB.*USER;

   // PAR.Job Name = JOB.*JOB
   PAR.Job_Name = JOB.*JOB;

   // PAR.Job Date = JOB.*Job date
   PAR.Job_Date = JOB.*Job_date;

  }

 }

}


//?add chargeback record to a/r header
CASE;

// IF WRK.Adjustment Type Code is Chargeback
IF WRK.Adjustment_Type_Code = 'CB';

// OR WRK.Adjustment Type Code is Accrual Chargeback
OR WRK.Adjustment_Type_Code = 'ACB';

EXECUTE FUNCTION(RTV Add Chargeback Hd. RT) TYPE(RTVOBJ) FILE(ARBDCPP)          AC1343147;
PARAMETER(KEY.Company_Number);
PARAMETER(KEY.Invoice_Number);
PARAMETER(KEY.Invoice_Suffix);
PARAMETER(WRK.Adjustment_Type_Code);
PARAMETER(WRK.Transaction_Amount);
PARAMETER(*BLANK);
PARAMETER(WRK.USR_Invoice_Number);
PARAMETER(*ZERO);
PARAMETER(KEY.Sequence_Number);
{
 //?USER: Process Data record

 CASE;

 // IF PAR.Deposit Date is not entered
 IF PAR.Deposit_Date = *ZERO;

 // WRK.Deposit Date = JOB.*Job date
 WRK.Deposit_Date = JOB.*Job_date;

 // IF *OTHERWISE
 IF *OTHERWISE;

 // WRK.Deposit Date = PAR.Deposit Date
 WRK.Deposit_Date = PAR.Deposit_Date;

 ENDIF;

 //?*** PK0333 ***  changed to use par.adjustment type code instead of
 //?cnd.chargeback
 // LCL.Original Inv for CB = PAR.Invoice Number
 LCL.Original_Inv_for_CB = PAR.Invoice_Number;

 EXECUTE FUNCTION(CRT A/R Header         CR) TYPE(CRTOBJ) FILE(ARBDCPP)          AC1341687;
 PARAMETER(PAR.Company_Number);
 PARAMETER(PAR.USR_Invoice_Number);
 PARAMETER('CB');
 PARAMETER(PAR.Adjustment_Type_Code);
 PARAMETER(WRK.Transaction_Amount);
 PARAMETER(*ZERO);
 PARAMETER(*ZERO);
 PARAMETER(WRK.Transaction_Amount);
 PARAMETER('E');
 PARAMETER('O');
 PARAMETER(PAR.Bank_Code);
 PARAMETER(*ZERO);
 PARAMETER(DB1.Order_Number_Ref);
 PARAMETER(DB1.Ship_To_Customer);
 PARAMETER(DB1.Salesperson_Code);
 PARAMETER(DB1.Sales_Route_Code);
 PARAMETER(WRK.Deposit_Date);
 PARAMETER(WRK.Deposit_Date);
 PARAMETER(*ZERO);
 PARAMETER(LCL.Original_Inv_for_CB);
 PARAMETER(*ZERO);
 PARAMETER(*ZERO);
 PARAMETER(DB1.AR_Customer_Number);
 PARAMETER(DB1.A_R_Check_Number);
 PARAMETER(*ZERO);
 PARAMETER(DB1.EDI_Status_1);
 PARAMETER(DB1.EDI_Status_2);
 PARAMETER(DB1.EDI_Status_3);
 {
  //?USER: Processing before Data update

  // DB1.Job Time = JOB.*Job time
  DB1.Job_Time = JOB.*Job_time;

  // DB1.User Id = JOB.*USER
  DB1.User_Id = JOB.*USER;

  // DB1.Job Name = JOB.*JOB
  DB1.Job_Name = JOB.*JOB;

  // DB1.Job Date = JOB.*Job date
  DB1.Job_Date = JOB.*Job_date;

  //?USER: Processing after Data update

  //?E6933 DN  08/12/16 - Create A/R Header Ext record.
  // Call program Crt A/R Header Ext    XF.
  CALL PROGRAM(Crt A/R Header Ext    XF) ('PBX3XFR');
  PARAMETER(DB1.Company_Number);
  PARAMETER(DB1.Invoice_Number);
  PARAMETER(DB1.Invoice_Suffix);
  PARAMETER(DB1.Remaining_Balance_Due);
  PARAMETER(DB1.Order_Number_Ref);
  PARAMETER(DB1.Original_Inv_for_CB);

 }

}


ENDIF;

//?       Create Reversing entry for CM A/R account
// LCL.Transaction Amount = CON.*ZERO - LCL.Transaction Amount
LCL.Transaction_Amount = *ZERO - LCL.Transaction_Amount;

EXECUTE FUNCTION(RTV G/L Code           RT) TYPE(RTVOBJ) FILE(CAEOREP)          AC1348132;
PARAMETER(PAR.Company_Number);
PARAMETER(PAR.AR_Customer_Number);
PARAMETER(PAR.G_L_ID_Code_Alpha);
{
 //?USER: Processing if Data record not found

 // PGM.*Return code = CND.*Record does not exist
 PGM.*Return_code = 'Y2U0005';

 //?USER: Process Data record

 // PAR.G/L Code = DB1.G/L Code
 PAR.G_L_Code = DB1.G_L_Code;

}


CASE;

// IF PGM.*Return code is *Record does not exist
IF PGM.*Return_code = 'Y2U0005';

// PAR.G/L ID Code Alpha = CND.Blank
PAR.G_L_ID_Code_Alpha = *BLANK;

ENDIF;

// Call program Val G/L Act Cde 2 HPE XF.
CALL PROGRAM(Val G/L Act Cde 2 HPE XF) ('PKVBXFR');
PARAMETER(KEY.Company_Number);
PARAMETER(PAR.G_L_ID_Code_Alpha);
PARAMETER(WRK.G_L_Code_Desc_USR);
PARAMETER(WRK.G_L_ID_Code_JDE);
PARAMETER(WRK.G_L_Account_Type_1_USR);
PARAMETER(WRK.G_L_Account_Type_2_USR);
PARAMETER(WRK.Record_Found_USR);

// Call program VAL Acct ID JDE-8 dgt  UP.
CALL PROGRAM(VAL Acct ID JDE-8 dgt  UP) ('ARACTRET');
PARAMETER(WRK.G_L_ID_Code_JDE);
PARAMETER(NLL.Cost_Center);
PARAMETER(NLL.Object_Account);
PARAMETER(NLL.Subsidiary);
PARAMETER(NLL.Description);
PARAMETER(WRK.G_L_Posting_Company);
PARAMETER(NLL.JDE_Posting_Edit_Code_USR);
PARAMETER(NLL.Error_Return_text);

EXECUTE FUNCTION(RTV Next Seq. No.      RT) TYPE(RTVOBJ) FILE(ARBECPP)          AC1336580;
PARAMETER(PAR.Company_Number);
PARAMETER(PAR.Invoice_Number);
PARAMETER(PAR.Invoice_Suffix);
PARAMETER(WRK.Sequence_Number);
{
 //?USER: Processing if Data record not found

 // PAR.Sequence Number = CON.1
 PAR.Sequence_Number = 1;

 //?USER: Process Data record

 // PAR.Sequence Number = DB1.Sequence Number
 PAR.Sequence_Number = DB1.Sequence_Number;

 //?USER: Exit processing

 // PAR.Sequence Number = PAR.Sequence Number + CON.1
 PAR.Sequence_Number = PAR.Sequence_Number + 1;

}


//?** Don't pass in G/L Vendor when creating the reverse entry per Tim
EXECUTE FUNCTION(CRT Reverse Entry Dtl  CR) TYPE(CRTOBJ) FILE(ARBECPP)          AC1339352;
PARAMETER(PAR.Company_Number);
PARAMETER(PAR.Invoice_Number);
PARAMETER(PAR.Invoice_Suffix);
PARAMETER(WRK.Sequence_Number);
PARAMETER('ARC');
PARAMETER(LCL.Transaction_Amount);
PARAMETER(*BLANK);
PARAMETER('Credit A/R');
PARAMETER(JOB.*Job_date);
PARAMETER(JOB.*Job_date);
PARAMETER(*ZERO);
PARAMETER(*ZERO);
PARAMETER(*BLANK);
PARAMETER(*ZERO);
PARAMETER(WRK.Cash_Adj);
PARAMETER('E');
PARAMETER(JOB.*PROGRAM);
PARAMETER(PAR.Effect_on_Account);
PARAMETER(WRK.G_L_Posting_Company);
PARAMETER(WRK.G_L_ID_Code_JDE);
PARAMETER('Y');
PARAMETER(LCL.A_R_TF_Exempt_Code);
PARAMETER(*BLANK);
PARAMETER(*BLANK);
PARAMETER(*BLANK);
PARAMETER(*BLANK);
PARAMETER(*BLANK);
PARAMETER(*ZERO);
PARAMETER(*ZERO);
PARAMETER(*ZERO);
PARAMETER(*ZERO);
PARAMETER(*ZERO);
PARAMETER(*ZERO);
PARAMETER(*ZERO);
PARAMETER(*ZERO);
PARAMETER(*ZERO);
PARAMETER(*ZERO);
PARAMETER(WRK.EDI_Status_1);
PARAMETER(WRK.EDI_Status_2);
PARAMETER(WRK.EDI_Status_3);
PARAMETER(*ZERO);
PARAMETER(*BLANK);
PARAMETER(*BLANK);
PARAMETER(*ZERO);
{
 //?USER: Processing before Data update

 EXECUTE FUNCTION(Set Record Stamp CHGOB IF) TYPE(EXCINTFUN)                     AC1283156;
 PARAMETER(DB1.Job_Time);
 PARAMETER(DB1.User_Id);
 PARAMETER(DB1.Job_Name);
 PARAMETER(DB1.Job_Date);
 {
  //?Execute internal function

  // PAR.Job Time = JOB.*Job time
  PAR.Job_Time = JOB.*Job_time;

  // PAR.User Id = JOB.*USER
  PAR.User_Id = JOB.*USER;

  // PAR.Job Name = JOB.*PROGRAM
  PAR.Job_Name = JOB.*PROGRAM;

  // PAR.Job Date = JOB.*Job date
  PAR.Job_Date = JOB.*Job_date;

 }

}


ENDIF;

ENDIF;

