     Z* CRTBNDRPG
     Z* DFTACTGRP(*NO) BNDDIR(YBNDDIR) DBGVIEW(*SOURCE)
     Z* CVTOPT(*DATETIME) ACTGRP(*CALLER) OPTIMIZE(*BASIC)
     H/TITLE E1I0907  - Determine If Account Structure Has Been Redefined copied from X0907
     H* ----------------------------------------------------------------
     H*
     H*    Copyright (c) 1993
     H*    J. D. Edwards & Company
     H*
     H*        This unpublished material is proprietary to
     H*        J. D. Edwards & Company.  All rights reserved.
     H*        The methods and techniques described herein are
     H*        considered trade secrets and/or confidential.
     H*        Reproduction or distribution, in whole or in part,
     H*        is forbidden except by express written permission
     H*        of J. D. Edwards & Company.
     H*
     H* ----------------------------------------------------------------
     H*                                                                -
     F*
     F*    PROGRAM REVISION LOG
     F*    --------------------
     F*
     F*          Date     Programmer     Nature of Revision
     F*        --------   ----------  ------------------------------------
     F*        01/15/93   DOTSON      SAR # 00415425
     F*        06/08/93   DOTSON      SAR # 00559146
     F*        06/15/94   SPILLANE    SAR # 00773978
     F*        09/06/94   KIRKWOOD    SAR # 00794200
     F*        12/27/94   BUSS        SAR # 00864263
     F*         5/05/20   BADEN       SAR # SDN465
     F*
     F*****************************************************************
     F*
     F*    General Description
     F*    -------------------
     F*
     F*    This program reads the F0907 file and determines if
     F*    the default account number structure has been changed
     F*    by the user. If so a 'Y' is passed backed in the parm
     F*    If not a ' ' is passed backed.
     F*
     F*****************************************************************
     F*
     F*    Flex Account Structure
     F*
     F*F0907LA   IF   E           K DISK    USROPN
     fe10907la  if   e           k disk    usropn
     F*
     D*****************************************************************
     D*
     D*****************************************************************
     D*
     D*/COPY JDECPY,I00DSPROG
     D*****************************************************************    00003
     D*
     D*    PROGRAM STATUS DATA STRUCTURE
     D*    -----------------------------
     D*
     D*    Portions of this data structure are loaded at the time the
     D*    program is loaded.  Other portions of this data structure
     D*    are loaded as you perform I/O.
     D*
     D*    PURPOSE
     D*    -------
     D*    This common subroutine is set up to be used with C0000
     D*    (Cost Center Security) common subroutine and C0001(Edit
     D*    Action Code) common subroutine.  Those two subroutines
     D*    will retrieve ##USER for the user name.
     D*
     D*    No program calcs are done in this subroutine.
     D*
     D ##PSDS         SDS
     D*
     D*          Program Name
     D  ##PROG                 1     10
     D*          Status Code(09999=I/O Error)
     D  ##STAT                11     15  0
     D*          Previous Status code
     D  ##PSTA                16     20  0
     D*          RPG Source Statement Sequence Number
     D  ##SEQN                21     28
     D*          RPG Routine in Which Exception/Error Occured
     D  ##ROUT                29     36
     D*          Number of Parameters Passed to This Program
     D  ##PARM                37     39  0
     D*          Exception Type(MCH=Machine, CPF=CPF)
     D  ##ETYP                40     42
     D*          Exception Message Number
     D  ##ENBR                43     46
     D*          Machine Instruction/Object Definition Template Number
     D  ##MINO                47     50
     D*          Work Area for Messages
     D  ##MWRK                51     80
     D*          Name of Library in Which Program is Located
     D  ##PLIB                81     90
     D*          Retrieved Exdeption Data.  CPF Messages.
     D  ##MSG                 91    170
     D*          Identification of Exception That Caused RPG9001
     D  ##9001               171    174
     D*          Unused
     D  ##FLR1               175    200
     D*          Name of File for Last I/O(Only Updated if Error)
     D  ##LFIL               201    208
     D*          Status Info on Last File Used(Only on Error)
     D  ##LFST               209    243
     D*          Status Code on Last File Used(Only on Error)
     D  ##LFS5               209    213
     D*          Job Name
     D  ##JOBN               244    253
     D*          User Name From User Profile
     D  ##USER               254    263
     D*          Job Number
     D  ##JOB#               264    269  0
     D*          Date Job Entered the System(MMDDYY)
     D  ##JDT                270    275  0
     D*          Date of Program Execution(MMDDYY)
     D  ##EDT                276    281  0
     D*          Time of Program Execttion(HHMMSS)
     D  ##ETM                282    287  0
     D*          Date Program Was Compiled
     D  ##CDT                288    293  0
     D*          Time Program Was Compiled
     D  ##CTM                294    299  0
     D*          Level of the Compiler
     D  ##LVL                300    303
     D*          Source File Name
     D  ##SRCN               304    313
     D*          Source Library Name
     D  ##SRCL               314    323
     D*          Source File Member Name
     D  ##SRCM               324    333
     D*          Unused
     D  ##FLR2               334    429
     C****************************************************************
     C*    MAINLINE PROGRAM
     C*    ----------------
     C*
     C*    *INZSR subroutine executed first time.
     C*
     C     *ENTRY        PLIST
     C                   PARM                    PSFLEX            1
     C                   PARM                    PSOBJL            2 0
     C                   PARM                    PSSUBL            2 0
     C*
     C*     Return values: PSFLEX
     C*       *BLANK = No change from default 12,4,8 setup
     C*       5 or 6 = OBJ size (no other changes)
     C*            Y = Flex on  (segmentation or part sequence changed)
     C*
     C*     Return values: PSOBJL
     C*       4, 5 or 6 = Oblect size
     C*
     C*    Key list for - Chart of Accounts Format
     C*
     C     GYKY0A        KLIST
     C                   KFLD                    GYRETY
     C                   KFLD                    GYEL
     C                   KFLD                    GYSBTY
     C*
     C*    If flex file does not exist, set off flex and exit
     C*
B1   C     $0907         IFEQ      '1'
     C                   MOVEL     *BLANK        PSFLEX
     C                   RETURN
E1   C                   ENDIF
     C*
     C*    Determine if default structure has changed
     C*
     C                   MOVEL     *BLANK        PSFLEX
     C                   Z-ADD     *ZERO         $X                1 0
     C                   Z-ADD     1             GYRETY
     C*    GYRETY        SETLL     I0907
     c     gyrety        setll     i0907la
B1   C                   DO        4             $X
     C*    GYRETY        READE     I0907                                  81
     c     gyrety        reade     i0907la                                81
     C*
B2   C     *IN81         IFEQ      '0'
B3   C                   SELECT
W3   C     $X            WHENEQ    1
     C*
     C*    If first segment not stored in cost center set flex on.
     C*
B4   C     GYSBTY        IFNE      1
     C                   MOVEL     'Y'           PSFLEX
     C                   LEAVE
E4   C                   ENDIF
     C*
     C*    If first segment length not = 12 set flex on.
     C*
B4   C*    GYELL         IFNE      12
B4   c     gyell1        IFNE      12
     C                   MOVEL     'Y'           PSFLEX
     C                   LEAVE
E4   C                   ENDIF
     C*
     C*    If first segment not mapped to cost center set flex on.
     C*
B4   C     GYDTAI        IFNE      'MCU'
     C                   MOVEL     'Y'           PSFLEX
     C                   LEAVE
E4   C                   ENDIF
     C*
     C*----------------------------------------------------------------
     C*
W3   C     $X            WHENEQ    2
     C*
     C*    If second segment not stored in object set flex on.
     C*
B4   C     GYSBTY        IFNE      2
     C                   MOVEL     'Y'           PSFLEX
     C                   LEAVE
E4   C                   ENDIF
     C*
     C*    If second segment not mapped to object set flex on.
     C*
B4   C     GYDTAI        IFNE      'OBJ'
     C                   MOVEL     'Y'           PSFLEX
     C                   LEAVE
E4   C                   ENDIF
     C*
     C*    If second segment length is less than 4, set flex on.
     C*
B4   C*    GYELL         IFLT      4
B4   c     gyell1        IFLT      4
     C                   MOVEL     'Y'           PSFLEX
     C                   LEAVE
E4   C                   ENDIF
     C*
     C*    If object length has increased with no other changes,
     C*    send back new length.
     C*
B4   C*    GYELL         IFGT      4
     C*                  MOVE      GYELL         PSFLEX
B4   c     gyell1        ifgt      4
     c                   move      gyell1        psflex
E4   C                   ENDIF
     C*
     C*----------------------------------------------------------------
     C*
W3   C     $X            WHENEQ    3
     C*
     C*    If third segment not stored in subsidiary set flex on.
     C*
B4   C     GYSBTY        IFNE      3
     C                   MOVEL     'Y'           PSFLEX
     C                   LEAVE
E4   C                   ENDIF
     C*
     C*    If third segment length not = 8 set flex on.
     C*
B4   C*    GYELL         IFNE      8
B4   c     gyell1        ifne      8
     C                   MOVEL     'Y'           PSFLEX
     C                   LEAVE
E4   C                   ENDIF
     C*
     C*    If third segment not mapped to subsidiary set flex on.
     C*
B4   C     GYDTAI        IFNE      'SUB'
     C                   MOVEL     'Y'           PSFLEX
     C                   LEAVE
E4   C                   ENDIF
     C*
     C*    If a fourth segment exists set flex on.
     C*
W3   C     $X            WHENGE    4
     C                   MOVEL     'Y'           PSFLEX
     C                   LEAVE
E3   C                   ENDSL
     C*
X2   C                   ELSE                                                   *in81 on
     C*
     C*    If less than 3 segments are defined set flex off.
     C*
B3   C     $X            IFLE      3
     C                   MOVEL     *BLANK        PSFLEX
     C                   LEAVE
E3   C                   ENDIF
     C*
E2   C                   ENDIF
E1   C                   ENDDO
     C*
     C*----------------------------------------------------------------
     C*
     C*    Determine Object Size
     C*
B1   C     ##PARM        IFGT      1                                                        f
     C*
     C                   Z-ADD     0             $OBJL             2 0
     C                   Z-ADD     1             GYRETY
     C                   Z-ADD     1             GYEL
     C                   Z-ADD     1             GYSBTY
     C                   SETOFF                                       81
     C*
     C*    GYKY0A        SETLL     I0907
     c     gyky0a        setll     i0907la
     C*
B2   C     *IN81         DOWEQ     '0'
     C*
     C*    GYRETY        READE     I0907                                  81
     c     gyrety        reade     i0907la                                81
     C*
B3   C     *IN81         IFEQ      '0'
     C     GYSBTY        ANDEQ     2
     C*                  ADD       GYELL         $OBJL
     c                   add       gyell1        $objl
E3   C                   ENDIF
E2   C                   ENDDO
     C                   Z-ADD     $OBJL         PSOBJL
E1   C                   ENDIF
     C*
     C*----------------------------------------------------------------
     C*
     C*    Determine Subsidiary Size
     C*
B1   C     ##PARM        IFGT      2                                                        f
     C*
     C                   Z-ADD     0             $SUBL             2 0
     C                   Z-ADD     1             GYRETY
     C                   Z-ADD     1             GYEL
     C                   Z-ADD     1             GYSBTY
     C                   SETOFF                                       81
     C*
     C*    GYKY0A        SETLL     I0907
     c     gyky0a        setll     i0907la
     C*
B2   C     *IN81         DOWEQ     '0'
     C*
     C*    GYRETY        READE     I0907                                  81
     c     gyrety        reade     i0907la                                81
     C*
B3   C     *IN81         IFEQ      '0'
     C     GYSBTY        ANDEQ     3
     C*                  ADD       GYELL         $SUBL
     c                   add       gyell1        $subl
E3   C                   ENDIF
E2   C                   ENDDO
     C                   Z-ADD     $SUBL         PSSUBL
E1   C                   ENDIF
     C*
     C*----------------------------------------------------------------
     C*
     C                   RETURN
     C****************************************************************
     C*
     C*    SUBROUTINE *INZSR - Initial subroutine - first time only
     C*    --------------------------------------------------------
     C*
     C*    Processing:
     C*                 1.  Open database files
     C*
     CSR   *INZSR        BEGSR
     CSR   *LIKE         DEFINE    *IN81         $0907
     C*R                 OPEN      F0907LA                              81
     c                   open      e10907la                             81
     CSR                 MOVE      *IN81         $0907
     CSR                 ENDSR
     C****************************************************************
