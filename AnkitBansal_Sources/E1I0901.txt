     Z* CRTBNDRPG
     Z* DFTACTGRP(*NO) BNDDIR(YBNDDIR) DBGVIEW(*SOURCE)
     Z* CVTOPT(*DATETIME) ACTGRP(*CALLER) OPTIMIZE(*BASIC)
     H/TITLE E10901  - Validate G/L Account Number for Enterprise 1 copied from X0901
     H* ----------------------------------------------------------------
     H*
     H*    Copyright (c) 1990
     H*    J. D. Edwards & Company
     H*
     H*        This unpublished material is proprietary to
     H*        J. D. Edwards & Company.  All rights reserved.
     H*        The methods and techniques described herein are
     H*        considered trade secrets and/or confidential.
     H*        Reproduction or distribution, in whole or in part,
     H*        is forbidden except by express written permission
     H*        of J. D. Edwards & Company.
     H*
     H* ----------------------------------------------------------------
     H*                                                                -
     F*
     F*    PROGRAM REVISION LOG
     F*    --------------------
     F*
     F*          Date     Programmer     Nature of Revision
     F*        --------   ----------  ------------------------------------
     F*        07/25/91   FURNAS      SAR # 00384180
     F*        11/14/91   DOTSON      SAR # 00411491
     F*        03/17/92   FURNAS      SAR # 00430810
     F*        05/12/92   FURNAS      SAR # 00477765
     F*        07/06/92   DOTSON      SAR # 00415425
     F*        07/16/92   FURNAS      SAR # 00494338
     F*        07/30/92   FURNAS      SAR # 00506440
     F*        04/01/93   DOTSON      SAR # 00559146
     F*        07/27/93   SPILLANE    SAR # 00638346
     F*        08/31/93   SW930339    SAR # 00651735
     F*        02/01/94   DOTSON      SAR # 00666718
     F*        04/11/94   LB266041    SAR # 00730062
     F*        07/11/94   KIRKWOOD    SAR # 00791771
     F*        08/09/94   BUSS        SAR # 00797013
     F*        09/06/94   KIRKWOOD    SAR # 00794200
     F*        09/22/94   BUSS        SAR # 00820640
     F*        12/01/94   BUSS        SAR # 00790938
     F*        06/14/95   KIRKWOOD    SAR # 00977014
     F*        08/15/95   RB255668    SAR #  1003537
     F*        03/30/20   BRAD BADEN  SDN465  TFS# 16169
     F*                   Copied from source X0901, modified, and compiled
     F*        08/18/20   CENTONZE    SDN465  TFS# 16169
     F*                   Comment the code that gets the language preference. Cant use
     F*                   dtaara X0028 and the dtaara are blank anyways
     F*                   fields:   #9LNGP  $LNGP -- data structures: D00921  QJDF
     F*   11/23/2021 RMC  use E10901L2 in place of E10901LA - new one has key glid/co
     F*****************************************************************
     F*
     F*    General Description
     F*    -------------------
     F*
     F*    This program performs the account number scrub/unscrub
     F*    and optionally validates the account master record
     F*    in file F0901.  Account validation will occur if
     F*    the data structure I0901 is passed to receive the F0901
     F*    data structure. I0901 is contained in data structure
     F*    I090171 which must be added to the calling program with
     F*    a /COPY entry in the I specs.
     F*
     F*    The input account mode can be any of the following
     F*    values:
     F*      1 = short account id
     F*      2 = account number (CC.OBJ.SUB OR Flex)
     F*      3 = 3rd account number (unstructured)
     F*     ' '= unknown, use account symbols
     F*      8 = use cost center, object, subsidiary fields
     F*          in display mode
     F*      9 = use cost center, object, subsidiary fields
     F*          in database mode
     F*      A = account portion only (object and subsidiary)
     F*
     F*    The output account mode can be any of the following
     F*    values:
     F*      1 = return short account id
     F*      2 = return account number (CC.OBJ.SUB or Flex)
     F*      3 = return 3rd account number (unstructured)
     F*      8 = return cost center, object, subsidiary fields
     F*          in display mode
     F*      9 = return cost center, object, subsidiary fields
     F*          in database mode
     F*      I = return in same mode as input mode
     F*      U = return in same mode as input mode, uneditted
     F*     ' '= return in default mode (whichever symbol is blank)
     F*      A = return account (object and subsidiary)
     F*
     F*    The error return parameter will pass back a four digit
     F*    error number if error occurred.  Otherwise, this value will
     F*    be blank.
     F*
     F*****************************************************************
     F*
     F*    General constants
     F*
     F*F0009     IF   E           K DISK    USROPN
     FE10009L1  IF   E           K DISK    USROPN
     F*----------------------------------------------------------------
     F*
     F*    AAI (Key G/L's)
     F*
     F*F0012     IF   E           K DISK    USROPN
     fe10012l1  if   e           k disk    usropn
     F*----------------------------------------------------------------
     F*
     F*    Flex Account Structure
     F*
     F*F0907LA   IF   E           K DISK    USROPN
     fe10907la  if   e           k disk    usropn
     F*
     F*----------------------------------------------------------------
     F*
     F*    Account master
     F*
     F*F0901LA   IF   E           K DISK    USROPN
     F*                                    RENAME(I0901LA:I0901A)
     f*e10901la  if   e           k disk    usropn
     f*                                    rename(I0901la:I0901a)
     fe10901l2  if   e           k disk    usropn
     f*                                    rename(I0901l2:I09012)
     F*F0901LB   IF   E           K DISK    USROPN
     F*                                     RENAME(I0901LB:I0901B)
     fe10901lb  if   e           k disk    usropn
     f*                                    rename(i0901lb:i0901b)
     F*F0901LC   IF   E           K DISK    USROPN
     F*                                     RENAME(I0901LC:I0901C)
     fe10901lc  if   e           k disk    usropn
     f*                                    rename(I0901lc:I0901c)
     F*
     F*    Account Master - Alternate Description
     F*
     F*F0901D    IF   E           K DISK    USROPN
     f*e10901d1  if   e           k disk    usropn                   dont need p16169
     F*                                     INFDS(DS901D)            ''      ''
     F**************************************************************
     D*****************************************************************
     D*    PROGRAM TABLES AND ARRAYS
     D*    -------------------------
     D*
     D*    Speed code arrays
     D*
     D @SP             S              1    DIM(50)                              Speed Code
     D @CC             S             12    DIM(50)                              Speed cost center
     D @OB             S              6    DIM(50)                              Speed object
     D @SU             S              8    DIM(50)                              Speed subsidiary
     D*
     D*    Account number array
     D*
     D*
     D*    Account value array
     D*
     D*
     D*
     D*    Account part arrays
     D*
     D @PL             S              5  0 DIM(12)                              part lengths
     D @2V             S             30    DIM(12)                              part values-work
     D @2L             S              5  0 DIM(12)                              part lengths-work
     D*
     D*    Account part arrays for default values
     D*
     D @4V             S             30    DIM(12)                              part values
     D @4L             S              5  0 DIM(12)                              part lengths
     D*
     D*    Object length array
     D*
     D @BO             S              1    DIM(6)
     D*
     D*    Subsidiary length array
     D*
     D @SB             S              1    DIM(8)
     D*
     D**************************************************************
     D*
     D*    Copy Composite Member for Common Subroutine - C0012
     D*
     D*/COPY JDECPY,E0012
     D**************************************************************
     D*  This is part of a composite common subroutine. In
     D*  order for the subroutine to work correctly, the
     D*  RPG program must /COPY in the following members:
     D*   E0012, C0012
     D*********************************************************************00004
     D*    PROGRAM TABLES AND ARRAYS
     D*    -------------------------
     D*
     D @NM             S              1    DIM(22)                              C0012 Scrub arr
     D @N2             S              1    DIM(22)                              C0012 Scrub arr
     D**************************************************************
     D*
     D*    Copy Composite Member for User Exit Parameters
     D*
     D*/COPY JDECPY,E00UE
     D**************************************************************
     D*  This is part of a common subroutine. In order for
     D*  the subroutine to work correctly, the RPG program
     D*  program must /COPY in the following members:
     D*   E01100, I01100
     D*********************************************************************00040
     D*    PROGRAM TABLES AND ARRAYS
     D*    -------------------------
     D*
     D @EM             S              4    DIM(10)                                            ray
     D @DI             S              4    DIM(10)                                            ray
     D @WN             S              1    DIM(10)                                            ray
     D @DA             S             30    DIM(10)                                            ray
     D*
     D**************************************************************
     D*****************************************************************
     D*    PROGRAM INPUT SPECIFICATIONS AND DATA STRUCTURES
     D*    ------------------------------------------------
     D*
     D*    Account Master Record
     D*
     D*/COPY JDECPY,I090171
     D**************************************************************
     D*  This copy module contains the record image for the F0901
     D*  file at the A7.1 release level.
     D*****************************************************************
     D*
     D*    XF file server format, @@FMT = A71
     D*
     D I0901           DS           500    INZ
     D*                                                                        )
     D*    company
     D  GMCO                   1      5
     D*    account id
     D  GMAID                  6     13
     D*    cost center
     D  GMMCU                 14     25
     D*    object account
     D  GMOBJ                 26     31
     D*    subsidiary
     D  GMSUB                 32     39
     D*    free form (3rd acct  no )
     D  GMANS                 40     64
     D*    description
     D  GMDL01                65     94
     D*    account level of detail
     D  GMLDA                 95     95
     D*    budget pattern code
     D  GMBPC                 96     98
     D*    posting edit
     D  GMPEC                 99     99
     D*    billable (y/n)
     D  GMBILL               100    100
     D*    currency code
     D  GMCRCD               101    103
     D*    unit of measure
     D  GMUM                 104    105
     D*    category code 001
     D  GMR001               106    108
     D*    category code 002
     D  GMR002               109    111
     D*    category code 003
     D  GMR003               112    114
     D*    category code 004
     D  GMR004               115    117
     D*    category code 005
     D  GMR005               118    120
     D*    category code 006
     D  GMR006               121    123
     D*    category code 007
     D  GMR007               124    126
     D*    category code 008
     D  GMR008               127    129
     D*    category code 009
     D  GMR009               130    132
     D*    category code 010
     D  GMR010               133    135
     D*    category code 011
     D  GMR011               136    138
     D*    category code 012
     D  GMR012               139    141
     D*    category code 013
     D  GMR013               142    144
     D*    category code 014
     D  GMR014               145    147
     D*    category code 015
     D  GMR015               148    150
     D*    category code 016
     D  GMR016               151    153
     D*    category code 017
     D  GMR017               154    156
     D*    category code 018
     D  GMR018               157    159
     D*    category code 019
     D  GMR019               160    162
     D*    category code 020
     D  GMR020               163    165
     D*    category code 021
     D  GMR021               166    175
     D*    category code 022
     D  GMR022               176    185
     D*    category code 023
     D  GMR023               186    195
     D*    alternate object account
     D  GMOBJA               196    201
     D*    alternate subsidiary
     D  GMSUBA               202    209
     D*    workers comp
     D  GMWCMP               210    213
     D*    method of computation
     D  GMCCT                214    214
     D*    equipment rate code
     D  GMERC                215    216
     D*    header type code
     D  GMHTC                217    217
     D*    lod quantity roll-up code
     D  GMQLDA               218    218
     D*    cost code complete (y/n)
     D  GMCCC                219    219
     D*    flag model and consolidated accounts
     D  GMFMOD               220    220
     D*    user id
     D  GMUSER               221    230
     D*    program id
     D  GMPID                231    240
     D*    work station id
     D  GMJOBN               241    250
     D*    date updated
     D  GMUPMJ               251    256  0
     D*    time last updated
     D  GMUPMT               257    262  0
     D*    cost object edit code 1
     D  gmcec1               263    263
     D*    cost object edit code 2
     D  gmcec2               264    264
     D*    cost object edit code 3
     D  gmcec3               265    265
     D*    cost object edit code 4
     D  gmcec4               266    266
     D*    item edit code
     D  gmiec                267    267
     D*    fixed asset posting edit
     D  gmfpec               268    268
     D*    type code-acct master
     D  gmstpc               269    269
     D*    g/l account taxable code
     D  gmtxgl               270    270
     D*    target object account
     D  gmtobj               271    276
     D*    target subsidiary
     D  gmtsub               277    284
     D*    purge flag
     D  gmprgf               285    285
     D*    tax rate/area
     D  gmtxa1               286    295
     D*    catg code - g/l 24
     D  gmr024               296    305
     D*    catg code - g/l 25
     D  gmr025               306    315
     D*    catg code - g/l 26
     D  gmr026               316    325
     D*    catg code - g/l 27
     D  gmr027               326    335
     D*    catg code - g/l 28
     D  gmr028               336    345
     D*    catg code - g/l 29
     D  gmr029               346    355
     D*    catg code - g/l 30
     D  gmr030               356    365
     D*    catg code - g/l 31
     D  gmr031               366    375
     D*    catg code - g/l 32
     D  gmr032               376    385
     D*    catg code - g/l 33
     D  gmr033               386    395
     D*    catg code - g/l 34
     D  gmr034               396    405
     D*    catg code - g/l 35
     D  gmr035               406    415
     D*    catg code - g/l 36
     D  gmr036               416    425
     D*    catg code - g/l 37
     D  gmr037               426    435
     D*    catg code - g/l 38
     D  gmr038               436    445
     D*    catg code - g/l 39
     D  gmr039               446    455
     D*    catg code - g/l 40
     D  gmr040               456    465
     D*    catg code - g/l 41
     D  gmr041               466    475
     D*    catg code - g/l 42
     D  gmr042               476    485
     D*    catg code - g/l 43
     D  gmr043               486    495
     D*    adjustment entry
     D  gmadje               496    496
     D*    FAR unallowable flag
     D  gmuafl               497    497
     D*
     D*----------------------------------------------------------------
     D*
     D*    Constants
     D*
     D                 DS
     D $@AN            C                   CONST(30)
     D $@A             C                   CONST(30)
     D $@PV            C                   CONST(12)
     D*-------------------------------------------------------------
     D*
     D*    Define User Exit Program
     D*
     D                 DS
     D  $EXIT                  1     10    INZ('X0901E    ')
     D*----------------------------------------------------------------
     D*
     D*    Account number
     D*
     D DSANI           DS
     D  @AN                    1     30
     D                                     DIM(30)                              Account number
     D  $ANIS                  1      1
     D  $ANIA                  2     30
     D*
     D DSACCT          DS
     D  @A                     1     30
     D                                     DIM(30)                              Part values
     D  $MCU                   1     12
     D  $OBJ                  13     18
     D  $OBJS                 14     18
     D  $SUB                  19     26
     D  $AID                   1      8
     D  $ANS                   1     25
     D*----------------------------------------------------------------
     D*
     D*    Account parts definition
     D*
     D DSFLEX          DS                  OCCURS(20)
     D  $XTYPE                 1      1  0
     D  $XLEN                  2      3  0
     D  $XNUM                  4      4
     D  $XLR                   5      5
     D  $XBEG                  6      7  0
     D  $XEND                  8      9  0
     D  $XLONG                10     11  0
     D  $XCCL                 12     13  0
     D  $XCCP                 14     15  0
     D*----------------------------------------------------------------
     D*
     D*    Definition for mapping of long account parts to flex
     D*
     D DSLONG          DS                  OCCURS(20)
     D  $LTYPE                 1      1  0
     D  $LLEN                  2      3  0
     D  $LNUM                  4      4
     D  $LLR                   5      5
     D  $LBEG                  6      7  0
     D  $LEND                  8      9  0
     D  $LFLEX                10     11  0
     D*----------------------------------------------------------------
     D*
     D*    Account part values
     D*
     D DS@PV           DS
     D  @PV                    1    360
     D                                     DIM(12)                              part values
     D  @PV001                 1     30
     D  @PV002                31     60
     D  @PV003                61     90
     D  @PV004                91    120
     D  @PV005               121    150
     D  @PV006               151    180
     D  @PV007               181    210
     D  @PV008               211    240
     D  @PV009               241    270
     D  @PV010               271    300
     D  @PV011               301    330
     D  @PV012               331    360
     D*----------------------------------------------------------------
     D*
     D*    Account part maximum sizes
     D*
     D                 DS
     D*    Cost center
     D $MXMCU          C                   CONST(12)
     D*    Subsidiary
     D $MXSUB          C                   CONST(08)
     D*    Short id
     D $MXAID          C                   CONST(08)
     D*
     D DS901D          DS
     D  $RCNT                156    159B 0
     D*----------------------------------------------------------------
     D*
     D*    Data Structure to Define Indexes in Common Subroutines
     D*
     D*/COPY JDECPY,I00DSINX
     D*                                                                    00001
     D*    This data strucure provides the field definitions of all
     D*    possible array index field names useable by all common
     D*    subroutines.
     D*
     D DSINX           DS                  INZ                                   00001
     D*
     D*    Indexes of 1 digit 0 decimals
     D*
     D  #A                     1      1  0
     D  #B                     2      2  0
     D  #C                     3      3  0
     D  #D                     4      4  0
     D  #E                     5      5  0
     D  #F                     6      6  0
     D*
     D*    Indexes of 2 digits 0 decimals
     D*
     D  #G                     7      8  0
     D  #H                     9     10  0
     D  #I                    11     12  0
     D  #J                    13     14  0
     D  #K                    15     16  0
     D  #L                    17     18  0
     D*
     D*    Indexes of 3 digits 0 decimals
     D*
     D  #M                    19     21  0
     D  #N                    22     24  0
     D  #O                    25     27  0
     D  #P                    28     30  0
     D  #Q                    31     33  0
     D  #R                    34     36  0
     D*
     D*    Indexes of 4 digits 0 decimals
     D*
     D  #S                    37     40  0
     D  #T                    41     44  0
     D  #U                    45     48  0
     D  #V                    49     52  0
     D  #W                    53     56  0
     D  #X                    57     60  0
     D  #Y                    61     64  0
     D  #Z                    65     68  0
     D*
     D*/COPY JDECPY,I00DSPROG
     D*****************************************************************    00003
     D*
     D*    PROGRAM STATUS DATA STRUCTURE
     D*    -----------------------------
     D*
     D*    Portions of this data structure are loaded at the time the
     D*    program is loaded.  Other portions of this data structure
     D*    are loaded as you perform I/O.
     D*
     D*    PURPOSE
     D*    -------
     D*    This common subroutine is set up to be used with C0000
     D*    (Cost Center Security) common subroutine and C0001(Edit
     D*    Action Code) common subroutine.  Those two subroutines
     D*    will retrieve ##USER for the user name.
     D*
     D*    No program calcs are done in this subroutine.
     D*
     D ##PSDS         SDS
     D*
     D*          Program Name
     D  ##PROG                 1     10
     D*          Status Code(09999=I/O Error)
     D  ##STAT                11     15  0
     D*          Previous Status code
     D  ##PSTA                16     20  0
     D*          RPG Source Statement Sequence Number
     D  ##SEQN                21     28
     D*          RPG Routine in Which Exception/Error Occured
     D  ##ROUT                29     36
     D*          Number of Parameters Passed to This Program
     D  ##PARM                37     39  0
     D*          Exception Type(MCH=Machine, CPF=CPF)
     D  ##ETYP                40     42
     D*          Exception Message Number
     D  ##ENBR                43     46
     D*          Machine Instruction/Object Definition Template Number
     D  ##MINO                47     50
     D*          Work Area for Messages
     D  ##MWRK                51     80
     D*          Name of Library in Which Program is Located
     D  ##PLIB                81     90
     D*          Retrieved Exdeption Data.  CPF Messages.
     D  ##MSG                 91    170
     D*          Identification of Exception That Caused RPG9001
     D  ##9001               171    174
     D*          Unused
     D  ##FLR1               175    200
     D*          Name of File for Last I/O(Only Updated if Error)
     D  ##LFIL               201    208
     D*          Status Info on Last File Used(Only on Error)
     D  ##LFST               209    243
     D*          Status Code on Last File Used(Only on Error)
     D  ##LFS5               209    213
     D*          Job Name
     D  ##JOBN               244    253
     D*          User Name From User Profile
     D  ##USER               254    263
     D*          Job Number
     D  ##JOB#               264    269  0
     D*          Date Job Entered the System(MMDDYY)
     D  ##JDT                270    275  0
     D*          Date of Program Execution(MMDDYY)
     D  ##EDT                276    281  0
     D*          Time of Program Execttion(HHMMSS)
     D  ##ETM                282    287  0
     D*          Date Program Was Compiled
     D  ##CDT                288    293  0
     D*          Time Program Was Compiled
     D  ##CTM                294    299  0
     D*          Level of the Compiler
     D  ##LVL                300    303
     D*          Source File Name
     D  ##SRCN               304    313
     D*          Source Library Name
     D  ##SRCL               314    323
     D*          Source File Member Name
     D  ##SRCM               324    333
     D*          Unused
     D  ##FLR2               334    429
     D*
     D*    Data structure for call to X00921, to get language preferenc
     D*
     D*/COPY JDECPY,I00921
     D*
     D*    User Display Preference Data Structure
     D*
     d********************************************* comment this DS p16169 *****************
     D*D00921          DS            22
     D*
     D*    Date Format
     D* #9FRMT                 1      3
     D*    Date Separator
     D* #9DSEP                 4      4
     D*    Language Preference
     D* #9LNGP                 5      6
     D*    Company
     D* #9CO                   7     11
     D*    Decimal Format
     D* #9DECF                12     12
     D*    Version Prefix
     D* #9VRSP                13     18
     D*    Currency Symbol (Future Use)
     D* #9CUR                 19     19
     D*    Country
     D* #9CTR                 20     22
     D*****************************************************************
     D*
     D*    System Values Data Structure
     D*
     D*/COPY JDECPY,I00QJDF
     D*****************************************************************
     D*
     d********************************************* Comment this DS p16169 *****************
     D*    JDE System Values Data Structure
     D*    ================================
     D*
     D*QJDF            DS          2000
     D*
     D*    Time-out period, in seconds, for menu display file
     D*    (This value obsoleted in release A3)
     D* #$TIME                31     36
     D*
     D*    Single/Double column menu indicator (*IN03)
     D*    (This value obsoleted in release A4)
     D* #$IN03                50     50
     D*
     D*    Source file library name
     D* #$LIBS                81     90
     D*
     D*    Color Palette flag (1=SAA  2=JDE).
     D* #$COLR               100    100
     D*
     D*    Menu display file library name
     D* #$LIBO               131    140
     D*
     D*    Menu display file soft coding data record key (F0020)
     D* #$VOK                141    148
     D*
     D*    User profile file (F0092) library name
     D* #$LIBD               181    190
     D*
     D*    Country code for menu masking
     D* #$CC                 191    193
     D*
     D*    Name of program to be executed by all terminals
     D* #$PROG               231    240
     D*
     D*    System Identification name
     D* #$SYID               281    288
     D*
     D*    Hidden Menu Key
     D  #$HIDM               331    340
     D*
     D*    Positions 381-399 are reserved for BPs or Clients to
     D*    override the Product ID and PTF level displayed on a
     D*    menu in the lower right corner when hidden selection
     D*    25 is taken.  Changes to the data area are done through
     D*    the CHGDTAARA command.  (11/08/95)
     D*
     D*    Product ID (ex. 'Genesis')
     D* reserved                            381 387 #$VERS
     D*    Product Release (ex. '1.1')
     D* reserved                            388 393 #$PRD
     D*    PC Identification (ex.'00009')
     D* reserved                            394 398 #$PC
     D*    Product ID Override Flag (Set to '1' to override)
     D* reserved                            399 399 #$PFLG
     D*
     D*    Member Master Editing Program
     D*    (This value obsoleted in release A5) ????
     D  #$EPGM               431    440
     D*
     D*    Time format (' '=am/pm, '1'=24hr)
     D  #$TF                 450    450
     D*
     D*    Date format (AD,AM DD, YYYY)
     D  #$DF                 451    466
     D*
     D*    Software Protection Notification Days
     D  #$SPD                481    483
     D*
     D*    Software Protection Expiration Date
     D  #$SPED               496    501
     D*
     D*    Software security code
     D  #$SPC                502    507
     D*
     D*    System/38 CPU serial number
     D*    (This value obsoleted in release F5 & A1)
     D*    Re-assigned this field to be the licensed user count for
     D*    User Based Pricing in A7.
     D  #$SRNO               508    512
     D  #$UBP$               508    512
     D  #$UBP#               508    512  0
     D*
     D*    User Based Pricing Audit Flag
     D  #$AUD                520    520
     D*
     D*    User Based Pricing Code
     D  #$UBP                535    544
     D*
     D*    Japanese date flag (' ' = Western  '1' = Japanese)
     D  #$JAPD               600    600
     D*
     D*    MARCAM flag (' ' = No  '1' = Yes)
     D  #$MARC               610    610
     D*
     D*    Software Installation Type (' ' = Normal Install,
     D*                                '1' = One Step Install)
     D  #$INST               611    611
     D*
     D*    Double byte system 1 = yes, 0 = no
     D  #$#RSP               620    620
     D*
     D*    Language preference
     D  #$LNGP               630    631
     D*
     D*    Version prefix
     D  #$VRSP               640    645
     D*
     D*    Number of Users
     D  #$USR                650    659
     D*
     D*    Pricing Method
     D  #$PRMT               670    670
     D*
     D*    Application Override System
     D  #$#SYR               680    683
     D*
     D*    Imaging
     D  #$IMG                690    690
     D*
     D*    Control File Library
     D  #$LIBC               701    710
     D*
     D*    Demo/Training Flag
     D  #$DEMO               720    721
     I*----------------------------------------------------------------
     C****************************************************************
     C*    MAINLINE PROGRAM
     C*    ----------------
     C*
     C*    *INZSR subroutine executed first time.
     C*
     C*    If no parameters, bypass routine.
     C*
     C     ##PARM        CABEQ     0             EOJ
     C*                    -----          ---
     C*
     C*    Initialize routine
     C*
     C                   EXSR      S999
     C*                    ---- ----
     C     PSERR         CABNE     *BLANKS       EOJ
     C*                    -----          ---
     C*------------------------------------------------------------------
     C*
     C*    Move parameters to input work fields
     C*
     C                   MOVEL     PSSYM         $IISYM                         symbol
     C                   MOVEL     PSOMOD        $IOMOD                         output mode
     C                   MOVEL     PSIMOD        $IIMOD                         input mode
     C                   MOVEL     PSIMOD        $IMODE                         input mode
     C                   MOVEL     PSANI         $IANI                          account
     C                   MOVEL     PSMCU         $IMCU                          cost center
     C                   MOVEL     PSOBJ         $IOBJ                          object
     C                   MOVEL     PSSUB         $ISUB                          subsidiary
     C                   MOVEL     $OEDIT        $IEDIT                         edit flag
     C*------------------------------------------------------------------
     C*
     C*    Determine input mode, symbol and account number
     C*      Input parms:
     C*          $IMODE  = input mode work field
     C*          P$ANI   = input account
     C*          P$MCU   = input cost center
     C*          P$OBJ   = input object
     C*          P$SUB   = input subsidiary
     C*      Output parms:
     C*          $IMODE  = input mode work field
     C*          $ISYM   = input symbol
     C*          DSACCT  = account data structure
     C*
     C                   EXSR      S003
     C*                    ---- ----
     C*
     C*    Exit if errors occurred
     C*
     C     PSERR         CABNE     *BLANKS       EOJ
     C*                    -----          ---
     C*------------------------------------------------------------------
     C*
     C*    Determine output mode
     C*      Input parms:
     C*          PSOMOD  = output mode parameter
     C*          $IMODE  = input mode work field
     C*      Output parms:
     C*          $OMODE  = output mode work field
     C*          $OSYM   = output symbol
     C*
     C                   EXSR      S004
     C*                    ---- ----
     C*
     C*    Exit if errors occurred
     C*
     C     PSERR         CABNE     *BLANKS       EOJ
     C*                    -----          ---
     C*------------------------------------------------------------------
     C*
     C*    Create output account from input account
     C*      Input parms:
     C*          $OMODE  = output mode work field
     C*          $IMODE  = input mode work field
     C*          DSACCT  = account data structure
     C*          $OSYM   = output symbol
     C*          PSSYM   = symbol parameter
     C*      Output parms:
     C*          P$ANI   = input account
     C*          P$MCU   = input cost center
     C*          P$OBJ   = input object
     C*          P$SUB   = input subsidiary
     C*          I0901   = account master record
     C*
     C                   EXSR      S005
     C*                    ---- ----
     C*
     C*    Exit if errors occurred
     C*
     C     PSERR         CABNE     *BLANKS       END
     C*                    -----          ---
     C*------------------------------------------------------------------
     C*
     C*    Return.
     C*
     C     END           TAG
     C*          ---       ---
     C*------------------------------------------------------------------
     C*
     C*    Load output parameters
     C*
     C*    ANI account
     C*
B1   C     $SPCDE        IFEQ      '1'
     C     PSERR         OREQ      *BLANKS
     C     PSOMOD        ANDNE     'U'
     C     PSIMOD        OREQ      '8'
     C     PSIMOD        OREQ      '9'
     C*
     C*    Scan for a '\' and if found move account number right
     C*    justified into PSANI
     C*
     C     '\':1         SCAN      P$ANI:1       $POS              2 0    83
B2   C     *IN83         IFEQ      '0'
     C                   MOVEL     P$ANI         PSANI
X2   C                   ELSE
     C     29            SUB       $POS          $LNGTH            2 0
     C                   ADD       1             $LNGTH
     C     $LNGTH        SUBST     P$ANI:$POS    PSANI
E2   C                   ENDIF
     C*
X1   C                   ELSE
     C                   MOVEL     $SVANI        PSANI
E1   C                   ENDIF
     C*
     C*    Cost center, object, subsidiary
     C*
     C                   MOVEL     P$MCU         PSMCU
     C                   MOVEL     P$OBJ         PSOBJ
     C                   MOVEL     P$SUB         PSSUB
     C*
     C*    Output mode
     C*
     C                   MOVEL     $OMODE        PSOMOD
     C*
     C*    Input mode
     C*
     C                   MOVEL     $IMODE        PSIMOD
     C*
     C*    Record return
     C*
B1   C     $OEDIT        IFEQ      '1'
DBN  C                   MOVEL     I0901         PS0901
E1   C                   ENDIF
     C*------------------------------------------------------------------
     C*
     C*    End of program
     C*
     C     EOJ           TAG
     C*          ---       ---
     C*
     C*    Process language overrides
     C*
     C                   EXSR      S011
     C*                    ---- ----
     C*
     C*    Exit program
     C*
     C                   RETURN
     C*
     C*    END MAINLINE PROGRAM
     C*    --------------------
     C*****************************************************************
     C**************************************************************************
     C*
     C*     SUBROUTINE S003  - Load input account number
     C*     --------------------------------------------
     C*
     C*      Input parms:
     C*          $IMODE  = input mode work field
     C*          P$ANI   = input account
     C*          P$MCU   = input cost center
     C*          P$OBJ   = input object
     C*          P$SUB   = input subsidiary
     C*
     C*      Output parms:
     C*          $IMODE  = input mode work field
     C*          $ISYM   = input symbol
     C*          DSACCT  = account data structure
     C*
     CSR   S003          BEGSR
     C*          ----      -----
     C*
     C*    Clear subroutine output parameters
     C*
     CSR                 MOVE      *BLANKS       $ISYM                          input symbol
     CSR                 MOVE      *BLANKS       DSACCT                         account number
     C*------------------------------------------------------------------
     C*
     C*    If input account blank, skip processing unless mode 8 or 9
     C*
B1   CSR   P$ANI         IFEQ      *BLANKS                                      account number
     CSR   $IMODE        ANDNE     '8'                                          input mode
     CSR   $IMODE        ANDNE     '9'                                          input mode
     CSR                 GOTO      E003
     C*                    ---- ----
E1   CSR                 ENDIF
     C*------------------------------------------------------------------
     C*
     C*    Load mode '8' or '9' account number and skip rest of process
     C*
B1   CSR   $IMODE        IFEQ      '8'
     CSR   $IMODE        OREQ      '9'
     CSR                 MOVEL     P$MCU         $MCU
     CSR                 MOVEL     P$OBJ         $OBJ
     CSR                 MOVEL     P$SUB         $SUB
     C*
     C*    If display mode passed, scrub values into database mode
     C*
B2   CSR   $IMODE        IFEQ      '8'
     C*
B3   CSR   $MCU          IFNE      *BLANKS
     C*R                 CALL      'X0006'
     c                   call      'E1I0006'
     C*                    ---- -------
     CSR                 PARM      '1'           $1OMOD            1
     CSR                 PARM      *BLANK        $1IMOD            1
     CSR   $MCU          PARM      $MCU          PSMCU            12
     CSR                 PARM      *BLANKS       PSERRM            4
B4   CSR   PSERRM        IFNE      *BLANKS
     CSR                 MOVEL     PSERRM        PSERR
     CSR                 GOTO      E003
     C*                    ---- ----
E4   CSR                 ENDIF
E3   CSR                 ENDIF
     C*
     C*  Check the length of the subsidiary against F0907 if flex is on
     C*
B3   CSR   $SUB          IFNE      *BLANKS
     CSR   PSERR         ANDEQ     *BLANKS
     C*R                 CALL      'X09012'
     c                   call      'E1I09012'
     C*                    ---- --------
     CSR                 PARM      '1'           $3OMOD            1
     CSR                 PARM      *BLANK        $3IMOD            1
     CSR   $SUB          PARM      $SUB          PSSUB             8
     CSR                 PARM      *BLANKS       PSERRM            4
B4   CSR   PSERRM        IFNE      *BLANKS
     CSR                 MOVEL     PSERRM        PSERR
     CSR                 GOTO      E003
     C*                    ---- ----
E4   CSR                 ENDIF
E3   CSR                 ENDIF
     C*
B3   CSR   PSFLEX        IFEQ      'Y'
     CSR                 MOVEA     *BLANKS       @SB
     CSR                 MOVEA     $SUB          @SB
B4   CSR   $MXSB         IFEQ      6
     CSR   @SB(7)        ANDNE     *BLANK
     CSR                 MOVEL     '3274'        PSERR
E4   CSR                 ENDIF
B4   CSR   $MXSB         IFEQ      7
     CSR   @SB(8)        ANDNE     *BLANK
     CSR                 MOVEL     '3274'        PSERR
E4   CSR                 ENDIF
E3   CSR                 ENDIF
     C*
     C*    Check the object length against F0907.
     C*
B3   CSR   $OBJ          IFNE      *BLANKS
     CSR   PSERR         ANDEQ     *BLANKS
     C*R                 CALL      'X09011'
     c                   call      'E1I09011'
     C*                    ---- --------
     CSR                 PARM      '1'           $2OMOD            1
     CSR                 PARM      *BLANK        $2IMOD            1
     CSR   $OBJ          PARM      $OBJ          PSOBJ             6
     CSR                 PARM      *BLANKS       PSERRM            4
B4   CSR   PSERRM        IFNE      *BLANKS
     CSR                 MOVEL     PSERRM        PSERR
     CSR                 GOTO      E003
     C*                    ---- ----
E4   CSR                 ENDIF
E3   CSR                 ENDIF
     C*
     CSR                 MOVEA     *BLANKS       @BO
     CSR                 MOVEA     $OBJ          @BO
B3   CSR   $MXOBJ        IFEQ      3
     CSR   @BO(4)        ANDNE     *BLANK
     CSR                 MOVEL     '3273'        PSERR
E3   CSR                 ENDIF
B3   CSR   $MXOBJ        IFEQ      4
     CSR   @BO(5)        ANDNE     *BLANK
     CSR                 MOVEL     '3273'        PSERR
E3   CSR                 ENDIF
B3   CSR   $MXOBJ        IFEQ      5
     CSR   @BO(6)        ANDNE     *BLANK
     CSR                 MOVEL     '3273'        PSERR
E3   CSR                 ENDIF
     C*
E2   CSR                 ENDIF
     CSR                 GOTO      E003
     C*                    ---- ----
E1   CSR                 ENDIF
     C*------------------------------------------------------------------
     C*
     C*    Initialize input account array for parsing
     C*
     CSR                 MOVE      *BLANKS       DSANI                          account work
DBN  CSR                 MOVEL     P$ANI         DSANI                          account work
     C*------------------------------------------------------------------
     C*
     C*    Determine account mode symbol and first position of acct
     C*      Input parms:
     C*          $IMODE  = input mode work field
     C*          $ISYM   = input symbol
     C*          DSANI   = account work structure
     C*      Output parms:
     C*          $IMODE  = input mode work field
     C*          $ISYM   = input symbol
     C*          DSANI   = account work structure
     C*          $FPOS   = first position of account number
     C*
     CSR                 EXSR      S003A
     C*                    ---- -----
     C*
     C*    Exit routine if account does not contain a first character
     C*
     CSR   $FPOS         CABLE     *ZERO         E003
     C*                    -----          ----
     C*------------------------------------------------------------------
     C*
     C*    Parse input account
     C*      Input parms:
     C*          DSANI   = account work structure
     C*          $FPOS   = first position of account number
     C*          $IMODE  = input mode work field
     C*      Output parms:
     C*          $P      = number of account parts
     C*          @PV     = account part values
     C*          @PL     = account part lengths
     C*
     CSR                 EXSR      S003B
     C*                    ---- -----
     C*------------------------------------------------------------------
     C*
     C*    Process parsed input values
     C*
B1   CSR                 SELECT
     C*
W1   CSR   $IMODE        WHENEQ    '1'
     CSR                 EXSR      S0031
     C*                    ---- -----
     C*
W1   CSR   $IMODE        WHENEQ    '2'
     CSR   $FLEX         ANDEQ     *BLANK
     CSR                 EXSR      S0032
     C*                    ---- -----
     C*
W1   CSR   $IMODE        WHENEQ    '3'
     CSR                 EXSR      S0033
     C*                    ---- -----
     C*
W1   CSR   $IMODE        WHENEQ    '2'
     CSR   $FLEX         ANDEQ     '1'
     CSR                 EXSR      S0034
     C*                    ---- -----
     C*
E1   CSR                 ENDSL
     C*
     C*    Exit subroutine if error occurred
     C*
     CSR   PSERR         CABNE     *BLANKS       E003
     C*                    -----          ----
     C*------------------------------------------------------------------
     C*
     CSR   E003          ENDSR
     C*****************************************************************
     C**************************************************************************
     C*
     C*     SUBROUTINE S003A - Locate symbol and first position
     C*     ---------------------------------------------------
     C*
     C*      Input parms:
     C*          $IMODE  = input mode work field
     C*          $ISYM   = input symbol
     C*          DSANI   = account work structure
     C*      Output parms:
     C*          $IMODE  = input mode work field
     C*          $ISYM   = input symbol
     C*          DSANI   = account work structure
     C*          $FPOS   = first position of account number
     C*
     CSR   S003A         BEGSR
     C*          -----     -----
     C*
     C*    Initialize subroutine output parms
     C*
     CSR                 Z-ADD     *ZERO         $FPOS             5 0          first character
     C*------------------------------------------------------------------
     C*
     C*    Check if invalid account symbol
     C*
B1   CSR   $ANIS         IFEQ      '#'
B2   CSR   $IMODE        IFEQ      ' '
     CSR   $IMODE        OREQ      '2'
     CSR                 MOVE      *BLANK        $ANIS
E2   CSR                 ENDIF
E1   CSR                 ENDIF
     C*------------------------------------------------------------------
     C*
     C*    Loop until first nonsymbol character is found
     C*
     CSR                 Z-ADD     *ZERO         $SPOS             5 0          symbol position
     CSR                 Z-ADD     1             #I
     C*
B1   CSR   $FPOS         DOWEQ     *ZERO
     CSR   #I            ANDLE     $@AN
     CSR                 MOVEL     @AN(#I)       $WRK1             1
     C*
     C*    Process nonblank character
     C*
B2   CSR   $WRK1         IFNE      *BLANKS
     C*
     C*    Determine if this is a symbol
     C*
B3   CSR   $SPOS         IFEQ      *ZERO
     C*
     C*    Short account
     C*
B4   CSR   $WRK1         IFEQ      GCSYMS
B5   CSR   $IMODE        IFEQ      '1'
     CSR   $IMODE        OREQ      ' '
     CSR                 MOVEL     '1'           $IMODE
     CSR                 Z-ADD     #I            $SPOS
E5   CSR                 ENDIF
X4   CSR                 ELSE
     C*
     C*    Account number (CC.OBJ.SUB or Flex)
     C*
B5   CSR   $WRK1         IFEQ      GCSYML
B6   CSR   $IMODE        IFEQ      '2'
     CSR   $IMODE        OREQ      ' '
     CSR   $IMODE        OREQ      'A'
     CSR                 MOVEL     '2'           $IMODE
     CSR                 Z-ADD     #I            $SPOS
E6   CSR                 ENDIF
X5   CSR                 ELSE
     C*
     C*    Unstructured account
     C*
B6   CSR   $WRK1         IFEQ      GCSYMU
B7   CSR   $IMODE        IFEQ      '3'
     CSR   $IMODE        OREQ      ' '
     CSR                 MOVEL     '3'           $IMODE
     CSR                 Z-ADD     #I            $SPOS
E7   CSR                 ENDIF
X6   CSR                 ELSE
     C*
     C*    First character is not a symbol
     C*
     CSR                 Z-ADD     #I            $FPOS
     C*
E6   CSR                 ENDIF
E5   CSR                 ENDIF
E4   CSR                 ENDIF
     C*
X3   CSR                 ELSE
     C*
     C*    First nonsymbol character
     C*
     CSR                 Z-ADD     #I            $FPOS
     C*
E3   CSR                 ENDIF
E2   CSR                 ENDIF
     C*
     C*    Next position
     C*
     CSR                 ADD       1             #I
E1   CSR                 ENDDO
     C*------------------------------------------------------------------
     C*
     C*    Replace symbol with a blank
     C*
B1   CSR   $SPOS         IFGT      *ZERO
     CSR                 Z-ADD     $SPOS         #I
     CSR                 MOVE      *BLANK        @AN(#I)
E1   CSR                 ENDIF
     C*------------------------------------------------------------------
     C*
     C*    Default account mode
     C*
B1   CSR   $IMODE        IFEQ      *BLANKS
     C*
B2   CSR                 SELECT
W2   CSR   GCSYMS        WHENEQ    *BLANKS
     CSR                 MOVEL     '1'           $IMODE
     C*
W2   CSR   GCSYML        WHENEQ    *BLANKS
     CSR                 MOVEL     '2'           $IMODE
     C*
W2   CSR   GCSYMU        WHENEQ    *BLANKS
     CSR                 MOVEL     '3'           $IMODE
     C*
W2   CSR                 OTHER
     CSR                 MOVEL     '2'           $IMODE
E2   CSR                 ENDSL
     C*
E1   CSR                 ENDIF
     C*------------------------------------------------------------------
     C*
     C*    Force long mode for obj/sub
     C*
B1   CSR   $IMODE        IFEQ      'A'
     CSR                 MOVEL     '2'           $IMODE
E1   CSR                 ENDIF
     C*------------------------------------------------------------------
     C*
     C*    Load account symbol based on mode
     C*
B1   CSR                 SELECT
     C*
W1   CSR   $IMODE        WHENEQ    '1'
     CSR                 MOVEL     GCSYMS        $ISYM
     C*
W1   CSR   $IMODE        WHENEQ    '2'
     CSR                 MOVEL     GCSYML        $ISYM
     C*
W1   CSR   $IMODE        WHENEQ    '3'
     CSR                 MOVEL     GCSYMU        $ISYM
     C*
E1   CSR                 ENDSL
     C*
     C*----------------------------------------------------------------
     CSR   E003A         ENDSR
     C**************************************************************************
     C**************************************************************************
     C*
     C*     SUBROUTINE S003B - Parse input account
     C*     -------------------------------------- ------------
     C*
     C*      Input parms:
     C*          DSANI   = account work structure
     C*          $FPOS   = first position of account number
     C*          $IMODE  = input mode work field
     C*      Output parms:
     C*          $P      = number of account parts
     C*          @PV     = account part values
     C*          @PL     = account part lengths
     C*
     CSR   S003B         BEGSR
     C*          -----     -----
     C*
     C*    Initialize subroutine output parameters
     C*
     CSR                 CLEAR                   @PV                            part values
     CSR                 CLEAR                   @PL                            part lengths
     CSR                 Z-ADD     *ZERO         $P                5 0          # of parts
     C*------------------------------------------------------------------
     C*
     C*    Initialize parsing values
     C*
     CSR                 Z-ADD     $FPOS         #I                             array position
     CSR                 Z-ADD     $FPOS         $BEG              5 0          part begin
     CSR                 Z-ADD     *ZERO         $LEN              5 0          part length
     CSR                 Z-ADD     *ZERO         $LST              5 0          part end
     CSR                 Z-ADD     1             $SEG              2 0          seg length
     CSR                 Z-ADD     1             #X
B1   CSR   #X            IFLE      $XPART
     CSR   #X            OCCUR     DSFLEX
     C*
     C*   Ignore cost center segments for input mode 'A'.
     C*
B2   CSR   PSIMOD        IFEQ      'A'
B3   CSR   $XTYPE        DOWEQ     1
     CSR   #X            ANDLE     $XPART
     CSR                 ADD       1             #X
B4   CSR   #X            IFLE      $XPART
     CSR   #X            OCCUR     DSFLEX
E4   CSR                 ENDIF
E3   CSR                 ENDDO
E2   CSR                 ENDIF
     C*
E1   CSR                 ENDIF
     C*
     C*    Set delimiter flag
     C*
B1   CSR   $IMODE        IFEQ      '1'                                          short id
     CSR   $IMODE        OREQ      '3'                                          3rd account
     CSR                 MOVEL     '0'           $DELIM            1
X1   CSR                 ELSE
     CSR                 MOVEL     '1'           $DELIM
E1   CSR                 ENDIF
     C*------------------------------------------------------------------
     C*
     C*    Parse account string
     C*
B1   CSR   #I            DOWLE     $@AN
     CSR                 MOVEL     '0'           $SEP              1
     CSR                 MOVEL     @AN(#I)       $WRK1             1
     C*------------------------------------------------------------------
     C*
     C*    If last character, set implicit delimiter
     C*
B2   CSR   #I            IFEQ      $@AN
B3   CSR   $WRK1         IFNE      *BLANKS
     CSR                 Z-ADD     #I            $LST
E3   CSR                 ENDIF
     CSR                 ADD       1             #I
E2   CSR                 ENDIF
     C*------------------------------------------------------------------
     C*
     C*    If account number mode and flex is off,
     C*    do not delimit past two parts
     C*
B2   CSR   $IMODE        IFEQ      '2'                                          long account
     CSR   $FLEX         ANDNE     '1'                                          flex off
     CSR   $P            ANDGE     2                                            number of parts
     CSR                 MOVEL     '0'           $DELIM            1
E2   CSR                 ENDIF
     C*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . --
     C*
     C*    Determine if character is a delimiter.
     C*
     C*    Default delimiters
     C*
B2   CSR   $WRK1         IFEQ      '.'                                          default delimit
     CSR   $DELIM        ANDEQ     '1'
     CSR   $WRK1         OREQ      ','                                          default delimit
     CSR   $DELIM        ANDEQ     '1'
     C*
     C*    System defined delimiter
     C*
     CSR   $WRK1         OREQ      GCSEP                                        system delimit
     CSR   *BLANKS       ANDNE     GCSEP
     CSR   $DELIM        ANDEQ     '1'
     CSR                 MOVEL     '1'           $SEP
E2   CSR                 ENDIF
     C*
B2   CSR   $SEP          IFEQ      '1'
     C*
     C*    Implicit delimiter - end of structure reached
     C*
     CSR   #I            ORGT      $@AN                                         end of string
     C*
     C*    Implicit delimiter - no seperator entered
     C*
     CSR   $SEG          ORGT      $XLEN                                        new segment g
     CSR   $IMODE        ANDEQ     '2'                                                      g
     CSR   $FLEX         ANDEQ     '1'                                                      g
     CSR   $P            ANDLT     $XPART                                                   g
     CSR   PSIMOD        ANDNE     'A'                                                      g
     C*
     CSR   $SEG          ORGT      $XLEN                                        new segment g
     CSR   $IMODE        ANDEQ     '2'                                                      g
     CSR   $FLEX         ANDEQ     '1'                                                      g
     CSR   $P            ANDLT     $XAPRT                                                   g
     CSR   PSIMOD        ANDEQ     'A'                                                      g
     C*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . --
     C*
     C*    Load value array if position and length nonzero
     C*
     CSR                 ADD       1             $P                             part number
     CSR   $LST          SUB       $BEG          $LEN                           part length
     CSR                 ADD       1             $LEN                           part length
     C*
     C*    Load @PV with value if position and length are valid
     C*
B3   CSR   $LEN          IFGT      *ZERO
     CSR   $BEG          ANDGT     *ZERO
     CSR   $LEN          SUBST     DSANI:$BEG    @PV($P)                81      part value
     CSR                 Z-ADD     $LEN          @PL($P)                        part length
E3   CSR                 ENDIF
     C*
     C*    Reset position and length values
     C*
     C*    If no seperator entered, current position is beginning
     C*    of next segment
     C*
B3   CSR   $SEP          IFEQ      '0'
     CSR                 Z-ADD     #I            $BEG                           part begin
     CSR                 Z-ADD     1             $SEG                           seg length
     C*
     C*    If seperator entered, next position is beginning
     C*    of next segment
     C*
X3   CSR                 ELSE
     CSR   #I            ADD       1             $BEG                           part begin
     CSR                 Z-ADD     *ZERO         $SEG                           seg length
E3   CSR                 ENDIF
     C*
     CSR                 Z-ADD     *ZERO         $LEN                           part length
     CSR                 Z-ADD     *ZERO         $LST                           part end
     CSR                 ADD       1             #X
B3   CSR   #X            IFLE      $XPART
     CSR   #X            OCCUR     DSFLEX
     C*
     C*   Ignore cost center segments for input mode 'A'.
     C*
B4   CSR   PSIMOD        IFEQ      'A'
B5   CSR   $XTYPE        DOWEQ     1
     CSR   #X            ANDLE     $XPART
     CSR                 ADD       1             #X
B6   CSR   #X            IFLE      $XPART
     CSR   #X            OCCUR     DSFLEX
E6   CSR                 ENDIF
E5   CSR                 ENDDO
E4   CSR                 ENDIF
     C*
E3   CSR                 ENDIF
     C*
X2   CSR                 ELSE
     C*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . --
     C*
     C*    Determine last nonblank character in account
     C*
B3   CSR   $WRK1         IFNE      *BLANKS
     CSR   $LST          OREQ      *ZERO
     CSR                 Z-ADD     #I            $LST
E3   CSR                 ENDIF
E2   CSR                 ENDIF
     C*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . --
     C*
     C*    Increment index
     C*
     CSR                 ADD       1             #I
     CSR                 ADD       1             $SEG
     C*
E1   CSR                 ENDDO
     C*------------------------------------------------------------------
     C*
     C*    If last part is blank, zero length of last part
     C*
B1   CSR   $P            IFGT      *ZERO
B2   CSR   @PV($P)       IFEQ      *BLANKS
B3   CSR   PSFLEX        IFEQ      'Y'
     CSR                 Z-ADD     *ZERO         @PL($P)
     CSR                 SUB       1             $P
X3   CSR                 ELSE
     CSR                 Z-ADD     *ZERO         @PL($P)
E3   CSR                 ENDIF
E2   CSR                 ENDIF
E1   CSR                 ENDIF
     C*
     C*----------------------------------------------------------------
     CSR   E003B         ENDSR
     C**************************************************************************
     C**************************************************************************
     C*
     C*     SUBROUTINE S003C - Replace speed account codes
     C*     ----------------------------------------------
     C*
     C*  Input
     C*       DSACCT   = Account string without delimiters
     C*
     C*  Output
     C*       DSACCT   = Account string without delimiters
     C*       $SPCDE   = Speed code used (1=yes, 0=no)
     C*
     CSR   S003C         BEGSR
     C*          -----     -----
     C*
     C*----------------------------------------------------------------
     C*
     C*    Check for speed code in object portion of account
     C*
B1   CSR   $OBJS         IFEQ      *BLANK
     CSR   $OBJ          ANDNE     *BLANK
DBN  CSR                 MOVEL     $OBJ          $WRK1
     C*
     C*    Search speed code table
     C*
B2   CSR   1             DO        $MAXSP        #X
     C*
     C*    Check if speed code is found
     C*
B3   CSR   @SP(#X)       IFEQ      $WRK1
     C*
     C*    Replace cost center
     C*
B4   CSR   $MCU          IFEQ      *BLANKS
     CSR                 MOVEL     @CC(#X)       $MCU
E4   CSR                 ENDIF
     C*
     C*    Replace object
     C*
     CSR                 MOVEL     @OB(#X)       $OBJ
     C*
     C*    Replace subsidiary
     C*
B4   CSR   $SUB          IFEQ      *BLANKS
     CSR                 MOVEL     @SU(#X)       $SUB
E4   CSR                 ENDIF
     C*
     C*    Set speed code flag and exit routine
     C*
     CSR                 MOVE      '1'           $SPCDE
     CSR                 GOTO      E003C
     C*                    ---- -----
E3   CSR                 ENDIF
E2   CSR                 ENDDO
E1   CSR                 ENDIF
     C*----------------------------------------------------------------
     CSR   E003C         ENDSR
     C**************************************************************************
     C**************************************************************************
     C*
     C*     SUBROUTINE S0031 - Process short account parts
     C*     ----------------------------------------------
     C*
     C*  Input
     C*       @PV      = Account part values
     C*       @PL      = Account part lengths
     C*       $P       = Number of account parts
     C*
     C*  Output
     C*       DSACCT   = Account string without delimiters
     C*
     CSR   S0031         BEGSR
     C*          -----     -----
     C*
     C*------------------------------------------------------------------
     C*
     C*    Check for too many account parts
     C*
B1   CSR   $P            IFGT      1
     CSR                 MOVEL     '2471'        PSERR
     CSR                 GOTO      E0031
     C*                    ---- -----
E1   CSR                 ENDIF
     C*------------------------------------------------------------------
     C*
     C*    Check if account part is too large
     C*
B1   CSR   @PL(1)        IFGT      $MXAID
     CSR                 MOVEL     '2471'        PSERR
     CSR                 GOTO      E0031
     C*                    ---- -----
E1   CSR                 ENDIF
     C*------------------------------------------------------------------
     C*
     C*    Build DSACCT from @PV
     C*
     CSR                 MOVEA     @PV001        @NM
     CSR                 EXSR      C0012
     C*                    ---- -----
     CSR                 Z-ADD     #NUMR         $NBR8             8 0
     CSR                 MOVEL     $NBR8         DSACCT
     C*
     C*----------------------------------------------------------------
     CSR   E0031         ENDSR
     C**************************************************************************
     C**************************************************************************
     C*
     C*     SUBROUTINE S0032 - Process long account parts
     C*     ---------------------------------------------
     C*
     C*  Input
     C*       @PV      = Account part values
     C*       @PL      = Account part lengths
     C*       $P       = Number of account parts
     C*
     C*  Output
     C*       DSACCT   = Account string without delimiters
     C*
     CSR   S0032         BEGSR
     C*          -----     -----
     C*------------------------------------------------------------------
     C*
     C*    Process speed code in object account
     C*
B1   CSR   PSIMOD        IFNE      'A'
     C*
     C*    Load object with possible speed code
     C*
B2   CSR   $P            IFEQ      1
DBN  CSR                 MOVEL     @PV001        $OBJ
X2   CSR                 ELSE
DBN  CSR                 MOVEL     @PV002        $OBJ
E2   CSR                 ENDIF
     C*
     C*    Determine if speed code was used
     C*
B2   CSR   $OBJ          CASNE     *BLANKS       S003C
     C*                    -----          -----
E2   CSR                 ENDCS
     C*
     C*    Load values with speed codes
     C*
B2   CSR   $SPCDE        IFEQ      '1'
     CSR   $OBJ          ANDNE     *BLANKS
     C*
     C*    Cost center speed code value
     C*
B3   CSR   $MCU          IFNE      *BLANKS
B4   CSR   $P            IFEQ      1
     CSR   @PV001        OREQ      *BLANKS
     CSR                 CLEAR                   @PV001
     CSR                 MOVEL     $MCU          @PV001
     CSR                 Z-ADD     $MXMCU        @PL(1)
E4   CSR                 ENDIF
E3   CSR                 ENDIF
     C*
     C*    Object speed code value
     C*
B3   CSR   $OBJ          IFNE      *BLANKS
     CSR                 CLEAR                   @PV002
     CSR                 MOVEL     $OBJ          @PV002
     CSR                 Z-ADD     $MXOBJ        @PL(2)
B4   CSR   $P            IFLT      2
     CSR                 Z-ADD     2             $P
E4   CSR                 ENDIF
E3   CSR                 ENDIF
     C*
     C*    Subsidiary speed code value
     C*
B3   CSR   $SUB          IFNE      *BLANKS
     CSR   @PV003        ANDEQ     *BLANKS
     CSR                 CLEAR                   @PV003
     CSR                 MOVEL     $SUB          @PV003
     CSR                 Z-ADD     $MXSUB        @PL(3)
B4   CSR   $P            IFLT      3
     CSR                 Z-ADD     3             $P
E4   CSR                 ENDIF
E3   CSR                 ENDIF
     C*
E2   CSR                 ENDIF
     C*
     C*    Clear account number
     C*
     CSR                 CLEAR                   DSACCT
E1   CSR                 ENDIF
     C*------------------------------------------------------------------
     C*
     C*    Check for too many account parts
     C*
B1   CSR   $P            IFGT      3
     CSR   $P            ORGT      3
     CSR   PSIMOD        ANDEQ     'A'
     CSR                 MOVEL     '2471'        PSERR
     CSR                 GOTO      E0032
     C*                    ---- -----
E1   CSR                 ENDIF
     C*------------------------------------------------------------------
     C*
     C*    Shift account parts if only object/subsidiary input
     C*
B1   CSR   PSIMOD        IFEQ      'A'
     CSR                 ADD       1             $P
     CSR                 MOVE      @PL(4)        @PL(5)
     CSR                 MOVE      @PV(4)        @PV(5)
     CSR                 MOVE      @PL(3)        @PL(4)
     CSR                 MOVE      @PV(3)        @PV(4)
     CSR                 MOVE      @PL(2)        @PL(3)
     CSR                 MOVE      @PV(2)        @PV(3)
     CSR                 MOVE      @PL(1)        @PL(2)
     CSR                 MOVE      @PV(1)        @PV(2)
     CSR                 Z-ADD     1             @PL(1)
     CSR                 MOVE      *BLANKS       @PV(1)
E1   CSR                 ENDIF
     C*------------------------------------------------------------------
     C*
     C*    Check if account part is too large
     C*
B1   CSR   @PL(1)        IFGT      $MXMCU
     CSR   @PL(2)        ORGT      $MXOBJ
     CSR   @PL(3)        ORGT      $MXSUB
     CSR                 MOVEL     '2471'        PSERR
     CSR                 GOTO      E0032
     C*                    ---- -----
E1   CSR                 ENDIF
     C*------------------------------------------------------------------
     C*
     C*    Check if cost center/account is larger than flex allows
     C*
B1   CSR   $FLEX         IFEQ      '1'
     CSR   @PL(2)        ADD       @PL(3)        $NBR15           15 0
     C*
B2   CSR   @PL(1)        IFGT      $XCLEN
     CSR   $NBR15        ORGT      $XALEN
     CSR                 MOVEL     '2474'        PSERR
     CSR                 GOTO      E0032
     C*                    ---- -----
E2   CSR                 ENDIF
     C*
E1   CSR                 ENDIF
     C*------------------------------------------------------------------
     C*
     C*    Build DSACCT from @PV
     C*
     C*    Cost center duplication
     C*
B1   CSR   $DUP          IFEQ      '1'
     CSR   @PV001        ANDEQ     *BLANKS
     CSR   @PL(1)        ANDEQ     *ZERO
     CSR   $2MCU         ANDNE     *BLANKS
     CSR   $P            ANDGT     1
     CSR                 MOVE      '1'           $SPCDE
     CSR                 MOVEL     $2MCU         @PV001
     CSR                 Z-ADD     $MXMCU        @PL(1)
E1   CSR                 ENDIF
     C*
     C*    Move cost center, right justified
     C*
B1   CSR   @PV001        IFNE      *BLANKS
DBN  CSR                 MOVEL     @PV001        DSANI
     CSR                 Z-ADD     1             #X
     CSR   13            SUB       @PL(1)        #I
B2   CSR   #I            DOWLE     $MXMCU
     CSR                 MOVEL     @AN(#X)       @A(#I)
     CSR                 ADD       1             #X
     CSR                 ADD       1             #I
E2   CSR                 ENDDO
     CSR                 MOVEL     $MCU          $2MCU
E1   CSR                 ENDIF
     C*
     C*    Move object
     C*
B1   CSR   $DUP          IFEQ      '1'
     CSR   @PV002        ANDEQ     *BLANKS
     CSR   $2OBJ         ANDNE     *BLANKS
     C*
B2   CSR   $P            IFGE      2
     CSR   @PL(2)        ANDEQ     *ZERO
     CSR                 MOVE      '1'           $SPCDE
     CSR                 MOVEL     $2OBJ         $OBJ
E2   CSR                 ENDIF
     C*
X1   CSR                 ELSE
DBN  CSR                 MOVEL     @PV002        $OBJ
     CSR                 MOVEL     $OBJ          $2OBJ
E1   CSR                 ENDIF
     C*
     C*    Move subsidiary
     C*
B1   CSR   $DUP          IFEQ      '1'
     CSR   @PV003        ANDEQ     *BLANKS
     CSR   $2SUB         ANDNE     *BLANKS
     C*
B2   CSR   $P            IFGE      3
     CSR   @PL(3)        ANDEQ     *ZERO
     CSR                 MOVE      '1'           $SPCDE
     CSR                 MOVEL     $2SUB         $SUB
     CSR                 ELSE
     CSR                 MOVEL     $SUB          $2SUB
E2   CSR                 ENDIF
     C*
X1   CSR                 ELSE
B2   CSR   @PV003        IFNE      *BLANK
     CSR   $SUB          CAT       @PV003:0      $SUB
B3   CSR   @PV004        IFNE      *BLANK
     CSR   $SUB          CAT       '.':0         $SUB
     CSR   $SUB          CAT       @PV004:0      $SUB
B4   CSR   @PV005        IFNE      *BLANK
     CSR   $SUB          CAT       '.':0         $SUB
     CSR   $SUB          CAT       @PV005:0      $SUB
B5   CSR   @PV006        IFNE      *BLANK
     CSR   $SUB          CAT       '.':0         $SUB
     CSR   $SUB          CAT       @PV006:0      $SUB
     CSR                 MOVEL     $SUB          $2SUB
E5   CSR                 ENDIF
E4   CSR                 ENDIF
E3   CSR                 ENDIF
E2   CSR                 ENDIF
     CSR                 MOVEL     $SUB          $2SUB
E1   CSR                 ENDIF
     C*
     C*----------------------------------------------------------------
     C*
     CSR   E0032         ENDSR
     C**************************************************************************
     C**************************************************************************
     C*
     C*     SUBROUTINE S0033 - Process unstructured account parts
     C*     -----------------------------------------------------
     C*
     C*  Input
     C*       @PV      = Account part values
     C*       @PL      = Account part lengths
     C*       $P       = Number of account parts
     C*
     C*  Output
     C*       DSACCT   = Account string without delimiters
     C*
     CSR   S0033         BEGSR
     C*          -----     -----
     C*
     C*------------------------------------------------------------------
     C*
     C*    Check for too many account parts
     C*
B1   CSR   $P            IFGT      1
     CSR                 MOVEL     '2471'        PSERR
     CSR                 GOTO      E0033
     C*                    ---- -----
E1   CSR                 ENDIF
     C*------------------------------------------------------------------
     C*
     C*    Check if account part is too large
     C*
B1   CSR   @PL(1)        IFGT      25
     CSR                 MOVEL     '2471'        PSERR
     CSR                 GOTO      E0033
     C*                    ---- -----
E1   CSR                 ENDIF
     C*------------------------------------------------------------------
     C*
     C*    Build DSACCT from @PV
     C*
DBN  CSR                 MOVEL     @PV001        DSACCT
     C*----------------------------------------------------------------
     C*
     CSR   E0033         ENDSR
     C**************************************************************************
     C**************************************************************************
     C*
     C*     SUBROUTINE S0034  - Process flex with delimiter
     C*     -----------------------------------------------
     C*
     C*  Input
     C*       @PV      = Account part values
     C*       @PL      = Account part lengths
     C*       $P       = Number of account parts
     C*
     C*  Output
     C*       DSACCT   = Account string without delimiters
     C*
     CSR   S0034         BEGSR
     C*          -----     -----
     C*
     C*------------------------------------------------------------------
     C*
     C*    Check for too many account parts
     C*
B1   CSR   $P            IFGT      $XPART
     CSR   $P            ORGT      $XAPRT
     CSR   PSIMOD        ANDEQ     'A'
     CSR                 MOVEL     '2471'        PSERR
     CSR                 GOTO      E0034
     C*                    ---- -----
E1   CSR                 ENDIF
     C*------------------------------------------------------------------
     C*
     C*    Shift account parts if only object/subsidiary input
     C*
B1   CSR   PSIMOD        IFEQ      'A'
     CSR                 Z-ADD     $P            #X
     CSR   #X            ADD       $XCPRT        #Y
B2   CSR   #X            DOWGT     *ZERO
     CSR   #Y            OCCUR     DSFLEX
B3   CSR   $XTYPE        DOWEQ     1
     CSR                 SUB       1             #Y
     CSR   #Y            OCCUR     DSFLEX
E3   CSR                 ENDDO
B3   CSR   #X            IFEQ      #Y
     CSR                 LEAVE
E3   CSR                 ENDIF
     CSR                 MOVE      @PL(#X)       @PL(#Y)
     CSR                 MOVE      @PV(#X)       @PV(#Y)
     CSR                 Z-ADD     1             @PL(#X)
     CSR                 MOVE      *BLANKS       @PV(#X)
     CSR                 SUB       1             #X
     CSR                 SUB       1             #Y
E2   CSR                 ENDDO
     CSR                 ADD       $XCPRT        $P                             total parts
E1   CSR                 ENDIF
     C*------------------------------------------------------------------
     C*
     C*   Rearrange flex parts in cc.obj.sub order for validation
     C*
B1   CSR   1             DO        $XPART        #H
     CSR                 Z-ADD     *ZERO         $G                2 0
B2   CSR   #H            DOUEQ     $LFLEX
     CSR                 ADD       1             $G
     CSR   $G            OCCUR     DSLONG
E2   CSR                 ENDDO
     CSR                 MOVE      @PV(#H)       @2V($G)
     CSR                 MOVE      @PL(#H)       @2L($G)
E1   CSR                 ENDDO
     C*
     C*   Move work arrays back
     C*
     CSR                 MOVEA     @2V           @PV
     CSR                 MOVEA     @2L           @PL
     C*------------------------------------------------------------------
     C*
     C*    Build DSACCT from @PV
     C*
     C*    Loop on each account part
     C*
     CSR                 Z-ADD     1             #I                             @PV index
B1   CSR   1             DO        $XPART        #X
     CSR   #X            OCCUR     DSLONG
     C*
     C*    Check if account part too long
     C*
B2   CSR   @PL(#I)       IFGT      $LLEN
     CSR                 MOVEL     '2474'        PSERR
     CSR                 GOTO      E0034
     C*                    ---- -----
E2   CSR                 ENDIF
     C*
     C*    Insert default value - account duplication
     C*
B2   CSR   $DUP          IFEQ      '1'
     CSR   @PV(#I)       ANDEQ     *BLANKS
     CSR   @PL(#I)       ANDEQ     *ZERO
     CSR   @4V(#I)       ANDNE     *BLANKS
B3   CSR   $P            IFGT      #I
     CSR   $P            OREQ      #I
     CSR   #I            ANDGT     1
     CSR                 MOVE      '1'           $SPCDE
     CSR                 MOVE      @4V(#I)       @PV(#I)
     CSR                 MOVE      @4L(#I)       @PL(#I)
E3   CSR                 ENDIF
E2   CSR                 ENDIF
     C*
     CSR                 MOVE      *BLANKS       DSANI
     C*
B2   CSR   $LNUM         IFEQ      'N'
     CSR   PSCALL        ANDNE     'P09217'
     CSR                 MOVEL     @PV(#I)       $PV
     CSR                 MOVEA     $PV           @NM
     CSR                 EXSR      C0012
     C*                    ---- -----
     CSR                 Z-ADD     #NUMR         $NBR29           29 0
     CSR                 MOVE      $NBR29        DSANI
X2   CSR                 ELSE
     C*
     C*    Load character value
     C*
DBN  CSR                 MOVEL     @PV(#I)       DSANI
E2   CSR                 ENDIF
     C*
     C*    Calculate position to begin moving from and to
     C*
B2   CSR   $LNUM         IFEQ      'N'
     CSR   PSCALL        ANDNE     'P09217'
     CSR   $@AN          SUB       $LLEN         $F                5 0
     CSR                 ADD       1             $F
     CSR                 Z-ADD     $LBEG         $BEG
X2   CSR                 ELSE
B3   CSR   $LLR          IFEQ      'R'
     CSR                 Z-ADD     1             $F
     CSR   $LLEN         SUB       @PL(#I)       $BEG
     CSR                 ADD       $LBEG         $BEG
X3   CSR                 ELSE
     CSR                 Z-ADD     1             $F
     CSR                 Z-ADD     $LBEG         $BEG
E3   CSR                 ENDIF
E2   CSR                 ENDIF
     C*
     C*    Move account part to DSACCT
     C*
B2   CSR   $BEG          DO        $LEND         #Z
     CSR                 MOVE      @AN($F)       @A(#Z)
     CSR                 ADD       1             $F
E2   CSR                 ENDDO
     C*
     CSR                 ADD       1             #I
E1   CSR                 ENDDO
     C*----------------------------------------------------------------
     C*
     C*    Save values for default
     C*
B1   CSR   PSERR         IFEQ      *BLANKS
     CSR   PSIMOD        ANDNE     'A'
     CSR                 MOVEA     @PV           @4V
     CSR                 MOVEA     @PL           @4L
E1   CSR                 ENDIF
     C*----------------------------------------------------------------
     C*
     CSR   E0034         ENDSR
     C**************************************************************************
     C**************************************************************************
     C*
     C*     SUBROUTINE S004  - Scrub output mode
     C*     ------------------------------------
     C*
     C*      Input parms:
     C*          PSOMOD  = output mode parameter
     C*          $IMODE  = input mode work field
     C*      Output parms:
     C*          $OMODE  = output mode work field
     C*          $OSYM   = output symbol
     C*
     CSR   S004          BEGSR
     C*          ----      -----
     C*
     C*----------------------------------------------------------------
     C*
     C*    Determine output mode
     C*
     CSR                 MOVEL     PSOMOD        $OMODE            1
     C*
     C*    Output mode is default mode
     C*
B1   CSR   $OMODE        IFEQ      *BLANK
B2   CSR   GCSYML        IFEQ      *BLANK
     CSR                 MOVE      '2'           $OMODE
X2   CSR                 ELSE
B3   CSR   GCSYMU        IFEQ      *BLANK
     CSR                 MOVE      '3'           $OMODE
X3   CSR                 ELSE
     CSR                 MOVE      '1'           $OMODE
E3   CSR                 ENDIF
E2   CSR                 ENDIF
E1   CSR                 ENDIF
     C*----------------------------------------------------------------
     C*
     C*    Output mode is same as input mode
     C*
B1   CSR   $OMODE        IFEQ      'I'
     CSR   $OMODE        OREQ      'U'
     CSR                 MOVEL     $IMODE        $OMODE
E1   CSR                 ENDIF
     C*----------------------------------------------------------------
     C*
     C*    Output mode is flex or long
     C*
B1   CSR   $OMODE        IFEQ      'A'
     CSR                 MOVEL     '2'           $OMODE
E1   CSR                 ENDIF
     C*----------------------------------------------------------------
     C*
     C*    Determine output symbol
     C*
     CSR                 MOVE      *BLANKS       $OSYM             1
     C*
B1   CSR                 SELECT
     C*
W1   CSR   $OMODE        WHENEQ    '1'
     CSR                 MOVEL     GCSYMS        $OSYM
     C*
W1   CSR   $OMODE        WHENEQ    '2'
     CSR                 MOVEL     GCSYML        $OSYM
     C*
W1   CSR   $OMODE        WHENEQ    '3'
     CSR                 MOVEL     GCSYMU        $OSYM
     C*
E1   CSR                 ENDSL
     C*----------------------------------------------------------------
     C*
     C*
     CSR   E004          ENDSR
     C*****************************************************************
     C*****************************************************************
     C*
     C*     SUBROUTINE S005  - Create output account
     C*     ----------------------------------------
     C*
     C*      Input parms:
     C*          DSACCT  = account data structure
     C*          DSANI   = account string with symbol ($ANIA)
     C*          $OMODE  = output mode work field
     C*          $IMODE  = input mode work field
     C*          $OSYM   = output symbol
     C*          PSSYM   = symbol parameter
     C*      Output parms:
     C*          P$ANI   = input account
     C*          P$MCU   = input cost center
     C*          P$OBJ   = input object
     C*          P$SUB   = input subsidiary
     C*          I0901   = account master record
     C*
     CSR   S005          BEGSR
     C*          ----      -----
     C*
     CSR                 CLEAR                   DSANI
     CSR                 CLEAR                   P$ANI
     CSR                 CLEAR                   P$MCU
     CSR                 CLEAR                   P$OBJ
     CSR                 CLEAR                   P$SUB
     C*----------------------------------------------------------------
     C*
     C*    Create output account from input account
     C*
     C*      Input parms:
     C*          DSACCT  = account data structure
     C*          $OMODE  = output mode work field
     C*          $IMODE  = input mode work field
     C*      Output parms:
     C*          DSANI   = account string with symbol ($ANIA)
     C*          I0901   = account master record
     C*          P$MCU   = input cost center
     C*          P$OBJ   = input object
     C*          P$SUB   = input subsidiary
     C*
B1   CSR                 SELECT
     C*
W1   CSR   $OMODE        WHENEQ    '1'
     CSR                 EXSR      S0051
     C*                    ---- -----
     C*
W1   CSR   $OMODE        WHENEQ    '2'
     CSR   $FLEX         ANDEQ     *BLANK
     CSR                 EXSR      S0052
     C*                    ---- -----
     C*
W1   CSR   $OMODE        WHENEQ    '2'
     CSR   $FLEX         ANDEQ     '1'
     CSR   GCSEP         ANDEQ     *BLANK
     CSR                 EXSR      S0052
     C*                    ---- -----
     C*
W1   CSR   $OMODE        WHENEQ    '3'
     CSR                 EXSR      S0053
     C*                    ---- -----
     C*
W1   CSR   $OMODE        WHENEQ    '2'
     CSR   $FLEX         ANDEQ     '1'
     CSR                 EXSR      S0054
     C*                    ---- -----
     C*
W1   CSR   $OMODE        WHENEQ    '8'
     CSR   $OMODE        OREQ      '9'
     CSR                 EXSR      S0059
     C*                    ---- -----
     C*
W1   CSR                 OTHER
     CSR                 EXSR      S005A
     C*                    ---- -----
     C*
E1   CSR                 ENDSL
     C*----------------------------------------------------------------
     C*
     C*    Create output for account portion only
     C*
B1   CSR   PSOMOD        IFEQ      'A'
     C*
     C*    Load the account mode symbol if:
     C*      1. Symbol is requested ($INSYM='1')
     C*      2. Symbol is not blank
     C*
B2   CSR   $INSYM        IFEQ      '1'
     CSR   $OSYM         ANDNE     *BLANK
     CSR   $ANIA         ANDNE     *BLANK
     CSR                 MOVEL     $OSYM         $ANIS
DBN  CSR                 MOVEL     DSANI         P$ANI
X2   CSR                 ELSE
     CSR                 MOVEL     $ANIA         P$ANI
E2   CSR                 ENDIF
     C*
E1   CSR                 ENDIF
     C*----------------------------------------------------------------
     C*
     C*    Load output account for full account
     C*
B1   CSR   PSOMOD        IFNE      'A'
     C*
     C*    Create output account for:
     C*      -Short mode of output
     C*      -Account number mode of output
     C*      -Unstructured mode of output
     C*
B2   CSR   $OMODE        IFEQ      '1'
     CSR   $OMODE        OREQ      '2'
     CSR   $OMODE        OREQ      '3'
     C*
     C*    Load the account mode symbol if:
     C*      1. Symbol is requested ($INSYM='1')
     C*      2. Symbol is not blank
     C*
B3   CSR   $INSYM        IFEQ      '1'
     CSR   $OSYM         ANDNE     *BLANK
     CSR   $ANIA         ANDNE     *BLANK
     CSR                 MOVEL     $OSYM         $ANIS
DBN  CSR                 MOVEL     DSANI         P$ANI
X3   CSR                 ELSE
     CSR                 MOVEL     $ANIA         P$ANI
E3   CSR                 ENDIF
     C*
E2   CSR                 ENDIF
E1   CSR                 ENDIF
     C*----------------------------------------------------------------
     C*
     CSR   E005          ENDSR
     C*****************************************************************
     C**************************************************************************
     C*
     C*     SUBROUTINE S0051 - Create short account
     C*     ---------------------------------------
     C*
     C*  Input
     C*       DSACCT   = Account string without delimiters
     C*       DSANI    = Account string initialized with symbol
     C*                  (includes $ANIA subfield)
     C*
     C*  Output
     C*       $ANIA    = Account string with delimiters
     C*
     CSR   S0051         BEGSR
     C*          -----     -----
     C*
     C*----------------------------------------------------------------
     C*
     C*    Create output from input
     C*
B1   CSR   $OEDIT        IFEQ      '1'
     CSR   $IMODE        ORNE      '1'
     CSR                 EXSR      S010
     C*                    ---- ----
     CSR                 MOVEL     GMAID         $ANIA
X1   CSR                 ELSE
DBN  CSR                 MOVEL     DSACCT        $ANIA
E1   CSR                 ENDIF
     C*
     C*----------------------------------------------------------------
     CSR   E0051         ENDSR
     C**************************************************************************
     C**************************************************************************
     C*
     C*     SUBROUTINE S0052 - Create long account
     C*     --------------------------------------
     C*
     C*  Input
     C*       DSACCT   = Account string without delimiters
     C*       DSANI    = Account string initialized with symbol
     C*                  (includes $ANIA subfield)
     C*
     C*  Output
     C*       $ANIA    = Account string with delimiters
     C*
     C*
     CSR   S0052         BEGSR
     C*          -----     -----
     C*
     C*----------------------------------------------------------------
     C*
     C*    Create output from input
     C*
B1   CSR   $OEDIT        IFEQ      '1'
     CSR   $IMODE        OREQ      '1'
     CSR   $IMODE        OREQ      '3'
     CSR                 EXSR      S010
     C*                    ---- ----
     CSR                 MOVEL     GMMCU         $MCU
     CSR                 MOVEL     GMOBJ         $OBJ
     CSR                 MOVEL     GMSUB         $SUB
E1   CSR                 ENDIF
     C*
     C*    Determine delimiter
     C*
     CSR                 MOVEL     '.'           $DEL              1
B1   CSR   GCSEP         IFNE      *BLANK
     CSR                 MOVEL     GCSEP         $DEL
E1   CSR                 ENDIF
     C*
     C*    Load output
     C*
B1   CSR   PSOMOD        IFEQ      'A'
     CSR                 MOVEL     $OBJ          $ANIA
     C*
B2   CSR   $SUB          IFNE      *BLANK
     C*
B3   CSR                 SELECT
W3   CSR   $MXOBJ        WHENEQ    3
     CSR                 MOVEL     $DEL          @AN(05)
DBN  CSR                 MOVEA     $SUB          @AN(06)
W3   CSR   $MXOBJ        WHENEQ    4
     CSR                 MOVEL     $DEL          @AN(06)
DBN  CSR                 MOVEA     $SUB          @AN(07)
W3   CSR   $MXOBJ        WHENEQ    5
     CSR                 MOVEL     $DEL          @AN(07)
DBN  CSR                 MOVEA     $SUB          @AN(08)
W3   CSR   $MXOBJ        WHENEQ    6
     CSR                 MOVEL     $DEL          @AN(08)
DBN  CSR                 MOVEA     $SUB          @AN(09)
E3   CSR                 ENDSL
     C*
E2   CSR                 ENDIF
     C*
X1   CSR                 ELSE
     C*
     CSR                 MOVEL     $MCU          $ANIA
B2   CSR   $OBJ          IFNE      *BLANK
     CSR   $SUB          ORNE      *BLANK
     CSR                 MOVEL     $DEL          @AN(14)
DBN  CSR                 MOVEA     $OBJ          @AN(15)
     C*
B3   CSR   $SUB          IFNE      *BLANK
     C*
B4   CSR                 SELECT
W4   CSR   $MXOBJ        WHENEQ    3
     CSR                 MOVEL     $DEL          @AN(18)
DBN  CSR                 MOVEA     $SUB          @AN(19)
W4   CSR   $MXOBJ        WHENEQ    4
     CSR                 MOVEL     $DEL          @AN(19)
DBN  CSR                 MOVEA     $SUB          @AN(20)
W4   CSR   $MXOBJ        WHENEQ    5
     CSR                 MOVEL     $DEL          @AN(20)
DBN  CSR                 MOVEA     $SUB          @AN(21)
W4   CSR   $MXOBJ        WHENEQ    6
     CSR                 MOVEL     $DEL          @AN(21)
DBN  CSR                 MOVEA     $SUB          @AN(22)
E4   CSR                 ENDSL
     C*
E3   CSR                 ENDIF
E2   CSR                 ENDIF
E1   CSR                 ENDIF
     C*
     C*----------------------------------------------------------------
     CSR   E0052         ENDSR
     C**************************************************************************
     C**************************************************************************
     C*
     C*     SUBROUTINE S0053 - Create unstructured account
     C*     ----------------------------------------------
     C*
     C*  Input
     C*       DSACCT   = Account string without delimiters
     C*       DSANI    = Account string initialized with symbol
     C*                  (includes $ANIA subfield)
     C*
     C*  Output
     C*       $ANIA    = Account string with delimiters
     C*
     CSR   S0053         BEGSR
     C*          -----     -----
     C*
     C*----------------------------------------------------------------
     C*
     C*    Create output from input
     C*
B1   CSR   $OEDIT        IFEQ      '1'
     CSR   $IMODE        ORNE      '3'
     CSR                 EXSR      S010
     C*                    ---- ----
     CSR                 MOVEL     GMANS         $ANIA
X1   CSR                 ELSE
DBN  CSR                 MOVEL     DSACCT        $ANIA
E1   CSR                 ENDIF
     C*----------------------------------------------------------------
     C*
     C*    If unstructured is default and is blank value,
     C*    return short id
     C*
B1   CSR   $ANIA         IFEQ      *BLANKS
     CSR   PSOMOD        ANDEQ     *BLANKS
     CSR                 MOVEL     GCSYMS        $OSYM
     CSR                 MOVEL     '1'           $OMODE
     CSR                 EXSR      S0051
     C*                    ---- -----
E1   CSR                 ENDIF
     C*
     C*----------------------------------------------------------------
     CSR   E0053         ENDSR
     C**************************************************************************
     C**************************************************************************
     C*
     C*     SUBROUTINE S0054  - Create flex account with delimiters
     C*     -------------------------------------------------------
     C*
     C*  Input
     C*       DSACCT   = Account string without delimiters
     C*       DSANI    = Account string initialized with symbol
     C*                  (includes $ANIA subfield)
     C*
     C*  Output
     C*       $ANIA    = Account string with delimiters
     C*
     C*
     CSR   S0054         BEGSR
     C*          -----     -----
     C*
     C*----------------------------------------------------------------
     C*
     C*    Create output from input
     C*
B1   CSR   $OEDIT        IFEQ      '1'
     CSR   $IMODE        OREQ      '1'
     CSR   $IMODE        OREQ      '3'
     CSR                 EXSR      S010
     C*                    ---- ----
     CSR                 MOVEL     GMMCU         $MCU
     CSR                 MOVEL     GMOBJ         $OBJ
     CSR                 MOVEL     GMSUB         $SUB
E1   CSR                 ENDIF
     C*----------------------------------------------------------------
     C*
     C*    Determine delimiter
     C*
     CSR                 MOVEL     '.'           $DEL              1
B1   CSR   GCSEP         IFNE      *BLANK
     CSR                 MOVEL     GCSEP         $DEL
E1   CSR                 ENDIF
     C*----------------------------------------------------------------
     C*
     C*    Rearrange cc.obj.sub ordered DSACCT into flex order
     C*
B1   CSR                 DO        $XPART        #H
     CSR   #H            OCCUR     DSLONG
     CSR                 Z-ADD     $LFLEX        $X                2 0
     C*
     C*    Process each account part
     C*
     CSR   $X            OCCUR     DSFLEX
     C*
     C*    Skip cost center parts if obj/sub output only
     C*
B2   CSR   $XTYPE        IFEQ      1
B3   CSR   PSOMOD        IFEQ      'A'
     CSR                 ITER
E3   CSR                 ENDIF
E2   CSR                 ENDIF
     C*
     C*    Determine segment starting position in flex structure
     C*    Allow for separator positions = 1 less than segment number
     C*
     CSR                 Z-ADD     $XBEG         #I                             seg start pos
     CSR                 ADD       $X            #I                             separators
     C*
     C*    If obj/sub output only - reduce #I by length of any
     C*    preceding cost center parts including separators.
     C*
B2   CSR   PSOMOD        IFEQ      'A'
     CSR                 SUB       $XCCL         #I
     CSR                 SUB       $XCCP         #I
E2   CSR                 ENDIF
     C*
     C*    Move characters from cc.obj.sub structure to flex
     C*
B2   CSR   $LBEG         DO        $LEND         #O
     CSR                 MOVE      @A(#O)        @AN(#I)
     CSR                 ADD       1             #I
E2   CSR                 ENDDO
     C*
     C*    Insert delimiter if there is more to come
     C*
B2   CSR   $X            IFLT      $XPART
     CSR   $XEND         ADD       1             #O
     CSR   $@A           SUB       $XEND         #M
B3   CSR   #O            IFLE      $@A
     CSR   #M            ANDGT     *ZERO
     CSR   #M            SUBST     DSACCT:#O     $WRK30           30
B4   CSR   $WRK30        IFNE      *BLANKS
     CSR                 MOVEL     $DEL          @AN(#I)
E4   CSR                 ENDIF
E3   CSR                 ENDIF
E2   CSR                 ENDIF
     C*
E1   CSR                 ENDDO
     C*
     C*    Remove trailing delimiters from output account by moving
     C*    backwards through the array.  Clear any delimiters
     C*    encountered until a account number characrter (non-blank,
     C*    non-delimiter) is found.  This code was added due to a
     C*    problem with account definitions that rearrange the major
     C*    segments (i.e. OBJ.SUB.CC).
     C*
     CSR                 Z-ADD     $@AN          #O
B1   CSR                 DO        $@AN
     C*
B2   CSR   @AN(#O)       IFNE      *BLANK
     CSR   @AN(#O)       ANDNE     $DEL
     CSR                 LEAVE
X2   CSR                 ELSE
B3   CSR   @AN(#O)       IFEQ      $DEL
     CSR                 CLEAR                   @AN(#O)
E3   CSR                 ENDIF
E2   CSR                 ENDIF
     CSR                 SUB       1             #O
     C*
E1   CSR                 ENDDO
     C*
     C*----------------------------------------------------------------
     C*
     CSR   E0054         ENDSR
     C**************************************************************************
     C**************************************************************************
     C*
     C*     SUBROUTINE S0059 - Create cost center, object, subsidiary
     C*     ---------------------------------------------------------
     C*
     C*  Input
     C*       DSACCT   = Account string without delimiters
     C*       DSANI    = Account string initialized with symbol
     C*                  (includes $ANIA subfield)
     C*
     C*  Output
     C*       P$MCU    = Cost center
     C*       P$OBJ    = Object
     C*       P$SUB    = Subsidiary
     C*
     CSR   S0059         BEGSR
     C*          -----     -----
     C*
     C*----------------------------------------------------------------
     C*
     C*    Create output from input
     C*
B1   CSR   $OEDIT        IFEQ      '1'
     CSR   $IMODE        OREQ      '1'
     CSR   $IMODE        OREQ      '3'
     CSR                 EXSR      S010
     C*                    ---- ----
     CSR                 MOVEL     GMMCU         P$MCU
     CSR                 MOVEL     GMOBJ         P$OBJ
     CSR                 MOVEL     GMSUB         P$SUB
X1   CSR                 ELSE
     CSR                 MOVEL     $MCU          P$MCU
     CSR                 MOVEL     $OBJ          P$OBJ
     CSR                 MOVEL     $SUB          P$SUB
E1   CSR                 ENDIF
     C*
B1   CSR   $OMODE        IFEQ      '8'
     CSR   $FLEX         ANDEQ     '1'
     CSR   GCSEP         ANDNE     *BLANKS
B2   CSR   P$MCU         IFNE      *BLANKS
     C*R                 CALL      'X0006'
     c                   call      'E1I0006'
     C*                    ---- -------
     CSR                 PARM      *BLANK        $1OMOD            1
     CSR                 PARM      '1'           $1IMOD            1
     CSR   P$MCU         PARM      P$MCU         PSMCU            12
     CSR                 PARM      *BLANKS       PSERRM            4
E2   CSR                 ENDIF
B2   CSR   P$OBJ         IFNE      *BLANKS
     C*R                 CALL      'X09011'
     c                   call      'E1I09011'
     C*                    ---- --------
     CSR                 PARM      *BLANK        $2OMOD            1
     CSR                 PARM      '1'           $2IMOD            1
     CSR   P$OBJ         PARM      P$OBJ         PSOBJ             6
     CSR                 PARM      *BLANKS       PSERRM            4
E2   CSR                 ENDIF
B2   CSR   P$SUB         IFNE      *BLANKS
     C*R                 CALL      'X09012'
     c                   call      'E1I09012'
     C*                    ---- --------
     CSR                 PARM      *BLANK        $3OMOD            1
     CSR                 PARM      '1'           $3IMOD            1
     CSR   P$SUB         PARM      P$SUB         PSSUB             8
     CSR                 PARM      *BLANKS       PSERRM            4
E2   CSR                 ENDIF
E1   CSR                 ENDIF
     C*----------------------------------------------------------------
     CSR   E0059         ENDSR
     C**************************************************************************
     C**************************************************************************
     C*
     C*     SUBROUTINE S005A - Invalid Output Mode
     C*     --------------------------------------
     C*
     C*  Input
     C*       DSACCT   = Account string without delimiters
     C*       DSANI    = Account string initialized with symbol
     C*                  (includes $ANIA subfield)
     C*
     C*  Output
     C*       $ANIA    = Account string with delimiters
     C*
     C*
     CSR   S005A         BEGSR
     C*          -----     -----
     C*
     C*    Load error message
     C*
     CSR                 MOVEL     '0028'        PSERR
     C*
     C*    Clear account structure
     C*
     CSR                 CLEAR                   I0901
     C*
     C*    Clear account number
     C*
     CSR                 CLEAR                   $ANIA
     C*----------------------------------------------------------------
     CSR   E005A         ENDSR
     C**************************************************************************
     C**************************************************************************
     C*
     C*     SUBROUTINE S010  - Validate/Translate account
     C*     ---------------------------------------------
     C*
     C*  Input
     C*       DSACCT   = Account string without delimiters
     C*       $IMODE   = Input mode
     C*
     C*  Output
     C*       I0901    = Account master record
     C*       PSERR    = Error code
     C*
     CSR   S010          BEGSR
     C*          ----      -----
     C*
     CSR                 CLEAR                   I0901
     C*----------------------------------------------------------------
     C*
     C*    Skip out of here if account master does not exist
     C*
     CSR   $0901         CABEQ     '1'           E010
     C*                    -----          ----
     C*----------------------------------------------------------------
     C*
     C*    Chain to account master by short id
     C*
B1   CSR   $IMODE        IFEQ      '1'
     CSR                 MOVE      $AID          GMAID
     C*R   GMKYA0        CHAIN     I0901A                             81
     c     GMKYA0        chain     I0901L2                            81             e10901l2
     CSR                 GOTO      T010
     C*                    ---- ----
E1   CSR                 ENDIF
     C*----------------------------------------------------------------
     C*
     C*    Chain to account master by cost center, object, subsidiary
     C*
B1   CSR   $IMODE        IFEQ      '2'
     CSR   $IMODE        OREQ      '8'
     CSR   $IMODE        OREQ      '9'
     CSR                 MOVEL     $MCU          GMMCU
     CSR                 MOVEL     $OBJ          GMOBJ
     CSR                 MOVEL     $SUB          GMSUB
     C*R   GMKYB0        CHAIN     I0901B                             81
     c     GMKYB0        chain     I0901LB                            81
     CSR                 GOTO      T010
     C*                    ---- ----
E1   CSR                 ENDIF
     C*----------------------------------------------------------------
     C*
     C*    Chain to account master by cost center, object, subsidiary
     C*
B1   CSR   $IMODE        IFEQ      '3'
     CSR                 MOVEL     $ANS          GMANS
     C*R   GMKYC0        CHAIN     I0901C                             81
     c     GMKYC0        chain     I0901LC                            81
     CSR                 GOTO      T010
     C*                    ---- ----
E1   CSR                 ENDIF
     C*----------------------------------------------------------------
     C*
     C*    Invalid input mode - unable to chain
     C*
     CSR                 SETON                                        81
     C*----------------------------------------------------------------
     C*
     CSR   T010          TAG
     C*          ----      ---
     C*
     C*    Check for invalid record
     C*
B1   CSR   *IN81         IFEQ      '1'
     C*
     C*    Execute User Exit Program (X0901E) if account is invalid and
     C*    if user exit program exits.
     C*
B2   CSR   $UEXIT        IFEQ      '1'
     C*
B3   CSR   PSEXEC        IFNE      '1'
     C*
     CSR                 CALL      $EXIT
     C*                    ---- -----
     CSR                 PARM                    PSEXEC            1
     CSR                 PARM                    @EM
     CSR                 PARM                    @DI
     CSR                 PARM                    @WN
     CSR                 PARM                    @DA
     CSR                 PARM                    I0901
     C*
     C*    Process errors from user exit
     C*
     CSR                 Z-ADD     1             $UE               2 0
     CSR                 MOVE      *BLANKS       $ERROR            4
     C*
     CSR   @EM($UE)      DOWNE     *BLANKS
     CSR   $UE           ANDLE     10
     CSR                 MOVE      @EM($UE)      $ERROR
     C*
     C*    Move error to error parameter
     C*
B5   CSR   $ERROR        IFNE      *BLANK
     CSR                 MOVE      $ERROR        PSERR
E5   CSR                 ENDIF
     C*
     CSR                 ADD       1             $UE
E4   CSR                 ENDDO
E3   CSR                 ENDIF
X2   CSR                 ELSE
     C*
     CSR                 MOVEL     '0028'        PSERR
E2   CSR                 ENDIF
E1   CSR                 ENDIF
     C*
     C*----------------------------------------------------------------
     CSR   E010          ENDSR
     C**************************************************************************
     C****************************************************************
     C*
     C*    SUBROUTINE S011   - Language Overrides
     C*    --------------------------------------
     C*
     C*    Processing:
     C*                 1.  Determine Alternate Language.
     C*                 2.  Retrieve alternate descriptions and
     C*                     override base descriptions if appropriate.
     C*
     CSR   S011          BEGSR
     C*          ----      -----
     C***************************************************************************
     C*  P16169 DONT GET LANGUAGE PREFERENCE -- CANT USE DTAARA X0028 8/18/20  -COMMENT CODE
     C***************************************************************************
     CSR                 MOVE      *BLANKS       $LNGP             2            P16169
     C*
     C*    Fetch user language preference from F00921
     C*
B1   C*R   ##PARM        IFEQ      10                                                       f
B2   C*R                 SELECT
W2   C*R   PSLNG         WHENEQ    *BLANKS                                                  r
     C*R                 MOVE      #9LNGP        $LNGP             2
W2   C*R   PSLNG         WHENEQ    '**'
     C*R                 MOVE      *BLANKS       $LNGP
W2   C*R                 OTHER
     C*R                 MOVE      PSLNG         $LNGP
E2   C*R                 ENDSL
X1   C*R                 ELSE
     C*R                 MOVE      #9LNGP        $LNGP             2
E1   C*R                 ENDIF
     C*
B1   C*R   $LNGP         IFEQ      *BLANKS
     C*R                 MOVEL     #$LNGP        $LNGP
E1   C*R                 ENDIF
     C*
     C*    If language preference is not blank, try to get an
     C*    alternate description from the F0006D file.
     C*
     C*R                 MOVEL     *BLANKS       LKDL01
     C*R                 MOVEL     GMDL01        $SDL01
     C*
B1   C*R   $LNGP         IFNE      *BLANKS
     C*R   KY901D        CHAIN     I0901D                             9899
     c*    ky901d        chain     I0901DL1                           9899
B2   C*R   LKDL01        IFEQ      *BLANKS
     C*R                 MOVEL     $SDL01        GMDL01
X2   C*R                 ELSE
     C*R                 MOVEL     LKDL01        GMDL01
E2   C*R                 ENDIF
E1   C*R                 ENDIF
     C*
B1   C*R   $OEDIT        IFEQ      '1'
DBN  C*R                 MOVEL     I0901         PS0901
DBN  c*                  movel     i0901         ps0901
E1   C*R                 ENDIF
     C*
     CSR                 CLEAR                   $OEDIT
     C*
     CSR   E011          ENDSR
     C*****************************************************************
     C*****************************************************************
     C*
     C*    Copy Common Subroutine - Scrub numeric value
     C*
     C*/COPY JDECPY,C0012
     C**************************************************************
     C*  This is part of a composite common subroutine. In
     C*  order for the subroutine to work correctly, the
     C*  RPG program must /COPY in the following members:
     C*   E0012, C0012
     C**************************************************************************
    C*    REVISION LOG
    C*    ------------
    C*
    C*          Date     Programmer     Nature of Revision
    C*        --------   ----------  ------------------------------------
    C*        12/11/97   BECK        SAR# 1810110
    C*
     C**************************************************************************
     C*    MAINLINE PROGRAM
     C*    ----------------
     C*
     C*
     C*     SUBROUTINE C0012 - Right Justify Numeric Fields
     C*     -----------------------------------------------
     C*
     C*  PURPOSE
     C*  -------
     C*       To provide a subroutine common to all programs which
     C*       right justifies numeric fields and places the sign over
     C*       the low order byte of the fields, designated by either a
     C*       leading or trailing minus sign.  This routine also ignores
     C*       all non-numeric characters in the input field, and
     C*       determines the placement of the decimal point.
     C*
     C*  REMARKS
     C*  -------
     C*
     C*       Prior to executing this subroutine data from an
     C*       alphanumeric input field should be placed in the array
     C*       named '@NM' with a 'MOVEA' command.  The right justified
     C*       number is available from the subroutine field named
     C*       '#NUMR', which is a 15 digit 6 decimal field.
     C*       CAUTION: The largest number that can be handled
     C*       by this subroutine is 999,999,999.999999.
     C*       However, the input field may contain only 15
     C*       numbers.
     C*
     CSR   C0012         BEGSR
     C*          -----     -----
     C*
     CSR                 Z-ADD     0             #NUMR            29 9
     CSR                 Z-ADD     0             #NUMR2           15 2          Compile only
     CSR                 Z-ADD     0             #NUMR9           15 9          Compile only
     C*
     CSR                 MOVEA     @NM           #ALNUM           22
     CSR   #ALNUM        CABEQ     *BLANKS       EN0012
     CSR                 SETOFF                                       818384
     CSR                 MOVEA     *ALL'0'       @N2
     CSR                 Z-ADD     0             #K1               3 0
     CSR                 Z-ADD     0             #K2               3 0
     CSR                 Z-ADD     0             Q#                3 0
     CSR                 Z-ADD     0             J#                3 0
     CSR                 Z-ADD     0             M#                3 0
     C*
     C*    Retrieve date separation and decimal format characters.
     C*
     CSR   ###1          IFEQ      ' '                                          Do once
     CSR                 MOVE      '1'           ###1              1
     C*R                 CALL      'X00SFMT '                           81
     c                   call      'E1I00SFMT '                         81
     C*                    ---- ----------
     CSR                 PARM      '/'           ###DS             1
     CSR                 PARM      ' '           ###DF             1
     CSR                 MOVE      '.'           ###DC             1
     CSR   ###DF         IFEQ      'J'
     CSR   ###DF         OREQ      'I'
     CSR                 MOVE      ','           ###DC
     CSR                 END
     CSR                 MOVE      ' '           ###EQ             1
     CSR   ###DS         IFEQ      ###DC
     CSR                 MOVE      '1'           ###EQ
     CSR                 END
     CSR                 END
     C*
     C*    If date separator character equals decimal format character,
     C*    Test for multiple decimal point characters and replace with
     C*    US standard date separator character(/).
     C*
     CSR   ###EQ         IFEQ      '1'
     C*
     CSR                 Z-ADD     0             Q#
     CSR                 DO        22            M#
     CSR   @NM(M#)       IFEQ      ###DC
     CSR                 ADD       001           Q#
     CSR                 END
     CSR                 END
     C*
     CSR   Q#            IFGT      1
     CSR                 DO        22            M#
     CSR   @NM(M#)       IFEQ      ###DC
     CSR                 MOVE      '/'           @NM(M#)
     CSR                 END
     CSR                 END
     CSR                 END
     C*
     CSR                 MOVEA     @NM           #ALNUM
     CSR                 END
     C*
     C*    Initialize beginning and ending scan positions.
     C*
     CSR                 Z-ADD     +1            #LOW              3 0
     CSR                 Z-ADD     +22           #HIGH             3 0
     C*
     C*    Find first non-blank character.
     C*
     CSR   ' '           CHECK     #ALNUM        #LOW
     C*
     C*    Find last non-blank character.
     C*
     CSR   ' '           CHECKR    #ALNUM        #HIGH
     C*
     C*    Test minus sign.
     C*    String may be surrounded by quotes... ( dftval from DD )
     C*
     C* &&&      '-'       SCAN #ALNUM                   83
     CSR                 Z-ADD     #LOW          M#
     CSR   @NM(M#)       IFEQ      ''''
     CSR                 ADD       +1            M#
     CSR                 ENDIF
     C*
     CSR   @NM(M#)       COMP      '-'                                    83
     C*
     CSR   *IN83         IFEQ      '0'
     CSR                 Z-ADD     #HIGH         M#
     CSR   @NM(M#)       IFEQ      ''''
     CSR   M#            ANDGT     +1
     CSR                 SUB       1             M#
     CSR                 ENDIF
     C*
     CSR   @NM(M#)       COMP      '-'                                    83
     CSR                 ENDIF
     C*
     C*    Scrub numeric value.
     C*
     CSR                 Z-ADD     #HIGH         M#
     CSR                 Z-ADD     22            Q#
     CSR                 SUB       1             #LOW
     CSR   M#            DOWGT     #LOW
     CSR                 MOVE      @NM(M#)       @NMM#             1
     CSR   @NMM#         IFNE      *BLANKS
     CSR   @NMM#         IFGE      '0'
     CSR   @NMM#         ANDLE     '9'
     CSR   *IN84         IFEQ      '0'
     CSR                 ADD       001           #K1
     CSR                 END
     CSR                 MOVE      @NMM#         @N2(Q#)
     CSR                 SUB       01            Q#
     CSR                 END
     C*
     C*    If decimal point not already found, test for decimal.
     C*
     CSR   *IN84         IFEQ      '0'
     CSR   @NMM#         COMP      ###DC                                  84
     CSR                 END
     C*
     CSR                 END
     CSR                 SUB       001           M#
     CSR                 END
     C*
     C*    Move whole scrubbed number to work field.
     C*
     CSR                 MOVEA     @N2           #ALNUM
     CSR                 MOVE      #ALNUM        #WK29            29 0
     CSR                 Z-ADD     1             #MULTX           11 9
     CSR                 Z-ADD     1             #MULTY           11 9
     C*
     C*    Set up divisor for decimal positions.
     C*
     CSR   *IN84         IFEQ      '1'                                          DECIMAL FND
     CSR   #K1           IFGT      9
     CSR   #K1           SUB       9             #K2
     CSR                 DO        #K2
     CSR                 MULT      .1            #MULTY
     CSR                 END
     CSR                 Z-ADD     9             #K1
     CSR                 END
     CSR                 DO        #K1
     CSR                 MULT      .1            #MULTX
     CSR                 END
     CSR                 ELSE
     CSR                 Z-ADD     0             #K1
     CSR                 Z-ADD     0             #K2
     CSR                 END
     C*
     C*    If negative number, reverse sign on result.
     C*
     CSR   *IN83         IFEQ      '1'
     CSR                 MULT      -1            #WK29
     CSR                 END
     C*
     C*    Position decimal point in result.
     C*
     CSR   #WK29         MULT      #MULTX        #NUMR            29 9
     CSR   #K2           IFGT      0
     CSR                 MULT      #MULTY        #NUMR
     CSR                 END
     C*
     C*    Test for truncation of high value digits.
     C*
     CSR   6             SUB       #K1           M#
     CSR                 ADD       7             M#
     CSR                 Z-ADD     1             Q#
     CSR                 MOVE      ' '           #HV#              1
     CSR   Q#            DOWLE     M#
     CSR   @N2(Q#)       IFGT      '0'
     CSR                 MOVE      '1'           #HV#
     CSR                 Z-ADD     M#            Q#
     CSR                 END
     CSR                 ADD       01            Q#
     CSR                 END
     CSR   #HV#          IFEQ      '1'
     CSR   #WK29         MULT(H)   #MULTX        #NUMR2
     CSR   #K2           IFGT      0
     CSR                 MULT(H)   #MULTY        #NUMR2
     CSR                 END
     CSR                 END
     C*
     C*    Test for truncation of low value digits.
     C*
     CSR                 Z-ADD     0             $NBR3             3 0
     CSR   #K1           IFGT      6
     CSR                 Z-ADD     0             $NBR3
     CSR                 MOVE      #WK29         $NBR1             1 0
     CSR                 MOVE      $NBR1         $NBR3
     CSR                 END
     CSR   #K1           IFGT      7
     CSR                 Z-ADD     0             $NBR3
     CSR                 MOVE      #WK29         $NBR2             2 0
     CSR                 Z-ADD     $NBR2         $NBR3
     CSR                 END
     CSR   #K1           IFGT      8
     CSR                 MOVE      #WK29         $NBR3             3 0
     CSR                 END
     CSR   $NBR3         IFNE      0
     CSR   #WK29         MULT      #MULTX        #NUMR9
     CSR   #K2           IFGT      0
     CSR                 MULT      #MULTY        #NUMR9
     CSR                 END
     CSR                 END
     C*
     CSR                 MOVEA     *BLANK        @NM
     C*
     CSR   EN0012        ENDSR
     C*****************************************************************
     C****************************************************************
     C*
     C*    SUBROUTINE S999   - Initial subroutine
     C*    --------------------------------------
     C*
     C*    Processing:
     C*                 1.  Initialize output parameters.
     C*                 2.  Validate input parameters.
     C*                 3.  Retrieve processing options.
     C*                 4.  Initialize variables.
     C*                      -system date and time
     C*                      -clear warning message array
     C*                      -initialize tax structure
     C*
     CSR   S999          BEGSR
     C*          ----      -----
     C*-----------------------------------------------------------------
     C*
     C*    Entry parameters...
     C*
     CSR   *ENTRY        PLIST
     C*
     C*    1.  Include mode symbol in ANI value
     C*
     CSR                 PARM                    PSSYM             1            include symbol
     C*
     C*    2.  Output mode of entry
     C*
     CSR                 PARM                    PSOMOD            1            output mode
     C*
     C*    3.  Input mode of entry
     C*
     CSR                 PARM                    PSIMOD            1            input mode
     C*
     C*    4.  Display account number
     C*
     CSR                 PARM                    PSANI            29            ANI value
     C*
     C*    5.  Cost center
     C*
     CSR                 PARM                    PSMCU            12            cost center
     C*
     C*    6.  Object
     C*
     CSR                 PARM                    PSOBJ             6            object
     C*
     C*    7.  Subsidiary
     C*
     CSR                 PARM                    PSSUB             8            subsidiary
     C*
     C*    8.  Error flag
     C*
     CSR                 PARM                    PSERR             4            error flag
     C*
     C*    9.  F0901 data structure
     C*
     CSR                 PARM                    PS0901                         F0901 record
     C*
     C*    6.  Language override
     C*
     CSR                 PARM                    PSLNG             2
     C*
     C*-----------------------------------------------------------------
     C*
     C*    Initialize output parameters
     C*
     CSR                 MOVE      *BLANKS       P$MCU
     CSR                 MOVE      *BLANKS       P$OBJ
     CSR                 MOVE      *BLANKS       P$SUB
     CSR                 MOVE      *BLANKS       P$ANI
     C*
     CSR                 MOVE      *BLANKS       PSERR                          error flag
B1   CSR   PSIMOD        IFEQ      '8'
     CSR   PSIMOD        OREQ      '9'
     CSR                 MOVE      PSMCU         P$MCU
     CSR                 MOVE      PSOBJ         P$OBJ
     CSR                 MOVE      PSSUB         P$SUB
     CSR                 MOVE      *BLANKS       PSANI
     CSR                 MOVE      *BLANKS       $SVANI
X1   CSR                 ELSE
     CSR                 MOVE      PSANI         $SVANI
     CSR                 MOVE      PSANI         P$ANI
     CSR                 MOVE      *BLANKS       PSMCU
     CSR                 MOVE      *BLANKS       PSOBJ
     CSR                 MOVE      *BLANKS       PSSUB
E1   CSR                 ENDIF
     C*
     CSR                 MOVE      '0'           $SPCDE            1            speed code used
     C*-----------------------------------------------------------------
     C*
     C*    Validate parameters
     C*
     C*    Return F0901 record value
     C*
B1   CSR   ##PARM        IFGE      9
     CSR                 MOVE      '1'           $OEDIT            1
X1   CSR                 ELSE
     CSR                 MOVE      '0'           $OEDIT
E1   CSR                 ENDIF
     C*
     C*    Output mode
     C*
B1   CSR   PSOMOD        IFNE      '1'
     CSR   PSOMOD        ANDNE     '2'
     CSR   PSOMOD        ANDNE     '3'
     CSR   PSOMOD        ANDNE     '8'
     CSR   PSOMOD        ANDNE     '9'
     CSR   PSOMOD        ANDNE     'I'
     CSR   PSOMOD        ANDNE     'U'
     CSR   PSOMOD        ANDNE     ' '
     CSR   PSOMOD        ANDNE     'A'
     CSR                 MOVEL     '2473'        PSERR
E1   CSR                 ENDIF
     C*
     C*    Input mode
     C*
B1   CSR   PSIMOD        IFNE      '1'
     CSR   PSIMOD        ANDNE     '2'
     CSR   PSIMOD        ANDNE     '3'
     CSR   PSIMOD        ANDNE     '8'
     CSR   PSIMOD        ANDNE     '9'
     CSR   PSIMOD        ANDNE     ' '
     CSR   PSIMOD        ANDNE     'A'
     CSR                 MOVEL     '2472'        PSERR
E1   CSR                 ENDIF
     C*
     C*    Set include symbol flag
     C*
B1   CSR   PSSYM         IFEQ      '1'
     CSR   PSSYM         OREQ      '3'
     CSR                 MOVE      '1'           $INSYM            1
X1   CSR                 ELSE
     CSR                 MOVE      '0'           $INSYM
E1   CSR                 ENDIF
     C*
     C*    Set account duplication flag
     C*
B1   CSR   PSSYM         IFEQ      '2'
     CSR   PSSYM         OREQ      '3'
     CSR                 MOVE      '1'           $DUP              1
X1   CSR                 ELSE
     CSR                 MOVE      '0'           $DUP
E1   CSR                 ENDIF
     C*-----------------------------------------------------------------
     C*
     CSR   E999          ENDSR
     C*****************************************************************
     C*****************************************************************
     C*
     C*    SUBROUTINE S999KL - Key list definitions
     C*    ----------------------------------------
     C*
     CSR   S999KL        BEGSR
     C*
     C*    AAI key list
     C*
     CSR   KGKY00        KLIST
     CSR                 KFLD                    KGITEM
     CSR                 KFLD                    KGCO
     C*
     C*    Flex key list
     C*
     CSR   GYKY02        KLIST
     CSR                 KFLD                    GYRETY
     C*
     C*    Short account key list
     C*
     CSR   GMKYA0        KLIST
     CSR                 KFLD                    $AID
     C*
     C*    Long/Flex account key list
     C*
     CSR   GMKYB0        KLIST
     CSR                 KFLD                    $MCU
     CSR                 KFLD                    $OBJ
     CSR                 KFLD                    $SUB
     C*
     C*    Unstructured account key list
     C*
     CSR   GMKYC0        KLIST
     CSR                 KFLD                    $ANS
     C*
     C*    KLIST for F0901D.
     C*
     CSR   KY901D        KLIST
     CSR                 KFLD                    GMAID
     CSR                 KFLD                    $LNGP
     C*
     CSR   E999KL        ENDSR
     C*****************************************************************
     C*****************************************************************
     C*
     C*    SUBROUTINE S999LK - *LIKE definitions
     C*    -------------------------------------
     C*
     CSR   S999LK        BEGSR
     C*
     C*    Work fields
     C*
     CSR   *LIKE         DEFINE    PSANI         $SVANI
     CSR   *LIKE         DEFINE    PSANI         P$ANI
     CSR   *LIKE         DEFINE    PSMCU         P$MCU
     CSR   *LIKE         DEFINE    PSOBJ         P$OBJ
     CSR   *LIKE         DEFINE    PSSUB         P$SUB
     CSR   *LIKE         DEFINE    I0901         PS0901
     CSR   *LIKE         DEFINE    @PV           $PV
     CSR   *LIKE         DEFINE    GMDL01        $SDL01
     C*
     C*    Save fields for input parameters
     C*
     CSR   *LIKE         DEFINE    PSSYM         $ISYM
     CSR   *LIKE         DEFINE    PSSYM         $IISYM
     CSR   *LIKE         DEFINE    PSIMOD        $IMODE
     CSR   *LIKE         DEFINE    PSIMOD        $IIMOD
     CSR   *LIKE         DEFINE    PSOMOD        $IOMOD
     CSR   *LIKE         DEFINE    PSANI         $IANI
     CSR   *LIKE         DEFINE    PSMCU         $IMCU
     CSR   *LIKE         DEFINE    PSOBJ         $IOBJ
     CSR   *LIKE         DEFINE    PSSUB         $ISUB
     CSR   *LIKE         DEFINE    $OEDIT        $IEDIT
     C*
     C*    Save fields for default values
     C*
     CSR   *LIKE         DEFINE    $MCU          $2MCU
     CSR   *LIKE         DEFINE    $OBJ          $2OBJ
     CSR   *LIKE         DEFINE    $SUB          $2SUB
     CSR   *LIKE         DEFINE    $XBEG         $SVBEG
     C*
     CSR   E999LK        ENDSR
     C*****************************************************************
     C*****************************************************************
     C*
     C*    SUBROUTINE *INZSR - Initial subroutine - first time only
     C*    --------------------------------------------------------
     C*
     C*    Processing:
     C*                 1.  Open database files
     C*                 2.  Retrieve constants
     C*                 3.  Load speed codes array
     C*
     CSR   *INZSR        BEGSR
     C*          ------    -----
     C*-----------------------------------------------------------------
     C*
     C*    Open account master files
     C*
     CSR                 MOVE      '0'           $0901             1
     C*
     C*R                 OPEN      F0901LA                              81
     c**                 open      e10901la                             81
     c                   open      e10901l2                             81
B1   CSR   *IN81         IFEQ      '1'
     CSR                 MOVE      '1'           $0901
E1   CSR                 ENDIF
     C*
     C*R                 OPEN      F0901LB                              81
     c                   open      e10901lb                             81
B1   CSR   *IN81         IFEQ      '1'
     CSR                 MOVE      '1'           $0901
E1   CSR                 ENDIF
     C*
     C*R                 OPEN      F0901LC                              81
     c                   open      e10901lc                             81
B1   CSR   *IN81         IFEQ      '1'
     CSR                 MOVE      '1'           $0901
E1   CSR                 ENDIF
     C*-----------------------------------------------------------------
     C*
     C*    Retrieve General Constants record
     C*
     C*      Returns the following values:
     C*        GCSYMS = symbol for short account
     C*        GCSYML = symbol for long account
     C*        GCSYMU = symbol for 3rd (unstructured) account
     C*        GCSEP  = account separator character
     C*                 (default allows either '.' or ',')
     C*
     C*R                 OPEN      F0009
     c                   open      e10009l1
     C*
     C*R   *BLANKS       CHAIN     I0009                              81
     c     *blanks       chain     i0009l1                            81
     C*
     C*    Close file
     C*
     C*R                 CLOSE     F0009
     c                   close     e10009l1
     C*
     C*-----------------------------------------------------------------
     C*
     C*    Determine if flex is on.
     C*
     CSR                 MOVE      *BLANK        $FLEX             1
     C*R                 CALL      'X0907'                              98
     c                   call      'E1I0907'                            98
     C*                    ---- -------
     CSR                 PARM      *BLANK        PSFLEX            1
     CSR                 PARM      *ZEROS        PSOBJL            2 0
     CSR                 PARM      *ZEROS        PSSUBL            2 0
     C*
     CSR                 Z-ADD     PSOBJL        $MXOBJ            2 0
     CSR                 Z-ADD     PSSUBL        $MXSB             2 0
     C*
B1   CSR   *IN98         IFNE      '1'
     CSR   PSFLEX        ANDEQ     'Y'
     CSR                 MOVEL     '1'           $FLEX
E1   CSR                 ENDIF
     C*-----------------------------------------------------------------
     CSR                 CLEAR                   DSFLEX
     C*
     C*    Load speed coding array with valid speed codes
     C*
     C*R                 OPEN      F0012
     c                   open      e10012l1
     C*
     C*    Speed code arrays
     C*
     CSR                 MOVEA     *BLANK        @SP
     CSR                 MOVEA     *BLANK        @CC
     CSR                 MOVEA     *BLANK        @OB
     CSR                 MOVEA     *BLANK        @SU
     C*
     CSR                 MOVE      *BLANKS       KGITEM
     CSR                 MOVEL     'SP'          KGITEM
     CSR                 MOVE      *ZEROS        KGCO
     CSR                 Z-ADD     *ZERO         #I
     C*R   KGKY00        SETLL     I0012
     c     kgky00        setll     i0012l1
     C*
B1   CSR   *IN81         DOUEQ     '1'
     CSR   #I            OREQ      50
     C*R                 READ      I0012                                  81
     c                   read      I0012l1                                81
B2   CSR   *IN81         IFEQ      '0'
DBN  CSR                 MOVEL     KGITEM        $WRK2             2
B3   CSR   $WRK2         IFNE      'SP'
     CSR                 SETON                                          81
E3   CSR                 ENDIF
B3   CSR   *IN81         IFEQ      '0'
     CSR   1             SUBST     KGITEM:3      $WRK1             1
B4   CSR   $WRK1         IFNE      *BLANKS
     CSR                 ADD       1             #I
     CSR                 MOVEL     $WRK1         @SP(#I)
     CSR                 MOVEL     KGMCU         @CC(#I)
     CSR                 MOVEL     KGOBJ         @OB(#I)
     CSR                 MOVEL     KGSUB         @SU(#I)
E4   CSR                 ENDIF
E3   CSR                 ENDIF
E2   CSR                 ENDIF
E1   CSR                 ENDDO
     C*
     C*    Save total number of speed codes
     C*
     CSR                 Z-ADD     #I            $MAXSP            5 0
     C*
     C*    Close AAI file
     C*
     C*R                 CLOSE     F0012
     c                   close     e10012l1
     C*-----------------------------------------------------------------
     C*
     C*    Load account parts array for flex account
     C*
B1   CSR   $FLEX         IFEQ      '1'
     C*
     C*    If flex file does not exist, set off flex
     C*
     C*R                 OPEN      F0907LA                              81
     c                   OPEN      E10907la                             81
B2   CSR   *IN81         IFEQ      '1'
     CSR                 MOVEL     *BLANK        $FLEX
X2   CSR                 ELSE
     C*
     C*    Initialize flex account parts
     C*
     CSR                 CLEAR                   DSFLEX
     CSR                 Z-ADD     *ZERO         $XPART            5 0          part number
     CSR                 Z-ADD     *ZERO         $XACCT            5 0          first account
     CSR                 Z-ADD     *ZERO         $XCLEN            5 0          cost ctr length
     CSR                 Z-ADD     *ZERO         $XALEN            5 0          account length
     CSR                 Z-ADD     *ZERO         $XCPRT            5 0          cost ctr parts
     CSR                 Z-ADD     *ZERO         $XAPRT            5 0          account parts
     CSR                 Z-ADD     1             #X                             begin position
     C*
     C*    Load account parts array for flex account
     C*
     CSR                 Z-ADD     1             GYRETY
     C*R   GYKY02        SETLL     I0907
     c     gyky02        setll     I0907la
B3   CSR   *IN81         DOUEQ     '1'
     C*R   GYKY02        READE     I0907                                  81
     c     gyky02        reade     I0907la                                81
B4   CSR   *IN81         IFEQ      '0'
     C*
     C*    Load account part
     C*
     CSR                 ADD       1             $XPART                         part number
     CSR   $XPART        OCCUR     DSFLEX
B5   CSR   GYSBTY        IFEQ      1
     CSR                 Z-ADD     1             $XTYPE
X5   CSR                 ELSE
B6   CSR   GYSBTY        IFEQ      2
     CSR                 Z-ADD     2             $XTYPE
X6   CSR                 ELSE
B7   CSR   GYSBTY        IFGE      3
     CSR                 Z-ADD     3             $XTYPE
X7   CSR                 ELSE
     CSR                 Z-ADD     *ZERO         $XTYPE
E7   CSR                 ENDIF
E6   CSR                 ENDIF
E5   CSR                 ENDIF
     C*
     C*    Positions and length
     C*
     CSR                 Z-ADD     #X            $XBEG                          begin position
     C*R                 Z-ADD     GYELL         $XLEN                          length
     C                   Z-ADD     GYELL1        $XLEN                          length
     CSR                 ADD       $XLEN         #X                             next position
     CSR   #X            SUB       1             $XEND                          end position
     CSR                 Z-ADD     *ZERO         $XLONG                         long xref   on
     C*
     C*    Attributes
     C*
     CSR                 MOVE      GYELTY        $XNUM                          numeric (A/N)
     CSR                 MOVE      GYLR          $XLR                           justify L/R
B5   CSR   GYSBTY        IFEQ      1
     CSR   GYDTAI        ANDEQ     'MCU'
     CSR                 MOVEL     'R'           $XLR
E5   CSR                 ENDIF
     C*
     C*    Accumulate number and length of cost center parts
     C*
B5   CSR   GYSBTY        IFEQ      1
     CSR                 ADD       1             $XCPRT                         cost ctr parts
     C*R                 ADD       GYELL         $XCLEN                         cost ctr length
     C                   ADD       GYELL1        $XCLEN                         cost ctr length
X5   CSR                 ELSE
     CSR                 Z-ADD     $XCLEN        $XCCL                          preced cc leng
     CSR                 Z-ADD     $XCPRT        $XCCP                          # preced cc pts
     CSR                 ADD       1             $XAPRT                         account parts
     C*R                 ADD       GYELL         $XALEN
     C                   ADD       GYELL1        $XALEN
E5   CSR                 ENDIF
     C*
     C*    Save first account part
     C*
B5   CSR   GYSBTY        IFNE      1
     CSR   $XACCT        ANDEQ     *ZERO
     CSR                 Z-ADD     $XPART        $XACCT
E5   CSR                 ENDIF
     C*
     C*
E4   CSR                 ENDIF
E3   CSR                 ENDDO
     C*----------------------------------------------------------------
     C*
     C*    Close Flex Chart file
     C*
     C*R                 CLOSE     F0907LA
     c                   close     E10907la
     C*
     C*    If no cost center parts or no account parts are defined,
     C*    set flex off
     C*
B3   CSR   $XCPRT        IFEQ      0                                                        ts
     CSR   $XAPRT        OREQ      0
     CSR                 MOVEL     *BLANK        $FLEX
E3   CSR                 ENDIF
     C*
E2   CSR                 ENDIF
E1   CSR                 ENDIF
     C*-----------------------------------------------------------------
     C*
     C*    Load account parts array for long account
     C*
B1   CSR   $FLEX         IFEQ      '1'
     C*
     CSR                 Z-ADD     1             #W
     CSR                 Z-ADD     1             $STYPE            1 0
     C*
B2   CSR   1             DO        $XPART        #H
     CSR                 Z-ADD     *ZERO         #J
     CSR                 MOVEL     '0'           $FOUND            1
     C*
     C*    Access DSFLEX in cc.obj.sub order
     C*
B3   CSR   $FOUND        DOWNE     '1'
     CSR                 ADD       1             #J
     CSR   #J            OCCUR     DSFLEX
     C*
B4   CSR   $XTYPE        IFEQ      $STYPE
     CSR   $XLONG        ANDEQ     *ZERO
     CSR                 MOVEL     '1'           $FOUND
X4   CSR                 ELSE
B5   CSR   #J            IFEQ      $XPART
     CSR                 Z-ADD     *ZERO         #J
     CSR                 ADD       1             $STYPE
E5   CSR                 ENDIF
E4   CSR                 ENDIF
E3   CSR                 ENDDO
     C*
     C*    Cross reference DSFLEX to DSLONG
     C*
     CSR                 Z-ADD     #H            $XLONG
     C*
     C*    Copy duplicate DSFLEX fields to DSLONG
     C*
     CSR   #H            OCCUR     DSLONG
     CSR                 Z-ADD     $XTYPE        $LTYPE
     CSR                 Z-ADD     $XLEN         $LLEN
     CSR                 MOVEL     $XNUM         $LNUM
     CSR                 MOVEL     $XLR          $LLR
     C*
     C*    Cross reference DSFLEX to DSLONG
     C*
     CSR                 Z-ADD     #J            $LFLEX
     C*
     C*    Build DSLONG begin and end positions
     C*
B3   CSR   $LTYPE        IFEQ      2
     CSR   #W            ANDLT     13
     CSR                 Z-ADD     13            #W
E3   CSR                 ENDIF
     C*
B3   CSR   $LTYPE        IFEQ      3
     CSR   #W            ANDLT     19
     CSR   19            SUB       #W            #I
     CSR                 ADD       #I            $XALEN
     CSR                 Z-ADD     19            #W
E3   CSR                 ENDIF
     C******************************************************************
     CSR                 Z-ADD     #W            $LBEG
     CSR                 ADD       $LLEN         #W
     CSR   #W            SUB       1             $LEND
     C*
E2   CSR                 ENDDO                                                              er
     C*
     C*    Recalculate cost center begin/end positions
     C*
B2   CSR   $XCLEN        IFLT      $MXMCU
     CSR   $MXMCU        SUB       $XCLEN        #I
B3   CSR   1             DO        $XCPRT        #X
     CSR   #X            OCCUR     DSLONG
     CSR                 ADD       #I            $LBEG
     CSR                 ADD       #I            $LEND
E3   CSR                 ENDDO                                                              er
E2   CSR                 ENDIF                                                              er
     C*
E1   CSR                 ENDIF                                                              er
     C*----------------------------------------------------------------
     C*
     C***************************************************************************
     C*  P16169 DONT GET LANGUAGE PREFERENCE -- CANT USE DTAARA X0028 8/18/20
     C***************************************************************************
     C*    Fetch user language preference from F00921 this will be stored in #9L
     C*
     C*R                 CLEAR                   D00921
     C*R                 CALL      'X00921'
     c*                  call      'E1I00921'
     C*                    ---- --------
     C*R                 PARM                    D00921
     C*
     C*    Fetch language preference from QJDF this will be stored in #$LNGP
     C*
     C*R                 CALL      'X00QJDF'
     c*                  call      'E1I00QJDF'
     C*                    ---- ---------
     C*R                 PARM                    QJDF
     C***************************************************************************
     C*-----------------------------------------------------------------
     C*
     C*    Scrub numeric value
     C*
     C*R                 CALL      'J98CPGM'
     C*                    ---- ---------
     C*R                 PARM      'X0901'       PSSEND           10
     C*R                 PARM                    PSCALL           10
      *
     c                   call      'E1I98CPGM'
     C*                    ---- ---------
     c                   parm      'E1I0901'     pssend           10
     c                   parm                    pscall           10
     C*
     C*-----------------------------------------------------------------
     C***************************************************************************
     C*  P16169 DONT GET LANGUAGE PREFERENCE -- CANT USE DTAARA X0028 8/18/20
     C***************************************************************************
     C*    Open Account Master - Alternate Description
     C*
B1   C*R   #9LNGP        IFNE      *BLANKS
     C*R                 OPEN      F0901D                               81
     c*                  open      E10901D1                             81
     C*
B2   C*R   *IN81         IFEQ      '1'
     C*R   $RCNT         OREQ      *ZEROS
     C*R                 MOVE      *BLANKS       $LNGP
E2   C*R                 ENDIF
E1   C*R                 ENDIF
     C*-----------------------------------------------------------------
     C*
     C*    Check if User Exit Program Exists.
     C*
     C*R                 CALL      'J98CHKOB'                           98
     c                   call      'E1I98CHKOB'                         98
     C*                    ---- ----------
     CSR                 PARM                    $EXIT            10
     CSR                 PARM      '*LIBL'       $#LIB            10
     CSR                 PARM      '*PGM '       $#TYPE            8
     CSR                 PARM      *BLANK        $#MBR            10
     CSR                 PARM      *BLANK        $#AUT            10
     CSR                 PARM      *BLANK        $ERTST            1
     C*
B1   CSR   $ERTST        IFEQ      *BLANK
     CSR   *IN98         ANDEQ     '0'
     CSR                 MOVE      '1'           $UEXIT            1
X1   CSR                 ELSE
     CSR                 MOVE      '0'           $UEXIT
E1   CSR                 ENDIF
     C*----------------------------------------------------------------
     C*
     CSR   EINZSR        ENDSR
     C*****************************************************************
