     h option(*SRCSTMT:*NODEBUGIO)
      *
      * SYSTEM:      OMS Development Model
      * PROGRAM:     PBJ8PVR
      * TITLE:       Prt Whse Aged Inventry PV Prompt & validate record
      * PROGRAMMER:  LeAnne Ramsey
      * CREATED:     09/17/13
      *
      * FUNCTION: This Specify uses an edit record format to allow the user
      *           to specify options for generating the report.
      *
      ****************************************************************
      * MODIFICATIONS:
      ****************************************************************
      * DATE      PROGRAMMER
      *
      * 12/12/13  LeAnne Ramsey (E2937)
      *           Added an additional selection for Dewey W. Now, he can
      *           elect to only print Items that have an Available Quantity to
      *           Sell. The new field is D1YN.
      *
      * 01/21/14  LeAnne Ramsey (E2981)
      *           Added an additional selection for Dewey W. Now, he can
      *           elect to only print a Summary Page. The new field is D1SUMYN.
      /EJECT
      ****************************************************************
      * FILE SPECIFICATIONS
      ****************************************************************
      *
     Fpbj8pvr#  cf   e             workstn infds(iofeed)
      *
      *
     Fcaadrel1  if   e           k disk
      *    Warehouse
      *
      *
     Fombyrel1  if   e           k disk
      *    Item default
      *
      *
     Fpdjzrel2  if   e           k disk
      *    Warehouse type
      *
      /EJECT
      ****************************************************************
      * DEFINITION SPECIFICATIONS
      ****************************************************************
      *
      ****************************************************************
      * CONSTANTS
      ****************************************************************
      *
     D yes             c                   'Y'
     D no              c                   'N'
     D set1            c                   'SET1  '
     D edit1           c                   'EDIT1 '
     D scrn1           c                   'SCRN1 '
     D exit            c                   'EXIT  '
      *
      ****************************************************************
      * ARRAYS AND TABLES
      ****************************************************************
      *
     D arwhcd          s              3    dim(6)
     D arwhds          s             30    dim(6)
      *
      *---------------------------------------------------------------
      *  Compile time array for SBMJOB used in QCMDEXC
      *---------------------------------------------------------------
     D cmd1            s              1    dim(80) ctdata perrcd(80)
     D cmd2            s              1    dim(80) ctdata perrcd(80)
      *
      ****************************************************************
      * STANDALONE FIELDS
      ****************************************************************
      *
      * Standard fields
      *
     D pgm             s             10
     D msgfl           s             10
     D routne          s              6
     D maxmsg          s              2  0  inz(20)
      *
      * Workfields
      *
     D wkokfl          s              1
     D wkwhcd          s                   like(d1whcd1)
     D wkwhds          s                   like(d1whds1)
      *
      * Workfields for Date Manipulation
      *
     D wkiso           s               d   datfmt(*iso)
     D wksysdt         s              7  0
      *
      * Parm fields
      *
     D xxreturn        s              7
     D xxwhtycd        s                   like(d1whtycd)
     D xxitcd          s                   like(d1fitcd)
     D xxwhcd          s                   like(d1whcd1)
      *
      * Parms for the call to the Synon Pop-up Window for Printing
     D xxdesc          s             25    inz('Aged Inventory by Warehse')
     D xxprinter       s             10
     D xxhold          s              4    inz('*NO ')
     D xxsave          s              4    inz('*NO ')
     D xxcopies        s              2  0 inz(1)
     D xxniteynfl      s              1    inz('N')
     D xxniteque       s             10    inz('GUYNIGHTQ')
     D xxappcode       s              6    inz('OMS')
      *
      *  Parms for use with QCMDEXC.  'LENGTH' is the length of the
      *  command that will be issued with QCMDEXC.  QCMDEXC requires
      *  the field containing length to be defined as 15 with 5 decimal
      *  positions.  The field 'CMDSBM' will hold the values of the
      *  submit job command when passed as a parm on the call to
      *  QCMDEXC.
      *
     D length          s             15  5 inz(80)
     D cmdsbm          s             80
      *
      * Array indexes
      *
     D x               s              3  0
     D y               s              3  0
      *
      ****************************************************************
      * DATA STRUCTURES
      ****************************************************************
      *
      *---------------------------------------------------------------
      * standard error message handling data structures
      *---------------------------------------------------------------
      *
      * For error message handling, a packed index (3) is required.
      * For program readability, define a corresponding error count
      * field called 'error'
      *
     D                 ds                  inz
     D  error                         2p 0
     D   e                            2p 0 overlay(error)
      *
      * This data structure supplies the name of the message file to
      * the message handling CL program.  The field name MSGFIL must be
      * constant. The value in quotes is the name of the specific
      * message file containing the user defined messages.
      *
     D                 ds                  inz
     D  msgfil                       10    inz('QUSRMSG   ')
      *
      *---------------------------------------------------------------
      *  Standard message data structures
      *---------------------------------------------------------------
      *
      * The following 3 data structures are used to speed message
      * handling since it is faster to clear data structures than
      * arrays.  Each is associated with a standard message array.
      *
     D mgi             ds                  inz
     D  mgid                          7    dim(20)
      *
     D mgd             ds                  inz
     D  mgdt                         50    dim(20)
      *
     D mgwk            ds                  inz
     D  mgw                           1    dim(50)
      *
      *
      *---------------------------------------------------------------
      * Standard program status data structure
      *---------------------------------------------------------------
      *    externally defined as UTPGFR (record format: PGMDSR)
     D pgmds         esds                  extname(utpgfr)
      *
      *
      *---------------------------------------------------------------
      * Standard workstation information data structure
      *---------------------------------------------------------------
      *    externally defined as UTWSFR (record format: UTIDFRR)
     D iofeed        e ds                  extname(utwsfr)
      *
      *
      *---------------------------------------------------------------
      * Standard database file information data structure
      *---------------------------------------------------------------
      *    externally defined as UTDBGR (record format: FDBCKD)
     D dbfeed        e ds                  extname(utdbfr)
      *
      *
      *---------------------------------------------------------------
      * Data areas
      *---------------------------------------------------------------
      *
     Dlda             uds                  dtaara(*lda)
      *
     d  ldwhtycd               1      2
     D  ldfmdy                 3      8  0
     D  ldtmdy                 9     14  0
     D  ldfcymd               15     21  0
     D  ldtcymd               22     28  0
     D  ldage                 29     31  0
     D  ldfitcd               32     38  0
     D  ldfitds               39     68
      *
     D  ldsofl                69     69
      *
     D  ldwhcd1               70     72
     D  ldwhds1               73    102
      *
     D  ldwhcd2              103    105
     D  ldwhds2              106    135
      *
     D  ldwhcd3              136    138
     D  ldwhds3              139    168
      *
     D  ldwhcd4              169    171
     D  ldwhds4              172    201
      *
     D  ldwhcd5              202    204
     D  ldwhds5              205    234
      *
     D  ldwhcd6              235    237
     D  ldwhds6              238    267
      *
     D  ldtitcd              268    274  0
     D  ldtitds              275    304
      *
     D  ldyn                 305    305
     D  ldsumyn              306    306
      *
     D  ldoutq               401    410
     D  ldhold               411    414
     D  ldsave               415    418
     D  ldcopy               419    419  0
      *
      *
      * The following is a dummy C-spec to keep the D-specs from
      * running over into the C-specs on the compile listing. It
      * serves no other purpose and can be deleted at any time.
      *
     C                   if        sdpgm = *blank
     C                   endif
      /EJECT
      ****************************************************************
      * MAINLINE
      ****************************************************************
     C
     C                   eval      routne = set1
      *
     C     *inlr         doweq     *off
     C     routne        caseq     set1          $set1
     C     routne        caseq     scrn1         $scrn1
     C     routne        caseq     edit1         $edit1
     C     routne        caseq     exit          $exit
     C                   endcs
     C                   enddo
      /EJECT
      *----------------------------------------------------------------
      * Set environment for screen 1
      *----------------------------------------------------------------
      *
     C     $set1         begsr
      *
     C                   eval      routne = scrn1
      *
     C                   endsr
      /EJECT
      *----------------------------------------------------------------
      * Perform operator I/O for screen 1
      *----------------------------------------------------------------
      *
     C     $scrn1        begsr
      *
      * Write the error messages from the error arrays to the error
      * message subfile
      *
     C                   exsr      $wrmsg
      *
      * Write screen 1 to CRT.
      *
     C                   write     pbj8pk1
     C                   write     pbj8pec
     C                   exfmt     pbj8pr1
      *
      * Clear the messages from the message data structures and
      * program message queue
      *
     C                   exsr      $clmsg
      *
      * Get user's entry and set next routine
      *
     C                   select
     C                   when      *in03 = *on
     C                   eval      routne = exit
      *
     C                   when      *in04 = *on
     C                   exsr      $f4s1
     C                   other
      *
     C                   eval      routne = edit1
     C                   endsl
      *
     C                   endsr
      /EJECT
      *----------------------------------------------------------------
      * Edit screen 1 input fields
      *----------------------------------------------------------------
      *
     C     $edit1        begsr
      *
      * Validate:
      *   1) warehouse type
      *   2) from date
      *   3) to date
      *   4) aging days
      *   5) only print Items that have an Available Quantity to Sell
      *   6) only print Summary Page
      *   7) select/omit warehouses flag
      *   8) warehouses
      *   9) from item code
      *  10) to item code
      *
     C                   exsr      $whtycd
     C                   exsr      $fmdy
     C                   exsr      $tmdy
     C                   exsr      $age
     C                   exsr      $sellqty
     C                   exsr      $sumpage
     C                   exsr      $sofl
     C                   exsr      $whcd
     C                   exsr      $fitcd
     C                   exsr      $titcd
      *
      * If there are no errors, call the Synon Pop-up Print Program
      *
     C                   if        error = 0
     C                   exsr      $print
     C                   endif
      *
     C                   eval      routne = scrn1
      *
     C                   endsr
      /EJECT
      *----------------------------------------------------------------
      * Validate Warehouse Type
      *----------------------------------------------------------------
      *
      * Validations:
      *  1) required
      *  2) must be FR=Fresh or FZ=Frozen
      *
     C     $whtycd       begsr
      *
     C                   select
     C                   when      d1whtycd = 'FR' or d1whtycd = 'FZ'
      *
     C                   when      d1whtycd = *blank
     C                   seton                                        30
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'USR4651'
     C                   endif
     C                   other
      *
     C                   seton                                        30
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'USR4651'
     C                   endif
     C                   endsl
      *
     C                   endsr
      /EJECT
      *----------------------------------------------------------------
      * Validate From Date
      *----------------------------------------------------------------
      *
      * Validations:
      *  1) required
      *  2) must be a valid date
      *
      *
     C     $fmdy         begsr
      *
     C                   z-add     0             ldfcymd
      *
     C                   select
     C                   when      d1fmdy = 0
     C                   other
      *
     C                   if        d1fmdy < 0
     C                   eval      d1fmdy = d1fmdy * -1
     C                   endif
      *
     C     *mdy          test(d)                 d1fmdy                 92
     C                   if        *in92 = *on                                  If bad date
     C                   seton                                        37
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'USR4268'
     C                   endif
     C                   else
      *
      * Flip the date from MMDDYY to CYYMMDD
      *
     C     *mdy          move      d1fmdy        wkiso
     C     *cymd         move      wkiso         ldfcymd
     C                   endif                                                  If bad date
     C                   endsl
      *
     C                   endsr
      /EJECT
      *----------------------------------------------------------------
      * Validate to date
      *----------------------------------------------------------------
      *
      *  1) required
      *  2) must be a valid date
      *  3) must be on/after From Date
      *
      *
     C     $tmdy         begsr
      *
     C                   z-add     0             ldtcymd
      *
     C                   select
     C                   when      d1tmdy = 0
     C                   seton                                        38
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'USR0231'
     C                   endif
     C                   other
      *
     C                   if        d1tmdy < 0
     C                   eval      d1tmdy = d1tmdy * -1
     C                   endif
      *
     C     *mdy          test(d)                 d1tmdy                 92
     C                   if        *in92 = *on                                  If bad date
     C                   seton                                        38
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'USR4268'
     C                   endif
     C                   else
      *
      * Flip the date from MMDDYY to CYYMMDD
      *
     C     *mdy          move      d1tmdy        wkiso
     C     *cymd         move      wkiso         ldtcymd
     C                   endif                                                  If bad date
     C                   endsl
      *
      * To date cannot be earlier than from date.
      *
     C                   if        *in37 = *off and
     C                             *in36 = *off and
     C                             ldtcymd < ldfcymd
     C                   seton                                        38
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'USR2719'
     C                   endif
     C                   endif
      *
      * Date cannot be greater than system date.
      *
     C                   if        *in37 = *off and
     C                             *in36 = *off and
     C                             ldtcymd > wksysdt
     C                   seton                                        38
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'USR4647'
     C                   endif
     C                   endif
      *
     C                   endsr
      /eject
      *----------------------------------------------------------------
      * Validate Aging Days
      *----------------------------------------------------------------
      *  1) must be greater than zero
      *
     C     $age          begsr
      *
     C                   if        d1age <= 0
     C                   seton                                        41
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'USR4648'
     C                   endif
     C                   endif
      *
     C                   endsr
      /eject
      *-------------------------------------------------------------------------------------
      * Validate Yes/No answer to "Only print Items that have an Available-to-Sell Quantity
      *-------------------------------------------------------------------------------------
      *  1) must be Yes/No
      *
     C     $sellqty      begsr
      *
     C                   if        d1yn = yes or d1yn = no
     C                   else
     C                   seton                                        42
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'USR4675'
     C                   endif
     C                   endif
      *
     C                   endsr
      /eject
      *-------------------------------------------------------------------------------------
      * Validate Yes/No answer to "Only print Summary Page"
      *-------------------------------------------------------------------------------------
      *  1) must be Yes/No
      *
     C     $sumpage      begsr
      *
     C                   if        d1sumyn = yes or d1sumyn = no
     C                   else
     C                   seton                                        44
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'USR4675'
     C                   endif
     C                   endif
      *
     C                   endsr
      /eject
      *----------------------------------------------------------------
      * Validate Select/Omit Warehouses
      *----------------------------------------------------------------
      *  1) optional
      *  2) must be S=Select or O=Omit if entered
      *
     C     $sofl         begsr
      *
     C                   select
     C                   when      d1sofl = *blank or
     C                             d1sofl = 'S' or
     C                             d1sofl = 'O'
     C                   other
     C                   seton                                        40
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'USR4652'
     C                   endif
     C                   endsl
      *
     C                   endsr
      /eject
      *----------------------------------------------------------------
      * Validate 6 Warehouse Codes
      *----------------------------------------------------------------
      *  1) optional
      *  2) warehouse type must match user's selected Warehouse Type
      *  3) must have at least 1 warehouse if Select/Omit is not blank
      *
     C     $whcd         begsr
      *
     C                   move      *blank        d1whds1
     C                   move      *blank        d1whds2
     C                   move      *blank        d1whds3
     C                   move      *blank        d1whds4
     C                   move      *blank        d1whds5
     C                   move      *blank        d1whds6
     C                   move      *blank        arwhcd
     C                   move      *blank        arwhds
     C                   z-add     0             x
     C                   z-add     0             y
      *
      * At least 1 warehouse must be entered if the user has enterd a value
      * for the Select/Omit Warehouses flag.
      *
     C                   select
     C                   when      d1sofl = *blank
      *
     C                   when      d1sofl <> *blank and
     C                             d1whcd1 = *blank and
     C                             d1whcd2 = *blank and
     C                             d1whcd3 = *blank and
     C                             d1whcd4 = *blank and
     C                             d1whcd5 = *blank and
     C                             d1whcd6 = *blank
     C                   seton                                        31
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'USR4650'
     C                   endif
     C                   other
      *
      * Warehouse 1
     C                   if        d1whcd1 <> *blank
     C                   move      d1whcd1       wkwhcd
     C                   exsr      $valwhcd
     C                   move      wkwhds        d1whds1
     C                   if        wkokfl = no
     C                   seton                                        31
     C                   endif
     C                   endif
      * Warehouse 2
     C                   if        d1whcd2 <> *blank
     C                   move      d1whcd2       wkwhcd
     C                   exsr      $valwhcd
     C                   move      wkwhds        d1whds2
     C                   if        wkokfl = no
     C                   seton                                        32
     C                   endif
     C                   endif
      * Warehouse 3
     C                   if        d1whcd3 <> *blank
     C                   move      d1whcd3       wkwhcd
     C                   exsr      $valwhcd
     C                   move      wkwhds        d1whds3
     C                   if        wkokfl = no
     C                   seton                                        33
     C                   endif
     C                   endif
      * Warehouse 4
     C                   if        d1whcd4 <> *blank
     C                   move      d1whcd4       wkwhcd
     C                   exsr      $valwhcd
     C                   move      wkwhds        d1whds4
     C                   if        wkokfl = no
     C                   seton                                        34
     C                   endif
     C                   endif
      * Warehouse 5
     C                   if        d1whcd5 <> *blank
     C                   move      d1whcd5       wkwhcd
     C                   exsr      $valwhcd
     C                   move      wkwhds        d1whds5
     C                   if        wkokfl = no
     C                   seton                                        35
     C                   endif
     C                   endif
      * Warehouse 6
     C                   if        d1whcd6 <> *blank
     C                   move      d1whcd6       wkwhcd
     C                   exsr      $valwhcd
     C                   move      wkwhds        d1whds6
     C                   if        wkokfl = no
     C                   seton                                        36
     C                   endif
     C                   endif
     C                   endsl
      *
     C                   endsr
      /eject
      *---------------------------------------------------------------
      * Validate Warehouse Code
      *---------------------------------------------------------------
      * Optional, if entered:
      *   1) must be active warehouse
      *   2) must have a Type that matches user's selected Warehouse Type
      *   3) cannot already be in the user's list
      *
     C     $valwhcd      begsr
      *
     C                   move      *blank        wkwhds
     C                   move      yes           wkokfl
      *
     C     wkwhcd        chain     caadrel1                           92
     C                   select
     C                   when      *in92 = *on
     C                   move      no            wkokfl
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'USR0007'
     C                   endif
     C                   other
      *
     C                   eval      wkwhds = adf8na
      *
     C                   if        advsst = 'I'
     C                   move      no            wkokfl
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'USR4655'
     C                   clear                   mgw
     C                   movea     adajcd        mgw(1)
     C                   movea     d1whtycd      mgw(4)
     C                   movea     mgw           mgdt(e)
     C                   endif
     C                   endif
      *
     C                   if        *in30 = *off and adwpst <> d1whtycd
     C                   move      no            wkokfl
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'USR2494'
     C                   clear                   mgw
     C                   movea     adajcd        mgw(1)
     C                   movea     d1whtycd      mgw(4)
     C                   movea     mgw           mgdt(e)
     C                   endif
     C                   endif
      *
     C                   z-add     1             x
     C     adajcd        lookup    arwhcd(x)                              92
     C                   if        *in92 = *off                                 If not there
     C                   add       1             y
     C                   move      adajcd        arwhcd(y)
     C                   move      wkwhds        arwhds(y)
     C                   else
     C                   move      no            wkokfl
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'USR4656'
     C                   clear                   mgw
     C                   movea     adajcd        mgw(1)
     C                   movea     mgw           mgdt(e)
     C                   endif
     C                   endif                                                  If not there
     C                   endsl
      *
     C                   endsr
      /eject
      *----------------------------------------------------------------
      * Validate From Item Code
      *----------------------------------------------------------------
      *  1) optional
      *  2) must be valid in the Item Default file
      *  3) user must enter both From/To Items if he enters either
      *
     C     $fitcd        begsr
      *
     C                   move      *blank        d1fitds
      *
     C                   if        d1fitcd < 0
     C                   eval      d1fitcd = d1fitcd * -1
     C                   endif
      *
     C                   select
     C                   when      d1fitcd = 0 and d1titcd = 0
      *
     C                   when      d1titcd <> 0 and d1fitcd = 0
     C                   seton                                        39
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'USR4658'
     C                   endif
     C                   other
      *
     C     d1fitcd       chain     ombyrel1                           92
     C                   if        *in92 = *on
     C                   seton                                        39
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'USR2800'
     C                   endif
     C                   else
     C                   eval      d1fitds = byavna
     C                   endif
     C                   endsl
      *
     C                   endsr
      /eject
      *----------------------------------------------------------------
      * Validate To Item Code
      *----------------------------------------------------------------
      *  1) optional
      *  2) must be valid in the Item Default file
      *  3) user must enter both From/To Items if he enters either
      *
     C     $titcd        begsr
      *
     C                   move      *blank        d1titds
      *
     C                   if        d1titcd < 0
     C                   eval      d1titcd = d1titcd * -1
     C                   endif
      *
     C                   select
     C                   when      d1fitcd = 0 and d1titcd = 0
      *
     C                   when      d1fitcd <> 0 and d1titcd = 0
     C                   seton                                        48
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'USR4659'
     C                   endif
     C                   other
      *
     C     d1titcd       chain     ombyrel1                           92
     C                   if        *in92 = *on
     C                   seton                                        48
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'USR2800'
     C                   endif
     C                   else
     C                   eval      d1titds = byavna
      *
     C                   if        d1titcd < d1fitcd and *in39 = *off
     C                   seton                                        48
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'USR4660'
     C                   endif
     C                   endif
      *
     C                   endif
     C                   endsl
      *
     C                   endsr
      /eject
      *----------------------------------------------------------------
      * F4 prompt on screen 1
      *----------------------------------------------------------------
      *
     C     $f4s1         begsr
      *
      * Warehouse Type
     C                   select
     C                   when      fld = 'D1WHTYCD'
     C                   seton                                        50
     C                   exfmt     popup1
     C                   select
     C                   when      p1whtycd = 1
     C                   eval      d1whtycd = 'FR'
     C                   when      p1whtycd = 2
     C                   eval      d1whtycd = 'FZ'
     C                   endsl
      *
      * Select/Omit Warehouses
     C                   when      fld = 'D1SOFL'
     C                   seton                                        60
     C                   exfmt     popup2
     C                   select
     C                   when      p2sofl = 1
     C                   eval      d1sofl = 'S'
     C                   when      p2sofl = 2
     C                   eval      d1sofl = 'O'
     C                   when      p2sofl = 3
     C                   eval      d1sofl = ' '
     C                   endsl
      *
      * Warehouse 1
     C                   when      fld = 'D1WHCD1'
     C                   call      'PDZNSRR'
     C                   parm      *blank        xxreturn
     C                   parm      *blank        xxwhcd
     C                   parm      d1whtycd      xxwhtycd
     C                   seton                                        51
     C                   if        xxwhcd <> *blank
     C                   move      xxwhcd        d1whcd1
     C                   move      d1whcd1       wkwhcd
     C                   exsr      $rtvwhds
     C                   move      wkwhds        d1whds1
     C                   else
     C                   move      *blank        d1whds1
     C                   endif
      * Warehouse 2
     C                   when      fld = 'D1WHCD2'
     C                   call      'PDZNSRR'
     C                   parm      *blank        xxreturn
     C                   parm      *blank        xxwhcd
     C                   parm      d1whtycd      xxwhtycd
     C                   seton                                        52
     C                   if        xxwhcd <> *blank
     C                   move      xxwhcd        d1whcd2
     C                   move      d1whcd2       wkwhcd
     C                   exsr      $rtvwhds
     C                   move      wkwhds        d1whds2
     C                   else
     C                   move      *blank        d1whds2
     C                   endif
      * Warehouse 3
     C                   when      fld = 'D1WHCD3'
     C                   call      'PDZNSRR'
     C                   parm      *blank        xxreturn
     C                   parm      *blank        xxwhcd
     C                   parm      d1whtycd      xxwhtycd
     C                   seton                                        53
     C                   if        xxwhcd <> *blank
     C                   move      xxwhcd        d1whcd3
     C                   move      d1whcd3       wkwhcd
     C                   exsr      $rtvwhds
     C                   move      wkwhds        d1whds3
     C                   else
     C                   move      *blank        d1whds3
     C                   endif
      * Warehouse 4
     C                   when      fld = 'D1WHCD4'
     C                   call      'PDZNSRR'
     C                   parm      *blank        xxreturn
     C                   parm      *blank        xxwhcd
     C                   parm      d1whtycd      xxwhtycd
     C                   seton                                        54
     C                   if        xxwhcd <> *blank
     C                   move      xxwhcd        d1whcd4
     C                   move      d1whcd4       wkwhcd
     C                   exsr      $rtvwhds
     C                   move      wkwhds        d1whds4
     C                   else
     C                   move      *blank        d1whds4
     C                   endif
      * Warehouse 5
     C                   when      fld = 'D1WHCD5'
     C                   call      'PDZNSRR'
     C                   parm      *blank        xxreturn
     C                   parm      *blank        xxwhcd
     C                   parm      d1whtycd      xxwhtycd
     C                   seton                                        55
     C                   if        xxwhcd <> *blank
     C                   move      xxwhcd        d1whcd5
     C                   endif
      * Warehouse 6
     C                   when      fld = 'D1WHCD6'
     C                   call      'PDZNSRR'
     C                   parm      *blank        xxreturn
     C                   parm      *blank        xxwhcd
     C                   parm      d1whtycd      xxwhtycd
     C                   seton                                        56
     C                   if        xxwhcd <> *blank
     C                   move      xxwhcd        d1whcd6
     C                   move      d1whcd5       wkwhcd
     C                   exsr      $rtvwhds
     C                   move      wkwhds        d1whds5
     C                   else
     C                   move      *blank        d1whds5
     C                   endif
      *
      * From Item Code
     C                   when      fld = 'D1FITCD'
     C                   call      'OMZ8SRR'
     C                   parm      *blank        xxreturn
     C                   parm      0             xxitcd
     C                   seton                                        59
     C                   if        xxitcd <> 0
     C                   z-add     xxitcd        d1fitcd
     C     d1fitcd       chain     ombyrel1                           92
     C                   if        *in92 = *off
     C                   eval      d1fitds = byavna
     C                   endif
     C                   endif
      *
      * To Item Code
     C                   when      fld = 'D1TITCD'
     C                   call      'OMZ8SRR'
     C                   parm      *blank        xxreturn
     C                   parm      0             xxitcd
     C                   seton                                        58
     C                   if        xxitcd <> 0
     C                   z-add     xxitcd        d1titcd
     C     d1titcd       chain     ombyrel1                           92
     C                   if        *in92 = *off
     C                   eval      d1titds = byavna
     C                   endif
     C                   endif
      *
     C                   other
      *
      * F4 not valid for this field, so issue message
      *
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'USR4649'
     C                   endif
     C                   endsl
      *
     C                   endsr
      /EJECT
      *---------------------------------------------------------------
      * Retrieve Warehouse Name/Description
      *---------------------------------------------------------------
      *
     C     $rtvwhds      begsr
      *
     C     wkwhcd        chain     caadrel1                           92
     C                   if        *in92 = *off
     C                   eval      wkwhds = adf8na
     C                   else
     C                   move      *blank        wkwhds
     C                   endif
      *
     C                   endsr
      /EJECT
      *---------------------------------------------------------------
      * Call the Synon Pop-up Print Window
      *---------------------------------------------------------------
      *
     C     $print        begsr
      *
     C                   call      'PDG0PVR'                              92
     C                   parm      *blank        xxreturn
     C                   parm                    xxdesc
     C     ldoutq        parm                    xxprinter
     C     ldhold        parm                    xxhold
     C     ldsave        parm                    xxsave
     C     ldcopy        parm                    xxcopies
     C                   parm                    xxniteynfl
     C                   parm                    xxniteque
     C                   parm                    xxappcode
      *
     C                   if        xxreturn = 'Y2U9999'
     C                   else
     C                   exsr      $proc1
     C                   endif
      *
     C                   endsr
      /EJECT
      *---------------------------------------------------------------
      * Process user's request
      *---------------------------------------------------------------
      *
      * This subroutine is only executed if the user submits the report
      *
     C     $proc1        begsr
      *
      * Move submission values into LDA
      *
     C                   move      d1whtycd      ldwhtycd
     C                   z-add     d1fmdy        ldfmdy
     C                   z-add     d1tmdy        ldtmdy
     C                   z-add     d1age         ldage
     C                   move      d1yn          ldyn
     C                   move      d1sumyn       ldsumyn
     C                   z-add     d1fitcd       ldfitcd
     C                   move      d1fitds       ldfitds
     C                   z-add     d1titcd       ldtitcd
     C                   move      d1titds       ldtitds
     C                   move      d1sofl        ldsofl
      *
     C                   move      arwhcd(1)     ldwhcd1
     C                   move      arwhds(1)     ldwhds1
     C                   move      arwhcd(2)     ldwhcd2
     C                   move      arwhds(2)     ldwhds2
     C                   move      arwhcd(3)     ldwhcd3
     C                   move      arwhds(3)     ldwhds3
     C                   move      arwhcd(4)     ldwhcd4
     C                   move      arwhds(4)     ldwhds4
     C                   move      arwhcd(5)     ldwhcd5
     C                   move      arwhds(5)     ldwhds5
     C                   move      arwhcd(6)     ldwhcd6
     C                   move      arwhds(6)     ldwhds6
      *
     C                   out       lda
      *
      * Move the 80-character compile time array 'CMD' to an
      * 80-character field for passing as a parm with QCMDEXC.
      *
     C                   if        xxniteynfl = yes
     C                   movea     cmd2          cmdsbm
     C                   else
     C                   movea     cmd1          cmdsbm
     C                   endif
      *
     C                   call      'QCMDEXC'
     C                   parm                    cmdsbm
     C                   parm                    length
      *
      * Issue the standard request submission message
      *
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'USR1832'
     C                   endif
      *
     C                   endsr
      /EJECT
      *---------------------------------------------------------------
      * Write error messages
      *---------------------------------------------------------------
      *
     C     $wrmsg        begsr
      *
     C                   call      'UT80045J'                           43
     C                   parm                    mgid
     C                   parm                    mgdt
     C                   parm                    error
     C                   parm                    pgm
     C                   parm                    msgfl
      *
      * If call to UT80045J failed, a message hardcoded in the DSPF
      * command line format will be set on. So, redisplay screen.
      *
     C                   if        *in43 = *on
     C                   eval      routne = set1
     C                   endif
      *
     C                   endsr
      *
      *----------------------------------------------------------------
      * Clear messages
      *----------------------------------------------------------------
      *
     C     $clmsg        begsr
      *
     C                   call      'UT80045J'                           43
     C                   parm      *blank        mgi
     C                   parm      *blank        mgd
     C                   parm      *zero         error
     C                   parm      sdpgm         pgm
     C                   parm      msgfil        msgfl
      *
      * If call to UT80045J failed, a message hardcoded in the DSPF
      * command line format will be set on; so, redisplay screen.
      *
     C                   if        *in43 = *on
     C                   eval      routne = set1
     C                   endif
      *
     C                   endsr
      /eject
      *---------------------------------------------------------------
      * Seton last record and end job
      *---------------------------------------------------------------
      *
     C     $exit         begsr
     C                   seton                                        lr
     C                   endsr
      /eject
      *----------------------------------------------------------------
      * Initialization subroutine
      *----------------------------------------------------------------
      *
     C     *inzsr        begsr
      *
      * Parm lists
      *    None
      *
      * Key lists
      *    None
      *
      * Initialize numeric LDA fields
      *
     C                   z-add     0             ldfmdy
     C                   z-add     0             ldtmdy
     C                   z-add     0             ldfcymd
     C                   z-add     0             ldtcymd
     C                   z-add     0             ldage
     C                   z-add     0             ldfitcd
     C                   z-add     0             ldtitcd
     C                   out       lda
      *
      * Default the System Date into the To Production Date.
      *
     C                   move      udate         d1tmdy
     C     *mdy          move      udate         wkiso
     C     *cymd         move      wkiso         wksysdt
      *
      * Default 'No' to the "Only print Items with Available to Sell Quantity"
     C                   move      no            d1yn
      *
      * Default 'No' to the "Only print Summary Page"
     C                   move      no            d1sumyn
      *
      * Default the 6 frozen warehouses that the user's want most often.
      *
     C                   move      'FZ'          d1whtycd
     C                   move      'S'           d1sofl
      *
     C                   move      'SF1'         d1whcd1
     C                   move      d1whcd1       wkwhcd
     C                   exsr      $rtvwhds
     C                   move      wkwhds        d1whds1
      *
     C                   move      'SA1'         d1whcd2
     C                   move      d1whcd2       wkwhcd
     C                   exsr      $rtvwhds
     C                   move      wkwhds        d1whds2
      *
     C                   move      'EF1'         d1whcd3
     C                   move      d1whcd3       wkwhcd
     C                   exsr      $rtvwhds
     C                   move      wkwhds        d1whds3
      *
     C                   move      'CF1'         d1whcd4
     C                   move      d1whcd4       wkwhcd
     C                   exsr      $rtvwhds
     C                   move      wkwhds        d1whds4
      *
     C                   move      'FS1'         d1whcd5
     C                   move      d1whcd5       wkwhcd
     C                   exsr      $rtvwhds
     C                   move      wkwhds        d1whds5
      *
     C                   move      'EF3'         d1whcd6
     C                   move      d1whcd6       wkwhcd
     C                   exsr      $rtvwhds
     C                   move      wkwhds        d1whds6
      *
      * The following standard code must be included to make the
      * standard error message handling program function properly.
      * This code sets and clears the program message queue.
      *
     C                   movel     '*'           msgpgm
     C                   exsr      $clmsg
      *
     C                   endsr
      /EJECT
      *****************************************************************
      * COMPILE TIME ARRAY 'CMD' USED IN QCMDEXC
      *****************************************************************
** CMD table 1 'CMD' submits listing
SBMJOB CMD(CALL PGM(PBKACLP))  JOB(WHSAGINV) JOBQ(*JOBD)
** CMD table 2 'CMD' submits listing
SBMJOB CMD(CALL PGM(PBKACLP))  JOB(WHSAGINV) JOBQ(GUYNIGHTQ)
