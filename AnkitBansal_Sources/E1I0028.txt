     Z* CRTBNDRPG
     Z* DFTACTGRP(*NO) BNDDIR(YBNDDIR) DBGVIEW(*SOURCE)
     Z* CVTOPT(*DATETIME) ACTGRP(*CALLER) OPTIMIZE(*BASIC)
     H/TITLE  E1I0028  - Convert and Edit Dates for JDE Enterprise 1 copied from X0028
     H* ----------------------------------------------------------------
     H*
     H*    Copyright (c) 1990
     H*    J. D. Edwards & Company
     H*
     H*        This unpublished material is proprietary to
     H*        J. D. Edwards & Company.  All rights reserved.
     H*        The methods and techniques described herein are
     H*        considered trade secrets and/or confidential.
     H*        Reproduction or distribution, in whole or in part,
     H*        is forbidden except by express written permission
     H*        of J. D. Edwards & Company.
     H*
     H* ----------------------------------------------------------------
     H*                                                                -
     F*
     F*    PROGRAM REVISION LOG
     F*    --------------------
     F*
     F*          Date     Programmer     Nature of Revision
     F*        --------   ----------  ------------------------------------
     F*        01/07/86   JLT         Creation on S/38 (A/G)
     F*        09/15/88   NUGENT      SAR # 32846
     F*        04/23/90   JLT         SAR # 74392
     F*        10/17/91   SAO         SAR # 376948
     F*        10/26/92   KREUTZ      SAR # 411694
     F*        12/11/92   KREUTZ      SAR # 491065
     F*        04/19/93   MILLS       SAR # 595972
     F*        06/10/93   SAO         SAR # 614871
     F*        09/03/93   KIRKWOOD    SAR # 651760
     F*        03/17/95   SCHIFF      SAR # 867923
     F*        07/31/95   KREUTZ      SAR # 948686
     F*        10/19/95   KREUTZ      SAR # 1054570 Again 03/05/96
     F*         3/15/96  jb875561     SAR # 1168104 NLS Compliance
     F*        10/17/96   SCHIFF      SAR # 1391592
     F*         1/12/98   BECK        SAR # 2636547
     F*         3/31/20   BRAD BADEN  SDN465  TFS# 16169
     F*                   Copied from X0028 for JDE Enterprise 1
     F*                   Renamed file F0089 to E10089
     F*
     F* ----------------------------------------------------------------
     F*
     F*F0089     IF   E           K DISK    USROPN
     F*F0089LA   IF   E           K DISK    USROPN
     FE10089L1  IF   E           K DISK    USROPN
     f*         Japanese Era Dates F0089   RTV index by Japanese Era
     f*
     FE10089LA  IF   E           K DISK    USROPN
     f*         Japanese Era Dates F0089   RSQ index by Yr/Mo/Day
     f*
     F*                                    RENAME(I0089:I0089A)
     D**************************************************************************
     D*    PROGRAM TABLES AND ARRAYS
     D*    -------------------------
     D*
     D @DM             S              3  0 DIM(12) CTDATA PERRCD(12) ASCEND     Days per month
     D @DL             S              3  0 DIM(12) CTDATA PERRCD(12) ASCEND     Days per month
     D @DG             S              3  0 DIM(12) CTDATA PERRCD(12)            Greg. days/mth
     D TABD            S              8  0 DIM(4) CTDATA PERRCD(4) DESCEND      Japanese Dates
     D TABE            S              1    DIM(4) ALT(TABD)
     D CMD             S              1    DIM(32) CTDATA PERRCD(32)            CHGJOB command
     D DLT             S              1    DIM(29) CTDATA PERRCD(29)            DLTDTAARA Cmd
     D @FF             S              1    DIM(3)                               From format
     D @TF             S              1    DIM(3)                               To   format
     D*
     D*    Copy Composite Member for Common Subroutine - C0012
     D*
     D*/COPY JDECPY,E0012
     D**************************************************************
     D*  This is part of a composite common subroutine. In
     D*  order for the subroutine to work correctly, the
     D*  RPG program must /COPY in the following members:
     D*   E0012, C0012
     D*********************************************************************00004
     D*    PROGRAM TABLES AND ARRAYS
     D*    -------------------------
     D*
     D @NM             S              1    DIM(22)                              C0012 Scrub arr
     D @N2             S              1    DIM(22)                              C0012 Scrub arr
     D**************************************************************************
     D*    PROGRAM INPUT SPECIFICATIONS AND DATA STRUCTURES
     D*    ------------------------------------------------
     D*
     D*
     D*    Data Structure for system date format and separator.
     D*
     D X0028           DS
     D  $SYFMT                 1      3
     D  $SYSEP                 4      4
     D  #9LNGP                 5      6
     D  #9CO                   7     11
     D  #9DECF                12     12
     D  #9VRSP                13     18
     D  #9CUR                 19     19
     D  $$FILR                20    256
     D  $1FILR               257    512
     D*
     D*    Data Structure for input date formats.
     D*
     D #SIDAT          DS
     D  $$CTRY                 1      1
     D  $$JYR                  2      3
     D  $$JDY                  4      6
     D*  Used for test numeric instead of TESTN
     D  $IDT1                  1      1
     D  $IDT2                  2      2
     D  $IDT3                  3      3
     D  $IDT4                  4      4
     D  $IDT5                  5      5
     D  $IDT6                  6      6
     D*  USED FOR SPLITTING DATE INTO YY MM DD
     D*   --  IF FFMT = MDY
     D  $IMM1                  1      2
     D  $IDD1                  3      4
     D  $IYY1                  5      6
     D*   --  IF FFMT = DMY
     D  $IDD2                  1      2
     D  $IMM2                  3      4
     D  $IYY2                  5      6
     D*   --  IF FFMT = YMD
     D  $IYY3                  1      2
     D  $IMM3                  3      4
     D  $IDD3                  5      6
     D*   --  OTHERWISE USE
     D  @DT                    1      6
     D                                     DIM(3)                               Gegorian Date
     D*
     D*    Data Structure for input date with century
     D*
     D #SIDT2          DS
     D*  Used for test numeric instead of TESTN
     D  $IDC1                  1      1
     D  $IDC2                  2      2
     D  $IDC3                  3      3
     D  $IDC4                  4      4
     D  $IDC5                  5      5
     D  $IDC6                  6      6
     D  $IDC7                  7      7
     D  $IDC8                  8      8
     D*  USED FOR SPLITTING DATE INTO YY MM DD
     D*   --  IF FFMT = MDY
     D  $IMX1                  1      2
     D  $IDX1                  3      4
     D  $IYX1                  5      8
     D*   --  IF FFMT = DMY
     D  $IDX2                  1      2
     D  $IMX2                  3      4
     D  $IYX2                  5      8
     D*   --  IF FFMT = YMD
     D  $IYX3                  1      4
     D  $IMX3                  5      6
     D  $IDX3                  7      8
     D*   --  OTHERWISE USE
     D  @DX                    1      8
     D                                     DIM(4)                               Grg Date w CC
     D*
     D*    Data Structure for Japanese Era Beginning Date
     D*
     D DSDT1           DS
     D* ZEERY                  1      4  0
     D  EEERY                  1      4  0
     D  ZEYR2                  3      4  0
     D* ZEERM                  5      6  0
     D  EEERM                  5      6  0
     D* ZEERD                  7      8  0
     D  EEERD                  7      8  0
     D  ZEER                   1      8  0
     D*
     D DSDT2           DS
     D  $FMTYC                 1      4
     D  $FMTYR                 1      4  0
     D*  Used for testing for leap year instead of div by 4
     D  $CC#                   1      2  0
     D  $CC                    1      2
     D  $HICC                  1      1
     D  $LOCC                  2      2
     D  $YY                    3      4
     D  $HIYR                  3      3
     D  $LOYR                  4      4
     D*
     D  $MONTC                 5      6
     D  $MONTH                 5      6  0
     D*  #M used to index into @DG instead of IF AND OR AND
     D  #M                     5      6  0
     D  $DAY                   7      8  0
     D  $DAYC                  7      8
     D  $JPDT                  1      8  0
     D*
     D*  Used to save $CC for JUL overflow to see if we need to re-
     D*  calculate the $CTRY field
     D                 DS
     D  $#FMTY                 1      4  0
     D  $#CC                   1      2
     D*
     D*    Data Structure for formated output date, no CCYY
     D*
     D #EDAT           DS
     D  #E1                    1      2
     D  SEP1                   3      3
     D  #E2                    4      5
     D  SEP2                   6      6
     D  #E3                    7      8
     D  $@JDY                  3      5
     D  SEPJ1                  6      6
     D  $@JYR                  7      8
     D*
     D*    Data Structure for formated output date, CCYY
     D*
     D #EDAT2          DS
     D  @D2                    1     10
     D                                     DIM(10)                              Grg Date w CC
     D*
     D*   QJDF Data Area Data Structure
     D*
     D*/COPY JDECPY,I00QJDF
     D*****************************************************************
     D*
     D*    JDE System Values Data Structure
     D*    ================================
     D*
     D QJDF            DS          2000
     D*
     D*    Time-out period, in seconds, for menu display file
     D*    (This value obsoleted in release A3)
     D  #$TIME                31     36
     D*
     D*    Single/Double column menu indicator (*IN03)
     D*    (This value obsoleted in release A4)
     D  #$IN03                50     50
     D*
     D*    Source file library name
     D  #$LIBS                81     90
     D*
     D*    Color Palette flag (1=SAA  2=JDE).
     D  #$COLR               100    100
     D*
     D*    Menu display file library name
     D  #$LIBO               131    140
     D*
     D*    Menu display file soft coding data record key (F0020)
     D  #$VOK                141    148
     D*
     D*    User profile file (F0092) library name
     D  #$LIBD               181    190
     D*
     D*    Country code for menu masking
     D  #$CC                 191    193
     D*
     D*    Name of program to be executed by all terminals
     D  #$PROG               231    240
     D*
     D*    System Identification name
     D  #$SYID               281    288
     D*
     D*    Hidden Menu Key
     D  #$HIDM               331    340
     D*
     D*    Positions 381-399 are reserved for BPs or Clients to
     D*    override the Product ID and PTF level displayed on a
     D*    menu in the lower right corner when hidden selection
     D*    25 is taken.  Changes to the data area are done through
     D*    the CHGDTAARA command.  (11/08/95)
     D*
     D*    Product ID (ex. 'Genesis')
     D* reserved                            381 387 #$VERS
     D*    Product Release (ex. '1.1')
     D* reserved                            388 393 #$PRD
     D*    PC Identification (ex.'00009')
     D* reserved                            394 398 #$PC
     D*    Product ID Override Flag (Set to '1' to override)
     D* reserved                            399 399 #$PFLG
     D*
     D*    Member Master Editing Program
     D*    (This value obsoleted in release A5) ????
     D  #$EPGM               431    440
     D*
     D*    Time format (' '=am/pm, '1'=24hr)
     D  #$TF                 450    450
     D*
     D*    Date format (AD,AM DD, YYYY)
     D  #$DF                 451    466
     D*
     D*    Software Protection Notification Days
     D  #$SPD                481    483
     D*
     D*    Software Protection Expiration Date
     D  #$SPED               496    501
     D*
     D*    Software security code
     D  #$SPC                502    507
     D*
     D*    System/38 CPU serial number
     D*    (This value obsoleted in release F5 & A1)
     D*    Re-assigned this field to be the licensed user count for
     D*    User Based Pricing in A7.
     D  #$SRNO               508    512
     D  #$UBP$               508    512
     D  #$UBP#               508    512  0
     D*
     D*    User Based Pricing Audit Flag
     D  #$AUD                520    520
     D*
     D*    User Based Pricing Code
     D  #$UBP                535    544
     D*
     D*    Japanese date flag (' ' = Western  '1' = Japanese)
     D  #$JAPD               600    600
     D*
     D*    MARCAM flag (' ' = No  '1' = Yes)
     D  #$MARC               610    610
     D*
     D*    Software Installation Type (' ' = Normal Install,
     D*                                '1' = One Step Install)
     D  #$INST               611    611
     D*
     D*    Double byte system 1 = yes, 0 = no
     D  #$#RSP               620    620
     D*
     D*    Language preference
     D  #$LNGP               630    631
     D*
     D*    Version prefix
     D  #$VRSP               640    645
     D*
     D*    Number of Users
     D  #$USR                650    659
     D*
     D*    Pricing Method
     D  #$PRMT               670    670
     D*
     D*    Application Override System
     D  #$#SYR               680    683
     D*
     D*    Imaging
     D  #$IMG                690    690
     D*
     D*    Control File Library
     D  #$LIBC               701    710
     D*
     D*    Demo/Training Flag
     D  #$DEMO               720    721
     D*----------------------------------------------------------------
     D*
     D* Program Status Data Structure (parms portion)
     D*
     D                SDS
     D*          Number of Parameters Passed to This Program
     D  ##PARM           *PARMS
     D*
     D*
     D*    Copy Routine for ZONED  Indexes
     D*
     D* /COPY JDECPY,I00DSINX
     D*/COPY JDECPY,I9800E
     D*
     D*    Data Dictionary Edit Structure
     D*
     D I9800E          DS
     D*
     D*    Data Item
     D  FRDTAI                 1     10
     D*    Data Item Type
     D  FRDTAT                11     11
     D*    Edit Code
     D  FREC                  12     12
     D*    Data Item Size
     D  FRDTAS                13     17  0
     D*    Data File Decimals
     D  FRDTAD                18     19  0
     D*    Install System Code
     D  FRSY                  20     23
     D*    Row Description
     D  FRDSCR                24     63
     D*    User Defined Codes
     D  FRRT                  64     65
     D*    Default Value for Entry
     D  FRDVAL                66    105
     D*    Allowed Values if not Desc. Title
     D  FRVAL                106    145
     D*    Lower Allowed Value
     D  FRLVAL               146    185
     D*    Upper Allowed Value
     D  FRUVAL               186    225
     D*    Data Display Decimals
     D  FRCDEC               226    226
     D*    Next Numbering Index Number
     D  FRNNIX               227    228  0
     D*    Edit Word
     D  FREDWR               229    258
     D*    Justify (R or L)
     D  FRLR                 259    259
     D*    Editing Subroutine Name
     D  FREXTN               260    269
     D*    Reporting System Code
     D  FRSYR                270    273
     D*    Data Item Category
     D  FRDSYN               274    283
     D*    Error Flag (1=Error 0=Okay)
     D  FRERR                284    284
     I****************************************************************
     C**************************************************************************
     C*    MAINLINE PROGRAM
     C*    ----------------
     C*
     C*    Passed parameters:
     C*      1.  Input/output date.
     C*      2.  Edited output date.
     C*      3.  Input format.
     C*      4.  Output format.
     C*      5.  Separator character.
     C*      6.  Error flag.
     C*
     C     *ENTRY        PLIST
     C                   PARM                    #SIDAT            6
     C                   PARM                    #EDAT             8
     C                   PARM                    #FFMT             7
     C                   PARM                    #TFMT             7
     C                   PARM                    #SEP              7
     C                   PARM                    $ERTST            1
     C*    Optional parameters
     C                   PARM                    $CTRY             2
     C                   PARM                    #FJPN             1
     C                   PARM                    #TJPN             1
     C*    SAR 1380148 - extra parms for dates with imbedded century
     C                   PARM                    #EDAT2           10
     C                   PARM                    #SIDT2            8
     C*   # Parms saved in packed field to make ##PARM IFGT quicker
     C                   Z-ADD     ##PARM        #$PARM            3 0
     C                   MOVE      ' '           $LDAT             1
     C*
     C*    Load default data format information.
     C*
     C     $F9800        IFNE      'Y'
     C                   Z-ADD     10            $$#CYR            3 0
     C                   MOVE      'Y'           $F9800            1
     C                   MOVEL     *BLANKS       FRDTAI
     C                   MOVEL     '#CYR'        FRDTAI
     C*                  CALL      'X9800E'                             81
     c                   CALL      'E1I9800E'                           81
     C*                    ---- --------
     C                   PARM                    I9800E
     C                   MOVE      FRERR         *IN81
     C     *IN81         IFEQ      '0'
     C     FRDVAL        ANDNE     *BLANKS
     C                   MOVEA     FRDVAL        @NM
     C                   EXSR      C0012
     C*                    ---- -----
     C                   Z-ADD     #NUMR         $NBR2             2 0
     C                   Z-ADD     $NBR2         $$#CYR
     C                   END
     C                   END
     C*
     C     #$PARM        IFEQ      0
     C*
     C*    Refresh X0028 Data Area.
     C*
     C                   IN        X0028                                81
     C     *IN81         IFNE      '1'
     C                   CALL      'QCMDEXC'                            99
     C                   PARM                    DLT
     C                   PARM      29.00000      CMDLEN
     C                   END
     C                   EXSR      S004
     C*                    ---- ----
     C                   GOTO      END
     C*                    ---- ---
     C                   END
     C*
     C                   Z-ADD     0             $CTRY#            3 0
     C     #$PARM        IFGE      7
     C     $CTRY         ANDNE     *BLANKS
     C                   MOVE      $CTRY         $CTRY#
     C                   END
     C*
     C*    If Japanese format parms passed in, retrieve QJDF data
     C*     area (once only)
     C*
     C                   MOVE      ' '           $JPN              1
     C     #$PARM        IFGE      9
     C*
     C     $QJDF         IFEQ      ' '
     C     *DTAARA       DEFINE                  QJDF
     C                   IN        QJDF                                 98
     C                   MOVE      '1'           $QJDF             1
     C                   END
     C*
     C     #$JAPD        IFEQ      '1'
     C                   MOVE      '1'           $JPN
     C                   END
     C                   END
     C*
     C*    If Japanese mode is set, open Japanese Eras file
     C*
     C     $JPN          IFEQ      '1'
     C     $OPEN         ANDEQ     ' '
     C                   MOVE      '1'           $F0089
     C*                  OPEN      F0089                                81
     C*                  OPEN      F0089LA                              82
     C                   OPEN      E10089L1                             81
     C                   OPEN      E10089LA                             82
     C     *IN81         IFEQ      '1'
     C     *IN82         OREQ      '1'
     C                   MOVE      ' '           $F0089            1
     C                   END
     C                   MOVE      '1'           $OPEN             1
     C                   END
     C*
     C*
     C                   MOVE      *BLANK        #EDAT
     C                   MOVE      ' '           $ERTST
     C*
     C*    Retrieve system date format and date separator(once only).
     C*
     C     $SYFMT        IFEQ      *BLANK
     C                   EXSR      S004
     C*                    ---- ----
     C                   END
     C*
     C     #SEP          IFNE      '*SYSVAL'
     C     #SEP          ANDNE     '*NONE  '
     C     #SEP          ANDNE     '       '
DBN  C                   MOVEL     #SEP          $$SEP             1
     C                   ELSE
     C                   MOVE      $SYSEP        $$SEP
     C                   END
     C*
     C*    Test for blank input or negative number.
     C*
     C     #$PARM        IFGT      10                                           CCYYMMDD
      *
     C     #SIDT2        IFNE      *BLANK
     C     #SIDT2        ANDNE     '00000000'
      *
     C*   The following code replaces  TESTN  and MOVE with neg. indic
     C     $IDC8         IFGE      'A'
     C     $IDC8         ANDLE     'R'
     C                   BITON     '23'          $IDC8                          MAKE POSITIVE
     C                   ENDIF
      *
     C     $IDC1         IFGE      '0'
     C     $IDC1         ANDLE     '9'
     C     $IDC2         ANDGE     '0'
     C     $IDC2         ANDLE     '9'
     C     $IDC3         ANDGE     '0'
     C     $IDC3         ANDLE     '9'
     C     $IDC4         ANDGE     '0'
     C     $IDC4         ANDLE     '9'
     C     $IDC5         ANDGE     '0'
     C     $IDC5         ANDLE     '9'
     C     $IDC6         ANDGE     '0'
     C     $IDC6         ANDLE     '9'
     C     $IDC7         ANDGE     '0'
     C     $IDC7         ANDLE     '9'
     C     $IDC8         ANDGE     '0'
     C     $IDC8         ANDLE     '9'
     C                   ELSE                                                   NOT NUMERIC
     C                   MOVE      '1'           $ERTST
     C                   MOVE      '000000'      #SIDAT
     C                   MOVE      '00000000'    #SIDT2
     C                   RETURN
     C                   ENDIF
     C                   ELSE                                                   0 OR BLANK
     C                   MOVE      '1'           $ERTST
     C                   MOVE      '000000'      #SIDAT
     C                   MOVE      '00000000'    #SIDT2
     C                   RETURN
     C                   ENDIF
      *
     C                   ELSE                                                   NOT CCYYMMDD
     C     #SIDAT        IFNE      *BLANK
     C     #SIDAT        ANDNE     '000000'
      *
     C*   The following code replaces  TESTN  and MOVE with neg. indic
     C     $IDT6         IFGE      'A'
     C     $IDT6         ANDLE     'R'
     C                   BITON     '23'          $IDT6                          MAKE POSITIVE
     C                   ENDIF
      *
     C     $IDT1         IFGE      '0'
     C     $IDT1         ANDLE     '9'
     C     $IDT2         ANDGE     '0'
     C     $IDT2         ANDLE     '9'
     C     $IDT3         ANDGE     '0'
     C     $IDT3         ANDLE     '9'
     C     $IDT4         ANDGE     '0'
     C     $IDT4         ANDLE     '9'
     C     $IDT5         ANDGE     '0'
     C     $IDT5         ANDLE     '9'
     C     $IDT6         ANDGE     '0'
     C     $IDT6         ANDLE     '9'
     C                   ELSE                                                   NOT NUMERIC
     C                   MOVE      '1'           $ERTST
     C                   MOVE      '000000'      #SIDAT
     C                   RETURN
     C                   ENDIF
     C                   ELSE                                                   0 OR BLANK
     C                   MOVE      '1'           $ERTST
     C                   MOVE      '000000'      #SIDAT
     C                   RETURN
     C                   ENDIF
     C                   ENDIF
     C*
     C*    Determine input date year.
     C*
     C                   MOVE      0000          $FMTYR
DBN  C                   MOVEL     #FFMT         $FMT              4
     C     #FFMT         IFEQ      '*SYSVAL'
     C                   MOVEL     '*'           $FMT
     C                   MOVE      $SYFMT        $FMT
     C                   END
DBN  C                   MOVEL     #TFMT         $TFMT             4
     C     #TFMT         IFEQ      '*SYSVAL'
     C                   MOVEL     '*'           $TFMT
     C                   MOVE      $SYFMT        $TFMT
     C                   END
DBN  C                   MOVE      $FMT          $WRK3             3
     C                   MOVEA     $WRK3         @FF
DBN  C                   MOVE      $TFMT         $WRK3
     C                   MOVEA     $WRK3         @TF
     C     $FMT          IFEQ      '*JUL'
      *
      *  If from format Julian and date supplied in #SIDT2, move to
      *  #SIDAT
      *
     C     #$PARM        IFGT      10                                           CCYYMMDD
     C     #SIDAT        IFEQ      *BLANK
     C     #SIDAT        OREQ      '000000'
DBN  C                   MOVE      #SIDT2        #SIDAT
     C                   ENDIF
     C                   ENDIF
      *
      * Validate for julian day > *ZERO...
      *
     C     $$JDY         IFEQ      *ZERO
     C                   MOVE      '1'           $ERTST
     C                   RETURN
     C                   ENDIF
      *
     C                   MOVE      $$JYR         $FMTYR
     C     #$PARM        IFGT      6
     C                   Z-ADD     0             $PKD30            3 0
     C     $$CTRY        IFGE      '0'
     C     $$CTRY        ANDLE     '9'
     C                   MOVE      $$CTRY        $PKD30
     C                   ENDIF
     C                   ADD       19            $PKD30
     C                   MOVE      $PKD30        $CTRY
     C     $CTRY#        IFEQ      0
     C                   Z-ADD     $PKD30        $CTRY#
     C                   ENDIF
     C                   ENDIF
     C                   ENDIF
      *
     C     #$PARM        IFGT      10                                           Input CCYY?
      *  Determine whether user keyed in 6 or 8 bytes of date ...
DBN  C                   MOVE      #SIDT2        #NUMR8            8 0
     C     #NUMR8        IFGT      1000000
     C                   MOVE      '1'           $LDAT
     C                   ELSE
     C                   MOVE      #NUMR8        #SIDAT
     C                   ENDIF
     C                   ENDIF
      *
     C     $LDAT         IFEQ      '1'                                          Input CCYY
      *
     C*  IF changed to SELEC WHxx
     C                   SELECT
     C     $FMT          WHENEQ    '*MDY'
     C     $FMT          OREQ      '*DMY'
     C                   MOVE      @DX(3)        $CC
     C                   MOVE      @DX(4)        $YY
     C     $FMT          WHENEQ    '*YMD'
     C                   MOVE      @DX(1)        $CC
     C                   MOVE      @DX(2)        $YY
     C                   ENDSL
     C                   MOVE      $CC           $CTRY#
     C                   MOVE      $CC           $CTRY
      *
     C                   ELSE                                                   Input YY not CCYY
     C                   SELECT
     C     $FMT          WHENEQ    '*MDY'
     C                   MOVE      $IYY1         $YY
     C     $FMT          WHENEQ    '*DMY'
     C                   MOVE      $IYY2         $YY
     C     $FMT          WHENEQ    '*YMD'
     C                   MOVE      $IYY3         $YY
     C                   ENDSL
     C                   ENDIF
     C*
     C*    If "From" format is Japanese, resolve year to Western year
     C*
     C     $JPN          IFEQ      '1'
     C     #FJPN         ANDNE     *BLANKS
     C     $FMT          ANDNE     '*JUL'
     C*
     C     $F0089        IFEQ      '1'
     C*    #FJPN         CHAIN     I0089                              8199
     C     #FJPN         CHAIN     I0089L1                            8199
     C     *IN81         IFEQ      '1'
     C                   MOVE      '1'           $ERTST
     C                   RETURN
     C                   END
     C*
     C*    If Japanese Era file not found, use compile-time table
     C*
     C                   ELSE
     C     #FJPN         LOOKUP    TABE          TABD                     84
     C     *IN84         IFEQ      '0'
     C                   MOVE      '1'           $ERTST
     C                   RETURN
     C                   END
     C                   MOVE      TABD          ZEER
     C                   END
     C*
     C     ZEYR2         ADD       $FMTYR        $FMTYR
     C                   SUB       1             $FMTYR
     C     $FMTYR        IFGE      100
     C                   SUB       100           $FMTYR
     C                   END
     C                   END
     C*
     C     $LDAT         IFEQ      '1'                                          CCYYMMDD
     C     $CC#          SUB       19            $WORK1            1 0
     C                   MOVE      $WORK1        $CNTRY
     C                   ELSE                                                   NOT CCYYMMDD
     C     $CTRY#        IFLT      19
     C     $FMTYR        IFGT      $$#CYR
     C                   MOVE      '19'          $CC
     C                   MOVE      '0'           $CNTRY            1
     C                   ELSE
     C******     $FMTYR    IFLE $$#CYR
     C                   MOVE      '20'          $CC
     C                   MOVE      '1'           $CNTRY
     C                   ENDIF
     C                   ELSE                                                   $CTRY>=19
     C     $CTRY#        MULT      100           $WORK5            5 0
     C                   ADD       $WORK5        $FMTYR
     C     $CTRY#        SUB       19            $WORK1            1 0
     C                   MOVE      $WORK1        $CNTRY
     C                   ENDIF
     C                   ENDIF
     C*
     C*    USING  TESTB   ---   quicker than div by 4
     C*    Test for leap year, set leap year flag.
     C*
     C                   MOVE      '0'           $LEAP             1
     C*  IF LOW ORDER BIT IN UNITS OF YR ON, IT IS ODD
     C                   TESTB     '7'           $LOYR                    29
     C     *IN29         IFEQ      '0'                                           EVEN
     C*  IF YY IS '00' IT IS NOT A LEAP YEAR (EXCEPT FOR 2000)
     C     $YY           IFEQ      '00'
     C     $CC           IFEQ      '20'
     C                   MOVE      '1'           $LEAP
     C                   ELSE
     C                   MOVE      '0'           $LEAP
     C                   ENDIF
     C                   ELSE
     C*  IF BIT 6 IS ON IN UNITS OF YEAR, IS 2 OR 6
     C                   TESTB     '6'           $LOYR                    28
     C*  IF LOW ORDER BIT IN DECADE IS ON, IT IS ODD
     C                   TESTB     '7'           $HIYR                    27
     C     *IN27         IFEQ      '1'                                           DECADE ODD
     C     *IN28         IFEQ      '1'                                           YR 2 OR 6
     C                   MOVE      '1'           $LEAP
     C                   ENDIF                                                   YR 2 6
     C                   ELSE                                                    DECADE EVEN
     C     *IN28         IFEQ      '0'                                           YR 4 OR 8
     C                   MOVE      '1'           $LEAP
     C                   ENDIF                                                   YR 4 8
     C                   ENDIF                                                   DECADE ODD
     C                   ENDIF                                                  $YY = 0
     C                   ENDIF                                                  YY ODD
     C*
     C*    Test for julian date past end of current year.
     C*
     C     $FMT          IFEQ      '*JUL'
     C                   MOVE      $LEAP         $SLEAP            1
     C*  SAR 820324  --  SAVE CCYY TO TEST FOR CC CHANGE
     C                   MOVE      $FMTYR        $#FMTY
     C     $SLEAP        IFEQ      '0'
     C     $$JDY         ANDGT     '365'
     C                   ADD       1             $FMTYR
     C                   MOVE      '0'           $LEAP
     C*    USING  TESTB again as new year may be leap
     C*  IF LOW ORDER BIT IN UNITS OF YR ON, IT IS ODD
     C                   TESTB     '7'           $LOYR                    29
     C     *IN29         IFEQ      '0'                                           EVEN
     C*  IF YY IS '00' IT IS NOT A LEAP YEAR (EXCEPT FOR 2000)
     C     $YY           IFEQ      '00'
     C     $CC           IFEQ      '20'
     C                   MOVE      '1'           $LEAP
     C                   ELSE
     C                   MOVE      '0'           $LEAP
     C                   ENDIF
     C                   ELSE
     C*  IF BIT 6 IS ON IN UNITS OF YEAR, IS 2 OR 6
     C                   TESTB     '6'           $LOYR                    28
     C*  IF LOW ORDER BIT IN DECADE IS ON, IT IS ODD
     C                   TESTB     '7'           $HIYR                    27
     C     *IN27         IFEQ      '1'                                           DECADE ODD
     C     *IN28         IFEQ      '1'                                           YR 2 OR 6
     C                   MOVE      '1'           $LEAP
     C                   ENDIF                                                   YR 2 6
     C                   ELSE                                                    DECADE EVEN
     C     *IN28         IFEQ      '0'                                           YR 4 OR 8
     C                   MOVE      '1'           $LEAP
     C                   ENDIF                                                   YR 4 8
     C                   ENDIF                                                   DECADE ODD
     C                   ENDIF                                                  $YY = 0
     C                   ENDIF                                                  YY ODD
     C*
     C                   ENDIF                                                  DDD>365
     C*
     C     $SLEAP        IFEQ      '1'
     C     $$JDY         ANDGT     '366'
     C                   ADD       1             $FMTYR
     C                   MOVE      '0'           $LEAP
     C                   ENDIF                                                  DDD > 366
     C*  Re-calculate $CTRY if $CC changed
     C     $CC           IFNE      $#CC
     C                   SELECT
     C     $CC           WHENEQ    '19'
     C                   MOVE      '0'           $CNTRY            1
     C     $CC           WHENEQ    '20'
     C                   MOVE      '1'           $CNTRY
     C                   OTHER
     C                   MOVE      $CC           $WORK5
     C     $WORK5        SUB       19            $WORK1
     C                   MOVE      $WORK1        $CNTRY
     C                   ENDSL
     C                   ENDIF
     C                   ENDIF
     C*
     C*    If gregorian date format, determine month, day and year.
     C*
     C*  Replace IF ENDIF with SELEC.  Re-order tests most freq ->
     C*  least frequent
     C*  Replace moves from array with moves from DS redefines
     C*
     C     $LDAT         IFEQ      ' '                                          Input YY not CCYY
     C                   MOVE      $YY           $YEAR             2 0
     C                   SELECT
     C     $FMT          WHENEQ    '*MDY'
     C                   MOVE      $IMM1         $MONTH
     C                   MOVE      $IDD1         $DAY
      *
     C     $FMT          WHENEQ    '*DMY'
     C                   MOVE      $IMM2         $MONTH
     C                   MOVE      $IDD2         $DAY
      *
     C     $FMT          WHENEQ    '*YMD'
     C                   MOVE      $IMM3         $MONTH
     C                   MOVE      $IDD3         $DAY
     C                   ENDSL
      *
     C                   ELSE                                                   Input CCYY
     C                   MOVE      $YY           $YEAR
     C                   SELECT
     C     $FMT          WHENEQ    '*MDY'
     C                   MOVE      $IMX1         $MONTH
     C                   MOVE      $IDX1         $DAY
      *
     C     $FMT          WHENEQ    '*DMY'
     C                   MOVE      $IMX2         $MONTH
     C                   MOVE      $IDX2         $DAY
      *
     C     $FMT          WHENEQ    '*YMD'
     C                   MOVE      $IMX3         $MONTH
     C                   MOVE      $IDX3         $DAY
     C                   ENDSL                                                  $FMT/=JUL
     C                   ENDIF
     C*
     C*    If julian date format, determine month, day and year.
     C*
     C     $FMT          IFEQ      '*JUL'
     C                   MOVE      $FMTYR        $YEAR
     C                   MOVE      $$JDY         $NBR3             3 0
     C                   Z-ADD     00            $MONTH
     C                   Z-ADD     00            $DAY
     C     $SLEAP        IFEQ      '0'
     C     $NBR3         IFGT      365
     C                   SUB       365           $NBR3
     C                   ENDIF
     C                   ELSE                                                   LEAP=1
     C     $NBR3         IFGT      366
     C                   SUB       366           $NBR3
     C                   ENDIF
     C                   ENDIF
     C                   Z-ADD     01            #G                3 0
     C     $LEAP         IFEQ      '0'
     C     $NBR3         LOOKUP    @DM(#G)                            81  81
     C                   ELSE
     C     $NBR3         LOOKUP    @DL(#G)                            81  81
     C                   ENDIF
     C     *IN81         IFEQ      '1'
     C                   MOVE      #G            $MONTH
     C                   SUB       1             #G                       81
     C     *IN81         IFEQ      '0'
     C     $LEAP         IFEQ      '0'
     C                   SUB       @DM(#G)       $NBR3
     C                   ELSE
     C                   SUB       @DL(#G)       $NBR3
     C                   ENDIF
     C                   ENDIF
     C                   MOVE      $NBR3         $DAY
     C                   ENDIF
     C*
     C                   ENDIF
     C*
     C*    Edit month, day and year.
     C*   CHANGED TO USE ARRAY OF DAYS IN MONTHS
     C*
     C     $FMT          IFNE      '*JUL'                                       EDIT GREG
     C*  Changed to AND AND tests instead of IF AND OR AND
     C     $MONTH        IFGE      01
     C     $MONTH        ANDLE     12
     C     $DAY          ANDGE     01
     C     $DAY          ANDLE     31
      *  PASSED BASIC VALIDATION AT THIS POINT
     C     $DAY          IFGT      @DG(#M)
     C                   MOVE      '1'           $ERTST            1
     C     $MONTH        IFEQ      02
     C     $LEAP         ANDEQ     '1'
     C     $DAY          ANDEQ     29
     C                   MOVE      ' '           $ERTST            1
     C                   ENDIF                                                  02/29 LEAPYR
     C                   ENDIF                                                  $DAY > @DG
     C                   ELSE                                                   DID NOT PASS
     C                   MOVE      '1'           $ERTST            1             BASIC VALD
     C                   ENDIF
     C     $ERTST        IFEQ      '1'
     C                   RETURN
     C                   ENDIF
     C                   ENDIF                                                  EDIT GREG
     C*
     C*    Validate Japanese Date
     C*
     C     $JPN          IFEQ      '1'
     C     #FJPN         ANDNE     *BLANKS
     C     $FMT          ANDNE     '*JUL'
     C*
     C     $JPDT         IFLT      ZEER
     C                   MOVE      '1'           $ERTST
     C                   RETURN
     C                   ENDIF
     C                   ENDIF
     C*
     C*    If to format is julian, convert to julian format.
     C*
     C     $TFMT         IFEQ      '*JUL'
     C                   MOVE      $CNTRY        $$CTRY
     C     $MONTH        SUB       1             #G
     C     #G            IFGE      1
     C     $LEAP         IFEQ      '0'
     C                   MOVE      @DM(#G)       $NBR3
     C                   ELSE
     C                   MOVE      @DL(#G)       $NBR3
     C                   END
     C                   ELSE
     C                   MOVE      *ZERO         $NBR3
     C                   END
     C                   ADD       $DAY          $NBR3
     C*  Re-order moves to avoid numeric conversions
     C                   MOVE      $NBR3         $$JDY
     C                   MOVE      $$JDY         $@JDY
     C                   MOVE      $YY           $$JYR
     C                   MOVE      $$JYR         $@JYR
     C                   MOVE      $$SEP         SEPJ1
     C     #$PARM        IFGT      6
     C                   MOVE      $CC           $CTRY
     C                   ENDIF
     C     #$PARM        IFGT      09
     C                   MOVE(P)   #EDAT         #EDAT2
     C     #$PARM        IFGT      10
DBN  C                   MOVE(P)   #SIDAT        #SIDT2
     C                   ENDIF
     C                   ENDIF
     C                   END
     C*
     C*    If "To" format is Japanese, convert year to Japanese era
     C*
     C     $JPN          IFEQ      '1'
     C                   MOVE      #TJPN         $#TJPN            1
     C                   MOVE      *BLANKS       #TJPN
     C     $#TJPN        IFNE      *BLANKS
     C     $TFMT         ANDNE     '*JUL'
     C*
     C*                  MOVE      $MONTH        ZEERM
     C*                  MOVE      $DAY          ZEERD
     C*                  MOVE      $FMTYR        ZEERY
      *
     C                   MOVE      $MONTH        EEERM
     C                   MOVE      $DAY          EEERD
     C                   MOVE      $FMTYR        EEERY
     C*
     C     ZEKY0A        KLIST
     C*                  KFLD                    ZEERY
     C*                  KFLD                    ZEERM
     C*                  KFLD                    ZEERD
     C                   KFLD                    EEERY
     C                   KFLD                    EEERM
     C                   KFLD                    EEERD
     C*
     C     $F0089        IFEQ      '1'
     C*
     C*    ZEKY0A        SETLL     I0089A                                 81
     C     ZEKY0A        SETLL     I0089LA                                81
     C     *IN81         IFEQ      '0'
     C*    ZEKY0A        SETGT     I0089A
     C     ZEKY0A        SETGT     I0089LA
     C                   ENDIF
     C                   SETOFF                                       81
     C*                  READ      I0089A                               9981
     C                   READ      I0089LA                              9981
     C     *IN81         IFEQ      '1'
     C                   MOVE      '1'           $ERTST
     C                   RETURN
     C                   ENDIF
     C*                  MOVE      ZEERA         #TJPN
     C                   MOVE      EEERA         #TJPN
     C*
     C                   ELSE
     C*
     C*    If Japanese Era file not found, retrieve compile-time table
     C*
     C     ZEER          LOOKUP    TABD          TABE                     84    IN84 ON=EQ
     C     *IN84         IFEQ      '0'
     C     ZEER          LOOKUP    TABD          TABE                   84      IN84ON=LOW
     C                   END
     C     *IN84         IFEQ      '0'
     C                   MOVE      '1'           $ERTST
     C                   RETURN
     C                   END
DBN  C                   MOVE      TABE          #TJPN
     C                   MOVE      TABD          ZEER
     C                   END
     C*
     C     $FMTYR        SUB       ZEYR2         $JAPYR            4 0
     C                   ADD       1             $JAPYR
     C     $JAPYR        IFLT      *ZERO
     C                   ADD       100           $JAPYR
     C                   END
     C*
     C                   MOVE      $JAPYR        $YEAR
     C                   END
     C                   END
     C*
     C*    If to format is gegorian, convert to gegorian format.
     C*
     C     $TFMT         IFNE      '*JUL'
      *   Set up #SIDAT
      *
     C*  Replace IF ENDIF  with SELEC
     C                   SELECT
     C     $TFMT         WHENEQ    '*MDY'
     C                   MOVE      $MONTH        $IMM1
     C                   MOVE      $DAY          $IDD1
     C                   MOVE      $YEAR         $IYY1
     C     $TFMT         WHENEQ    '*DMY'
     C                   MOVE      $DAY          $IDD2
     C                   MOVE      $MONTH        $IMM2
     C                   MOVE      $YEAR         $IYY2
     C     $TFMT         WHENEQ    '*YMD'
     C                   MOVE      $YEAR         $IYY3
     C                   MOVE      $MONTH        $IMM3
     C                   MOVE      $DAY          $IDD3
     C                   ENDSL
      *
     C     #$PARM        IFGT      6
     C                   MOVE      $CC           $CTRY
     C                   ENDIF
      *
      *  Set up #EDAT
      *
     C                   MOVE      @DT(1)        #E1
     C                   MOVE      $$SEP         SEP1
     C                   MOVE      @DT(2)        #E2
     C                   MOVE      $$SEP         SEP2
     C                   MOVE      @DT(3)        #E3
     C*
      *
     C     #$PARM        IFGT      09                                           Output YY not CCYY
      *
      *  Set up #SIDT2 if supplied
      *
     C     #$PARM        IFGT      10                                           #SIDT2 SUPPL
     C                   SELECT
     C     $TFMT         WHENEQ    '*MDY'
     C                   MOVE      $MONTH        $IMX1
     C                   MOVE      $DAY          $IDX1
     C                   MOVE      $FMTYR        $IYX1
     C     $TFMT         WHENEQ    '*DMY'
     C                   MOVE      $DAY          $IDX2
     C                   MOVE      $MONTH        $IMX2
     C                   MOVE      $FMTYR        $IYX2
     C     $TFMT         WHENEQ    '*YMD'
     C                   MOVE      $FMTYR        $IYX3
     C                   MOVE      $MONTH        $IMX3
     C                   MOVE      $DAY          $IDX3
     C                   ENDSL
     C                   ENDIF
      *
      *   Set up #EDAT2
      *
     C                   SELECT
     C     $TFMT         WHENEQ    '*MDY'
DBN  C                   MOVEA     $MONTC        @D2(1)
     C                   MOVE      $$SEP         @D2(3)
DBN  C                   MOVEA     $DAYC         @D2(4)
     C                   MOVE      $$SEP         @D2(6)
DBN  C                   MOVEA     $FMTYC        @D2(7)
     C     $TFMT         WHENEQ    '*DMY'
DBN  C                   MOVEA     $DAYC         @D2(1)
     C                   MOVE      $$SEP         @D2(3)
DBN  C                   MOVEA     $MONTC        @D2(4)
     C                   MOVE      $$SEP         @D2(6)
DBN  C                   MOVEA     $FMTYC        @D2(7)
     C     $TFMT         WHENEQ    '*YMD'
DBN  C                   MOVEA     $FMTYC        @D2(1)
     C                   MOVE      $$SEP         @D2(5)
DBN  C                   MOVEA     $MONTC        @D2(6)
     C                   MOVE      $$SEP         @D2(8)
DBN  C                   MOVEA     $DAYC         @D2(9)
     C                   ENDSL
     C                   MOVE      $CC           $CTRY
     C                   ENDIF
     C                   ENDIF
     C*
     C*    Return to calling program, no LR.
     C*
     C     END           TAG
     C*          ---       ---
     C                   RETURN
     C*
     C*    End of Job
     C*
     C     EOJ           TAG
     C*          ---       ---
     C                   SETON                                        LR
     C*
     C*    END OF MAINLINE PROGRAM
     C*    -----------------------
     C*****************************************************************
     C*
     C*    SUBROUTINE S004 - Load X0028 Data Area
     C*    --------------------------------------
     C*
     CSR   S004          BEGSR
     C*          ----      -----
     C*
     C     *DTAARA       DEFINE                  X0028
     C                   IN        X0028                                81
     C     *IN81         IFEQ      '1'
     C*                  CALL      'J0028DTA'                           84
     C                   CALL      'E1I0028DTA'                         84
     C*                    ---- ----------
     C                   IN        X0028                                81
     C     *IN81         IFEQ      '1'
     C                   MOVEL     'MDY'         $SYFMT
     C                   MOVE      '/'           $SYSEP
     C                   MOVE      '  '          #9LNGP
     C                   MOVE      '     '       #9CO
     C                   MOVE      ' '           #9DECF
     C                   MOVE      '      '      #9VRSP
     C*
     C*    The next line used to move a dollar sign to #9CUR
     C*     but was changed for NLS compliance (SAR 1168104)
     C*     It is an unused field anyhow.
     C*
     C                   MOVE      ' '           #9CUR
     C*
     C*    Set Job Description Attributes to X0028.
     C*
     C                   Z-ADD     16            $1                3 0
     C                   MOVE      *BLANKS       $BLK3             3
DBN  C                   MOVEA     $BLK3         CMD($1)
DBN  C                   MOVEA     $SYFMT        CMD($1)
     C                   Z-ADD     29            $1
     C                   MOVEA     ' '           CMD($1)
     C                   MOVEA     $SYSEP        CMD($1)
     C                   CALL      'QCMDEXC'                            99
     C                   PARM                    CMD
     C                   PARM      32.00000      CMDLEN           15 5
     C                   END
     C                   END
     C*
     CSR   END004        ENDSR
     C****************************************************************
     C*
     C*    Copy Common Subroutine - Right Justify Numeric Fields
     C*
     C*/COPY JDECPY,C0012
     C**************************************************************
     C*  This is part of a composite common subroutine. In
     C*  order for the subroutine to work correctly, the
     C*  RPG program must /COPY in the following members:
     C*   E0012, C0012
     C**************************************************************************
    C*    REVISION LOG
    C*    ------------
    C*
    C*          Date     Programmer     Nature of Revision
    C*        --------   ----------  ------------------------------------
    C*        12/11/97   BECK        SAR# 1810110
    C*
     C**************************************************************************
     C*    MAINLINE PROGRAM
     C*    ----------------
     C*
     C*
     C*     SUBROUTINE C0012 - Right Justify Numeric Fields
     C*     -----------------------------------------------
     C*
     C*  PURPOSE
     C*  -------
     C*       To provide a subroutine common to all programs which
     C*       right justifies numeric fields and places the sign over
     C*       the low order byte of the fields, designated by either a
     C*       leading or trailing minus sign.  This routine also ignores
     C*       all non-numeric characters in the input field, and
     C*       determines the placement of the decimal point.
     C*
     C*  REMARKS
     C*  -------
     C*
     C*       Prior to executing this subroutine data from an
     C*       alphanumeric input field should be placed in the array
     C*       named '@NM' with a 'MOVEA' command.  The right justified
     C*       number is available from the subroutine field named
     C*       '#NUMR', which is a 15 digit 6 decimal field.
     C*       CAUTION: The largest number that can be handled
     C*       by this subroutine is 999,999,999.999999.
     C*       However, the input field may contain only 15
     C*       numbers.
     C*
     CSR   C0012         BEGSR
     C*          -----     -----
     C*
     CSR                 Z-ADD     0             #NUMR            29 9
     CSR                 Z-ADD     0             #NUMR2           15 2          Compile only
     CSR                 Z-ADD     0             #NUMR9           15 9          Compile only
     C*
     CSR                 MOVEA     @NM           #ALNUM           22
     CSR   #ALNUM        CABEQ     *BLANKS       EN0012
     CSR                 SETOFF                                       818384
     CSR                 MOVEA     *ALL'0'       @N2
     CSR                 Z-ADD     0             #K1               3 0
     CSR                 Z-ADD     0             #K2               3 0
     CSR                 Z-ADD     0             Q#                3 0
     CSR                 Z-ADD     0             J#                3 0
     CSR                 Z-ADD     0             M#                3 0
     C*
     C*    Retrieve date separation and decimal format characters.
     C*
     CSR   ###1          IFEQ      ' '                                          Do once
     CSR                 MOVE      '1'           ###1              1
     C*R                 CALL      'X00SFMT '                           81
     c                   call      'E1I00SFMT'                          81
     C*                    ---- ----------
     CSR                 PARM      '/'           ###DS             1
     CSR                 PARM      ' '           ###DF             1
     CSR                 MOVE      '.'           ###DC             1
     CSR   ###DF         IFEQ      'J'
     CSR   ###DF         OREQ      'I'
     CSR                 MOVE      ','           ###DC
     CSR                 END
     CSR                 MOVE      ' '           ###EQ             1
     CSR   ###DS         IFEQ      ###DC
     CSR                 MOVE      '1'           ###EQ
     CSR                 END
     CSR                 END
     C*
     C*    If date separator character equals decimal format character,
     C*    Test for multiple decimal point characters and replace with
     C*    US standard date separator character(/).
     C*
     CSR   ###EQ         IFEQ      '1'
     C*
     CSR                 Z-ADD     0             Q#
     CSR                 DO        22            M#
     CSR   @NM(M#)       IFEQ      ###DC
     CSR                 ADD       001           Q#
     CSR                 END
     CSR                 END
     C*
     CSR   Q#            IFGT      1
     CSR                 DO        22            M#
     CSR   @NM(M#)       IFEQ      ###DC
     CSR                 MOVE      '/'           @NM(M#)
     CSR                 END
     CSR                 END
     CSR                 END
     C*
     CSR                 MOVEA     @NM           #ALNUM
     CSR                 END
     C*
     C*    Initialize beginning and ending scan positions.
     C*
     CSR                 Z-ADD     +1            #LOW              3 0
     CSR                 Z-ADD     +22           #HIGH             3 0
     C*
     C*    Find first non-blank character.
     C*
     CSR   ' '           CHECK     #ALNUM        #LOW
     C*
     C*    Find last non-blank character.
     C*
     CSR   ' '           CHECKR    #ALNUM        #HIGH
     C*
     C*    Test minus sign.
     C*    String may be surrounded by quotes... ( dftval from DD )
     C*
     C* &&&      '-'       SCAN #ALNUM                   83
     CSR                 Z-ADD     #LOW          M#
     CSR   @NM(M#)       IFEQ      ''''
     CSR                 ADD       +1            M#
     CSR                 ENDIF
     C*
     CSR   @NM(M#)       COMP      '-'                                    83
     C*
     CSR   *IN83         IFEQ      '0'
     CSR                 Z-ADD     #HIGH         M#
     CSR   @NM(M#)       IFEQ      ''''
     CSR   M#            ANDGT     +1
     CSR                 SUB       1             M#
     CSR                 ENDIF
     C*
     CSR   @NM(M#)       COMP      '-'                                    83
     CSR                 ENDIF
     C*
     C*    Scrub numeric value.
     C*
     CSR                 Z-ADD     #HIGH         M#
     CSR                 Z-ADD     22            Q#
     CSR                 SUB       1             #LOW
     CSR   M#            DOWGT     #LOW
     CSR                 MOVE      @NM(M#)       @NMM#             1
     CSR   @NMM#         IFNE      *BLANKS
     CSR   @NMM#         IFGE      '0'
     CSR   @NMM#         ANDLE     '9'
     CSR   *IN84         IFEQ      '0'
     CSR                 ADD       001           #K1
     CSR                 END
     CSR                 MOVE      @NMM#         @N2(Q#)
     CSR                 SUB       01            Q#
     CSR                 END
     C*
     C*    If decimal point not already found, test for decimal.
     C*
     CSR   *IN84         IFEQ      '0'
     CSR   @NMM#         COMP      ###DC                                  84
     CSR                 END
     C*
     CSR                 END
     CSR                 SUB       001           M#
     CSR                 END
     C*
     C*    Move whole scrubbed number to work field.
     C*
     CSR                 MOVEA     @N2           #ALNUM
     CSR                 MOVE      #ALNUM        #WK29            29 0
     CSR                 Z-ADD     1             #MULTX           11 9
     CSR                 Z-ADD     1             #MULTY           11 9
     C*
     C*    Set up divisor for decimal positions.
     C*
     CSR   *IN84         IFEQ      '1'                                          DECIMAL FND
     CSR   #K1           IFGT      9
     CSR   #K1           SUB       9             #K2
     CSR                 DO        #K2
     CSR                 MULT      .1            #MULTY
     CSR                 END
     CSR                 Z-ADD     9             #K1
     CSR                 END
     CSR                 DO        #K1
     CSR                 MULT      .1            #MULTX
     CSR                 END
     CSR                 ELSE
     CSR                 Z-ADD     0             #K1
     CSR                 Z-ADD     0             #K2
     CSR                 END
     C*
     C*    If negative number, reverse sign on result.
     C*
     CSR   *IN83         IFEQ      '1'
     CSR                 MULT      -1            #WK29
     CSR                 END
     C*
     C*    Position decimal point in result.
     C*
     CSR   #WK29         MULT      #MULTX        #NUMR            29 9
     CSR   #K2           IFGT      0
     CSR                 MULT      #MULTY        #NUMR
     CSR                 END
     C*
     C*    Test for truncation of high value digits.
     C*
     CSR   6             SUB       #K1           M#
     CSR                 ADD       7             M#
     CSR                 Z-ADD     1             Q#
     CSR                 MOVE      ' '           #HV#              1
     CSR   Q#            DOWLE     M#
     CSR   @N2(Q#)       IFGT      '0'
     CSR                 MOVE      '1'           #HV#
     CSR                 Z-ADD     M#            Q#
     CSR                 END
     CSR                 ADD       01            Q#
     CSR                 END
     CSR   #HV#          IFEQ      '1'
     CSR   #WK29         MULT(H)   #MULTX        #NUMR2
     CSR   #K2           IFGT      0
     CSR                 MULT(H)   #MULTY        #NUMR2
     CSR                 END
     CSR                 END
     C*
     C*    Test for truncation of low value digits.
     C*
     CSR                 Z-ADD     0             $NBR3             3 0
     CSR   #K1           IFGT      6
     CSR                 Z-ADD     0             $NBR3
     CSR                 MOVE      #WK29         $NBR1             1 0
     CSR                 MOVE      $NBR1         $NBR3
     CSR                 END
     CSR   #K1           IFGT      7
     CSR                 Z-ADD     0             $NBR3
     CSR                 MOVE      #WK29         $NBR2             2 0
     CSR                 Z-ADD     $NBR2         $NBR3
     CSR                 END
     CSR   #K1           IFGT      8
     CSR                 MOVE      #WK29         $NBR3             3 0
     CSR                 END
     CSR   $NBR3         IFNE      0
     CSR   #WK29         MULT      #MULTX        #NUMR9
     CSR   #K2           IFGT      0
     CSR                 MULT      #MULTY        #NUMR9
     CSR                 END
     CSR                 END
     C*
     CSR                 MOVEA     *BLANK        @NM
     C*
     CSR   EN0012        ENDSR
**    Ending days for each month
031059090120151181212243273304334365
**    Ending days for each month - leap year
031060091121152182213244274305335366
**    #DAYS for each month  @DG
031028031030031030031031030031030031
**    Japanese Era Beginning Dates
19890108H19261226S19120731T18670101M
**     Change Job Description for User Display Preference
CHGJOB DATFMT(*   ) DATSEP(' ')
**     Refresh X0028 Data Area
DLTDTAARA DTAARA(QTEMP/X0028)
