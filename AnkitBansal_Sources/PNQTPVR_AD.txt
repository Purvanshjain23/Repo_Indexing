// ?------------------------------------------------------------------------------------------------
// ?Synon action diagram for PNQTPVR
// ?Date: 14.08.2025 Time: 03:46:12
// ?------------------------------------------------------------------------------------------------

//?USER: Initialize program

EXECUTE FUNCTION(VAL Set Inter. Access  IF) TYPE(EXCINTFUN)                     AC1144606;
PARAMETER('OMS');
PARAMETER(PAR.Company_Number);
PARAMETER(PAR.Warehouse_Code);
PARAMETER(PAR.Allow_Multi_Company);
PARAMETER(PAR.Default_Printer);
PARAMETER(PAR.Salesperson_Code);
{
 //?Execute internal function

 // PAR.User Profile Name = JOB.*USER
 PAR.User_Profile_Name = JOB.*USER;

 EXECUTE FUNCTION(VAL User/Application   IF) TYPE(EXCINTFUN)                     AC1144188;
 PARAMETER(PAR.User_Profile_Name);
 PARAMETER(PAR.Application_Code);
 PARAMETER(PAR.Company_Number);
 PARAMETER(PAR.Warehouse_Code);
 PARAMETER(PAR.Allow_Multi_Company);
 PARAMETER(PAR.Default_Printer);
 PARAMETER(PAR.Salesperson_Code);
 {
  //?Execute internal function

  //?RMC 5/11/09 Rtv default company from user profile --
  //?  Override user code model company if it exists
  EXECUTE FUNCTION(RTV Program Setup w/Co RT) TYPE(RTVOBJ) FILE(CADRREP)          AC1935572;
  PARAMETER(PAR.User_Profile_Name);
  PARAMETER(PAR.Allow_Multi_Company);
  PARAMETER(PAR.Default_Printer);
  PARAMETER(PAR.Salesperson_Code);
  PARAMETER(LCL.Company_Number);
  PARAMETER(PAR.User_Code_Model);
  {
   //?USER: Processing if Data record not found

   // PGM.*Return code = CND.*Record does not exist
   PGM.*Return_code = 'Y2U0005';

   //?USER: Process Data record

   MOVE *ALL (To: PAR From: DB1);

  }

  //?User Profile Record Not found
  CASE;

  // IF PGM.*Return code is *Record does not exist
  IF PGM.*Return_code = 'Y2U0005';

  // Execute function SET Message Queue Dest US.
  EXECUTE FUNCTION(SET Message Queue Dest US) TYPE(EXCUSRSRC) ('USNCUFR');
  {
   C                     MOVEL'*PRV '   ZAPGRL           PREVIOUS
  }

  // Send completion message - 'Application access denied for user &1 in application area &2'
  MESSAGE(USR0810 *COMPLETION);
  MSGPARM(PAR.User_Profile_Name);
  MSGPARM(PAR.Application_Code);

  PGM.*Return_code = 'Y2U9999';

  RETURN;

  ENDIF;

  CASE;

  // IF PAR.User Code Model is equal to blank
  IF PAR.User_Code_Model = *BLANK;

  EXECUTE FUNCTION(RTV Appl. Profile      RT) TYPE(RTVOBJ) FILE(CADTREP)          AC1143177;
  PARAMETER(PAR.User_Profile_Name);
  PARAMETER(PAR.Application_Code);
  PARAMETER(PAR.Company_Number);
  PARAMETER(LCL.Warehouse_Code);
  {
   //?USER: Process Data record

   MOVE *ALL (To: PAR From: DB1);

  }

  // IF *OTHERWISE
  IF *OTHERWISE;

  EXECUTE FUNCTION(RTV Appl. Profile      RT) TYPE(RTVOBJ) FILE(CADTREP)          AC1143177;
  PARAMETER(PAR.User_Code_Model);
  PARAMETER(PAR.Application_Code);
  PARAMETER(PAR.Company_Number);
  PARAMETER(LCL.Warehouse_Code);
  {
   //?USER: Process Data record

   MOVE *ALL (To: PAR From: DB1);

  }

  ENDIF;

  // PAR.Warehouse Code = LCL.Warehouse Code
  PAR.Warehouse_Code = LCL.Warehouse_Code;

  //?Return code when not normal for Application Profile
  CASE;

  // IF PGM.*Return code is *Normal
  IF PGM.*Return_code = *BLANK;

  //?Return code when not normal for Application Profile
  // IF *OTHERWISE
  IF *OTHERWISE;

  // Execute function SET Message Queue Dest US.
  EXECUTE FUNCTION(SET Message Queue Dest US) TYPE(EXCUSRSRC) ('USNCUFR');
  {
   C                     MOVEL'*PRV '   ZAPGRL           PREVIOUS
  }

  // Send completion message - 'Application access denied for user &1 in application area &2'
  MESSAGE(USR0810 *COMPLETION);
  MSGPARM(PAR.User_Profile_Name);
  MSGPARM(PAR.Application_Code);

  PGM.*Return_code = 'Y2U9999';

  RETURN;

  ENDIF;

  //?Override company with User profile control's company if found
  CASE;

  // IF LCL.Company Number is not equal to zero
  IF LCL.Company_Number <> *ZERO;

  // PAR.Company Number = LCL.Company Number
  PAR.Company_Number = LCL.Company_Number;

  //?Get prod warehouse, if the appl got a warehouse
  CASE;

  // IF LCL.Warehouse Code is Not Blanks
  IF LCL.Warehouse_Code <> *BLANK;

  // Call program RTV Prod Whse for Co  XF.
  CALL PROGRAM(RTV Prod Whse for Co  XF) ('PNKDXFR');
  PARAMETER(PAR.Warehouse_Code);
  PARAMETER(LCL.Company_Number);

  ENDIF;

  ENDIF;

 }

 EXECUTE FUNCTION(SET Screen Headings    IF) TYPE(EXCINTFUN)                     AC1248058;
 PARAMETER(PAR.Application_Code);
 {
  //?Execute internal function

  EXECUTE FUNCTION(RTV Applic. Group Desc RT) TYPE(RTVOBJ) FILE(CADNREP)          AC1274118;
  PARAMETER(PAR.Application_Code);
  PARAMETER(WRK.Description);
  {
   //?USER: Process Data record

   CASE;

   // IF DB1.Application Group is Blank
   IF DB1.Application_Group = *BLANK;

   MOVE *ALL (To: PAR From: DB1);

   // IF *OTHERWISE
   IF *OTHERWISE;

   EXECUTE FUNCTION(RTV Application Desc   RT) TYPE(RTVOBJ) FILE(CADNREP)          AC1249881;
   PARAMETER(DB1.Application_Group);
   PARAMETER(PAR.Description);
   {
    //?USER: Processing if Data record not found

    MOVE *ALL (To: PAR From: CON);

    // PGM.*Return code = CND.*Record does not exist
    PGM.*Return_code = 'Y2U0005';

    //?USER: Process Data record

    MOVE *ALL (To: PAR From: DB1);

   }

   ENDIF;

  }

  // WRK.USR Description 40 = WRK.Description
  WRK.USR_Description_40 = WRK.Description;

  // Execute function CLC Center Txt Str 40  US.
  EXECUTE FUNCTION(CLC Center Txt Str 40  US) TYPE(EXCUSRSRC) ('PDYJUFR');
  PARAMETER(WRK.USR_Description_40);
  PARAMETER(WRK.USR_Description_40_2);
  {
   E                    UCT        40  1               CENTER TABLE
   C                     MOVEA#IDSC4    UCT              LOAD ARRAY
   C                     Z-ADD40        UX      20       SET COUNTER
   C           UX        DOWGT0
   C           UCT,UX    IFEQ ' '
   C                     SUB  1         UX
   C                     ELSE
   C                     Z-ADDUX        UXH     20
   C                     Z-ADD0         UX
   C                     END
   C                     END
   C           40        SUB  UXH       UX
   C           UX        DIV  2         UX
   C           UX        IFGT 0
   C                     MOVE *BLANKS   UCT
   C                     MOVEA#IDSC4    UCT,UX
   C                     END
   C                     MOVEAUCT       #ODE40           LOAD OUTPUT
  }

  // Execute function MOV Appl Desc-Co Head  US.
  EXECUTE FUNCTION(MOV Appl Desc-Co Head  US) TYPE(EXCUSRSRC) ('PDYKUFR');
  PARAMETER(WRK.USR_Description_40_2);
  {
   C                     MOVE #IDE40    ##CMP
  }

 }

}


//?USER: Process command keys

//?F7=Work With Commodity Market
CASE;

// IF DTL.*CMD key is CF07
IF DTL.*CMD_key = '07';

// Call program WW Commod Mrkt/Price   DF.
CALL PROGRAM(WW Commod Mrkt/Price   DF) ('PDEQDFR');

ENDIF;

//?F8=Display Customer Accruals
CASE;

// IF DTL.*CMD key is CF08
IF DTL.*CMD_key = '08';

CASE;

// IF DTL.Ship To Customer is equal to zero
IF DTL.Ship_To_Customer = *ZERO;

// Send error message - 'Ship To Customer Required'
ERROR(USR4306);
MSGPARM(DTL.Ship_To_Customer);

// IF *OTHERWISE
IF *OTHERWISE;

// Call program WW Cust Accruals-Dsp  DF.
CALL PROGRAM(WW Cust Accruals-Dsp  DF) ('PPB2DFR');
PARAMETER(DTL.Ship_To_Customer);

ENDIF;

ENDIF;

//?USER: Validate fields

CASE;

// IF DTL.*CMD key is *Prompt
IF DTL.*CMD_key = '04';

//?Date Method Code
CASE;

// IF PGM.*Cursor field <IS> DTL.Date Method Code
IF PGM.*Cursor_field = DTL.Date_Method_Code;

// Call program Sel Market Date Method SR.
CALL PROGRAM(Sel Market Date Method SR) ('PDKISRR');
PARAMETER(DTL.Company_Number);
PARAMETER(DTL.Date_Method_Code);

ENDIF;

//?Ship To Customer
CASE;

// IF PGM.*Cursor field <IS> DTL.Ship To Customer
IF PGM.*Cursor_field = DTL.Ship_To_Customer;

// Call program SEL Cust/ShpTo Flag 'Y'SR.
CALL PROGRAM(SEL Cust/ShpTo Flag 'Y'SR) ('PDYSSRR');
PARAMETER(DTL.Ship_To_Customer);

ENDIF;

//?Item Code
CASE;

// IF PGM.*Cursor field <IS> DTL.Item Code
IF PGM.*Cursor_field = DTL.Item_Code;

// Call program SEL Item Default FG    SR.
CALL PROGRAM(SEL Item Default FG    SR) ('POMYSRR');
PARAMETER(DTL.Item_Code);

ENDIF;

//?Order Number/Seq/SecSeq
CASE;

// IF PGM.*Cursor field <IS> DTL.Order Number
IF PGM.*Cursor_field = DTL.Order_Number;

// OR PGM.*Cursor field <IS> DTL.Order Sequence Number
OR PGM.*Cursor_field = DTL.Order_Sequence_Number;

// OR PGM.*Cursor field <IS> DTL.Order Secondary Line Seq
OR PGM.*Cursor_field = DTL.Order_Secondary_Line_Seq;

// Call program Zzz Order Detail      SR.
CALL PROGRAM(Zzz Order Detail      SR) ('PNRBSRR');
PARAMETER(DTL.Company_Number);
PARAMETER(DTL.Order_Number);
PARAMETER(DTL.Requested_Delivery_Date);
PARAMETER(DTL.Order_Sequence_Number);
PARAMETER(DTL.Order_Secondary_Line_Seq);
PARAMETER(DTL.Item_Code);
PARAMETER(PAR.Warehouse_Code);
PARAMETER(DTL.Ship_To_Customer);
PARAMETER(DTL.Market_Pricing_Date);
PARAMETER(DTL.Commodity_Market_Code);
PARAMETER(DTL.Date_Method_Code);
PARAMETER(DTL.Price_Method_Code);
PARAMETER(DTL.Price_Overage_Override);
PARAMETER(DTL.Requested_Ship_Date);
PARAMETER(DTL.Actual_Shipped_Date);
PARAMETER(DTL.OD_Ceiling_Price);
PARAMETER(DTL.OD_Market_Begin_Date);
PARAMETER(DTL.OD_Market_Ending_Date);

ENDIF;

//?Price Code
CASE;

// IF PGM.*Cursor field <IS> DTL.Price Code
IF PGM.*Cursor_field = DTL.Price_Code;

CASE;

// IF DTL.Ship To Customer is equal to zero
IF DTL.Ship_To_Customer = *ZERO;

// Send error message - 'Ship To Customer Required'
ERROR(USR4306);
MSGPARM(DTL.Ship_To_Customer);

// IF *OTHERWISE
IF *OTHERWISE;

// Call program Sel Customer Prc Hdr  SL.
CALL PROGRAM(Sel Customer Prc Hdr  SL) ('POPOSRR');
PARAMETER(DTL.Ship_To_Customer);
PARAMETER(DTL.Price_Code);

ENDIF;

ENDIF;

ENDIF;

EXECUTE FUNCTION(Val Manual Price      RT) TYPE(RTVOBJ) FILE(CABZREP)           AC1581694;
PARAMETER(DTL.Company_Number);
PARAMETER(DTL.Item_Code);
PARAMETER(LCL.Description_Line_One);
PARAMETER(LCL.Default_Commod_Mark_basis);
PARAMETER(LCL.Market_Overage);
PARAMETER(LCL.Standard_Overage_Underage);
PARAMETER(DTL.Commodity_Price_Group);
PARAMETER(LCL.Std_Weight_Head_Var_Ren);
PARAMETER(LCL.Primal_Group_Code);
{
 //?USER: Processing if Data record not found

 MOVE *ALL (To: PAR From: CON);

 //?USER: Process Data record

 MOVE *ALL (To: PAR From: DB1);

}


EXECUTE FUNCTION(RTV Item Pricing Info  RT) TYPE(RTVOBJ) FILE(CABZREP)          AC1412083;
PARAMETER(DTL.Company_Number);
PARAMETER(DTL.Item_Code);
PARAMETER(LCL.U_M_Ordered);
PARAMETER(NLL.Conversion_Factor_1);
PARAMETER(NLL.Operation_Factor_1);
PARAMETER(NLL.UOM_Second);
PARAMETER(NLL.Conversion_Factor_2);
PARAMETER(NLL.Operation_Factor_2);
PARAMETER(NLL.UOM_Third);
PARAMETER(LCL.U_M_Base_Price);
PARAMETER(NLL.Unit_Weight);
PARAMETER(NLL.Production_Date_Control);
PARAMETER(NLL.Catch_Weight_Status);
PARAMETER(NLL.Default_Commod_Mark_basis);
PARAMETER(NLL.Commodity_Price_Group);
{
 //?USER: Process Data record

 MOVE *ALL (To: PAR From: DB1);

}


//?R12926 DN 05/03/18-Commented Absorbed Freight Rate here.
EXECUTE FUNCTION(RTV AbsFrtRt/Type Cde  RT) TYPE(RTVOBJ) FILE(CAEOREP)          AC1582615;
PARAMETER(DTL.Company_Number);
PARAMETER(DTL.Ship_To_Customer);
PARAMETER(LCL.Type_Code);
PARAMETER(NLL.Absorbed_Freight_Rate_CWT);
{
 //?USER: Processing if Data record not found

 MOVE *ALL (To: PAR From: CON);

 //?USER: Process Data record

 MOVE *ALL (To: PAR From: DB1);

}


//?R12926 DN 05/03/18-If Order<>0 use AFR from OH else use it from Co Cust.
CASE;

// IF DTL.Order Number is Not equal to zeros
IF DTL.Order_Number <> *ZERO;

EXECUTE FUNCTION(Rtv Absorbed Frt Rate RT) TYPE(RTVOBJ) FILE(OPBFCPP)           AC2149231;
PARAMETER(DTL.Company_Number);
PARAMETER(DTL.Order_Number);
PARAMETER(LCL.Absorbed_Freight_Rate_CWT);
{
 //?USER: Initialize routine

 MOVE *ALL (To: PAR From: CON);

 //?USER: Process Data record

 MOVE *ALL (To: PAR From: DB1);

}


//?R12926 DN 05/03/18-If Order<>0 use AFR from OH else use it from Co Cust.
// IF *OTHERWISE
IF *OTHERWISE;

EXECUTE FUNCTION(RTV AbsFrtRt/Type Cde  RT) TYPE(RTVOBJ) FILE(CAEOREP)          AC1582615;
PARAMETER(DTL.Company_Number);
PARAMETER(DTL.Ship_To_Customer);
PARAMETER(LCL.Type_Code);
PARAMETER(LCL.Absorbed_Freight_Rate_CWT);
{
 //?USER: Processing if Data record not found

 MOVE *ALL (To: PAR From: CON);

 //?USER: Process Data record

 MOVE *ALL (To: PAR From: DB1);

}


ENDIF;

EXECUTE FUNCTION(Rtv Price Method Info RT) TYPE(RTVOBJ) FILE(PDIHREP)           AC1985066;
PARAMETER(DTL.Company_Number);
PARAMETER(DTL.Price_Method_Code);
PARAMETER(DTL.Price_Method_Description);
PARAMETER(DTL.Price_Audit);
PARAMETER(DTL.Price_Method_Type);
PARAMETER(DTL.System_Using_Price_Method);
PARAMETER(DTL.Decimal_Places_Rounded);
PARAMETER(DTL.PMH_Price_Type);
{
 //?USER: Processing if Data record not found

 MOVE *ALL (To: PAR From: CON);

 //?USER: Process Data record

 MOVE *ALL (To: PAR From: DB1);

}


EXECUTE FUNCTION(Edt OD Pricing Validt IF) TYPE(EXCINTFUN)                      AC1994988;
PARAMETER(DTL.Company_Number);
PARAMETER(DTL.Order_Number);
PARAMETER(DTL.Item_Code);
PARAMETER(DTL.Market_Pricing_Date);
PARAMETER(DTL.Commodity_Market_Code);
PARAMETER(DTL.Date_Method_Code);
PARAMETER(DTL.Price_Method_Code);
PARAMETER(DTL.Price_Overage_Override);
PARAMETER(LCL.U_M_Base_Price);
PARAMETER(PAR.Quantity_Ordered);
PARAMETER(*ZERO);
PARAMETER(DTL.Unit_Price_Credit);
PARAMETER(*ZERO);
PARAMETER(DTL.Requested_Ship_Date);
PARAMETER(DTL.Price_Code);
PARAMETER(DTL.OD_Ceiling_Price);
PARAMETER(DTL.OD_Market_Begin_Date);
PARAMETER(DTL.OD_Market_Ending_Date);
PARAMETER(DTL.Ship_To_Customer);
PARAMETER(LCL.Type_Code);
PARAMETER(LCL.Default_Commod_Mark_basis);
PARAMETER(LCL.Market_Overage);
PARAMETER(DTL.Commodity_Price_Group);
PARAMETER(LCL.Primal_Group_Code);
PARAMETER(LCL.Absorbed_Freight_Rate_CWT);
PARAMETER(1);
PARAMETER(LCL.USR_Display_4);
PARAMETER(LCL.Error_Status);
{
 //?Execute internal function

 // PAR.Unit Price - Credit = CON.*ZERO
 PAR.Unit_Price_Credit = *ZERO;

 // Call program RTV PrcMthTyp/PrcTyp  XF.
 CALL PROGRAM(RTV PrcMthTyp/PrcTyp  XF) ('PNS7XFR');
 PARAMETER(PAR.Company_Number);
 PARAMETER(PAR.Price_Method_Code);
 PARAMETER(LCL.Price_Method_Type);
 PARAMETER(LCL.PMH_Price_Type);

 // Call program Rtv Market Dtls OrEnt XF.
 CALL PROGRAM(Rtv Market Dtls OrEnt XF) ('PNS1XFR');
 PARAMETER(PAR.Item_Code);
 PARAMETER(PAR.Commodity_Market_Code);
 PARAMETER(LCL.Commodity_Price_Group);
 PARAMETER(LCL.Market_Prem_Ded);
 PARAMETER(LCL.Record_Found_USR);

 // PAR.USR Display 4 = CND.No
 PAR.USR_Display_4 = 'N';

 //?LCL.Commodity Price Group & LCL.Market Overage
 CASE;

 // IF LCL.Record Found USR is Record Found
 IF LCL.Record_Found_USR = 'Y';

 // LCL.Market Overage = LCL.Market Prem/Ded
 LCL.Market_Overage = LCL.Market_Prem_Ded;

 //?LCL.Commodity Price Group & LCL.Market Overage
 // IF *OTHERWISE
 IF *OTHERWISE;

 // LCL.Commodity Price Group = PAR.Commodity Price Group
 LCL.Commodity_Price_Group = PAR.Commodity_Price_Group;

 // LCL.Market Overage = PAR.Market Overage
 LCL.Market_Overage = PAR.Market_Overage;

 ENDIF;

 //?VAL: Price Method Code
 CASE;

 // IF PAR.Price Method Code is Blank
 IF PAR.Price_Method_Code = *BLANK;

 // PAR.Error Status = CND.yes
 PAR.Error_Status = 'Y';

 // Send error message - 'Value Required.'
 ERROR(USR2808);
 MSGPARM(PAR.Price_Method_Code);

 ENDIF;

 //?VAL: Price Code
 CASE;

 // IF PAR.Price Code is Entered
 IF PAR.Price_Code > *ZERO;

 //?VAL: Price Code
 CASE;

 // IF LCL.Price Method Type is Not Contract
 IF LCL.Price_Method_Type = 'X'/'F'/'M'/'K';

 // PAR.Error Status = CND.yes
 PAR.Error_Status = 'Y';

 // Send error message - 'Price code invalid for Pricing Method &2. Price Code must be zero,'
 ERROR(USR4338);
 MSGPARM(PAR.Price_Code);
 MSGPARM(PAR.Price_Method_Code);

 CASE;

 // IF PAR.USR Display 4 is No
 IF PAR.USR_Display_4 = 'N';

 // PAR.USR Display 4 = CND.Yes
 PAR.USR_Display_4 = 'Y';

 ENDIF;

 //?VAL: Price Code
 // IF *OTHERWISE
 IF *OTHERWISE;

 // Call program Rtv Cust Prc Str/End  XF.
 CALL PROGRAM(Rtv Cust Prc Str/End  XF) ('PNTAXFR');
 PARAMETER(PAR.Ship_To_Customer);
 PARAMETER(PAR.Price_Code);
 PARAMETER(LCL.Price_Start_Date);
 PARAMETER(LCL.Price_End_Date);

 CASE;

 // IF LCL.Price Start Date is Not Entered
 IF LCL.Price_Start_Date = *ZERO;

 // PAR.Error Status = CND.yes
 PAR.Error_Status = 'Y';

 // Send error message - 'Price Code &1 not found for customer or invalid date range.'
 ERROR(USR3318);
 MSGPARM(PAR.Price_Code);

 // IF *OTHERWISE
 IF *OTHERWISE;

 //?VAL: Contract Start & End Date
 CASE;

 // IF PAR.Scheduled Ship Date LT LCL.Price Start Date
 IF PAR.Scheduled_Ship_Date < LCL.Price_Start_Date;

 // OR PAR.Scheduled Ship Date GT LCL.Price End Date
 OR PAR.Scheduled_Ship_Date > LCL.Price_End_Date;

 // PAR.Error Status = CND.yes
 PAR.Error_Status = 'Y';

 // Send error message - 'Price Code &1 not valid because of start/end dates.'
 ERROR(USR3317);
 MSGPARM(PAR.Price_Code);

 ENDIF;

 // Call program Rtv Max Wt and price  XF.
 CALL PROGRAM(Rtv Max Wt and price  XF) ('PNTBXFR');
 PARAMETER(PGM.*Return_code);
 PARAMETER(PAR.Ship_To_Customer);
 PARAMETER(PAR.Price_Code);
 PARAMETER(PAR.Item_Code);
 PARAMETER(LCL.Maximum_Contract_Units);
 PARAMETER(LCL.Customer_Price_UM_Prc);
 PARAMETER(LCL.Commodity_Market_Code_USR);
 PARAMETER(LCL.Price_Method_Code_USR);
 PARAMETER(LCL.Date_Method_Code_USR);
 PARAMETER(LCL.Contract_Unit_Type);

 CASE;

 // IF PGM.*Return code is *Record does not exist
 IF PGM.*Return_code = 'Y2U0005';

 // PAR.Error Status = CND.yes
 PAR.Error_Status = 'Y';

 // Send error message - 'Price Code &1 not found for Item &2'
 ERROR(USR3319);
 MSGPARM(PAR.Price_Code);
 MSGPARM(PAR.Item_Code);

 // IF *OTHERWISE
 IF *OTHERWISE;

 //?Sum weights shipped/ordered for ship to /price code
 EXECUTE FUNCTION(Clc Sum Ship/Ord Unit IF) TYPE(EXCINTFUN)                      AC1829994;
 PARAMETER(PAR.Company_Number);
 PARAMETER(PAR.Order_Number);
 PARAMETER(PAR.Item_Code);
 PARAMETER(PAR.Ship_To_Customer);
 PARAMETER(PAR.Commodity_Market_Code);
 PARAMETER(PAR.Date_Method_Code);
 PARAMETER(PAR.Price_Method_Code);
 PARAMETER(PAR.Price_Overage_Override);
 PARAMETER(PAR.U_M_Base_Price);
 PARAMETER(PAR.Quantity_Ordered);
 PARAMETER(PAR.Unit_Weight_Ordered_U_M);
 PARAMETER(PAR.Price_Code);
 PARAMETER(PAR.OD_Ceiling_Price);
 PARAMETER(PAR.Error_Status);
 PARAMETER(LCL.Price_Method_Type);
 PARAMETER(LCL.PMH_Price_Type);
 {
  //?Execute internal function

  // PAR.Error Status = CND.no
  PAR.Error_Status = 'N';

  // LCL.Weight Ordered = PAR.Quantity Ordered * PAR.Unit Weight Ordered U/M *
  LCL.Weight_Ordered = PAR.Quantity_Ordered * PAR.Unit_Weight_Ordered_U_M;

  // Call program CLC Sum Ship/Ord Unit XF.
  CALL PROGRAM(CLC Sum Ship/Ord Unit XF) ('PPA6XFR');
  PARAMETER(PAR.Ship_To_Customer);
  PARAMETER(PAR.Price_Code);
  PARAMETER(PAR.Item_Code);
  PARAMETER(PAR.Total_Weight_Ordered_USR);
  PARAMETER(PAR.Order_Number);
  PARAMETER(PAR.Total_Quantity_Ordered);

  // PAR.Total Weight Ordered USR = PAR.Total Weight Ordered USR + LCL.Weight Ordered
  PAR.Total_Weight_Ordered_USR = PAR.Total_Weight_Ordered_USR + LCL.Weight_Ordered;

  // PAR.Total Quantity Ordered = PAR.Total Quantity Ordered + PAR.Quantity Ordered
  PAR.Total_Quantity_Ordered = PAR.Total_Quantity_Ordered + PAR.Quantity_Ordered;

  //?5/13/10 SAZ P205-Add parm for Max Unit Type;rtv Contract Unit Type
  // Call program Rtv Cust Prc hdr/dtl  XF.
  CALL PROGRAM(Rtv Cust Prc hdr/dtl  XF) ('PPA7XFR');
  PARAMETER(PAR.Ship_To_Customer);
  PARAMETER(PAR.Price_Code);
  PARAMETER(WRK.Price_Start_Date);
  PARAMETER(WRK.Price_End_Date);
  PARAMETER(PAR.Item_Code);
  PARAMETER(PAR.Maximum_Contract_Units);
  PARAMETER(PAR.Customer_Price_UM_Prc);
  PARAMETER(PAR.Commodity_Market_Code);
  PARAMETER(LCL.Price_Method_Code);
  PARAMETER(PAR.Date_Method_Code);
  PARAMETER(PAR.Contract_Unit_Type);

  // PAR.Price Method Code = LCL.Price Method Code
  PAR.Price_Method_Code = LCL.Price_Method_Code;

  EXECUTE FUNCTION(RTV PrcMthTyp/PrcTyp  RT) TYPE(RTVOBJ) FILE(PDIHREP)           AC1997170;
  PARAMETER(PAR.Company_Number);
  PARAMETER(LCL.Price_Method_Code);
  PARAMETER(PAR.Price_Method_Type);
  PARAMETER(PAR.PMH_Price_Type);
  {
   //?USER: Processing if Data record not found

   MOVE *ALL (To: PAR From: CON);

   //?USER: Process Data record

   MOVE *ALL (To: PAR From: DB1);

  }

  //?5/13/10 SAZ P205-Use Contract Unit Type to check Qty or Weight-Lbs
  //?Use Contract Unit Type to check Qty or Weight-Lbs
  //?VAL: Total Weight and Quantity w/Maximum
  CASE;

  // IF PAR.Contract Unit Type is Weight-LB
  IF PAR.Contract_Unit_Type = 'W';

  CASE;

  // IF PAR.Total Weight Ordered USR GT PAR.Maximum Contract Units
  IF PAR.Total_Weight_Ordered_USR > PAR.Maximum_Contract_Units;

  // PAR.Error Status = CND.yes
  PAR.Error_Status = 'Y';

  // LCL.Weight Allocated USR = PAR.Total Weight Ordered USR - PAR.Maximum Contract Units
  LCL.Weight_Allocated_USR = PAR.Total_Weight_Ordered_USR - PAR.Maximum_Contract_Units;

  // Send error message - 'Max Units &3 for Item &4/Price Code &1 exceeded by &2.'
  ERROR(USR3320);
  MSGPARM(PAR.Price_Code);
  MSGPARM(LCL.Weight_Allocated_USR);
  MSGPARM(PAR.Maximum_Contract_Units);
  MSGPARM(PAR.Item_Code);

  ENDIF;

  //?VAL: Total Weight and Quantity w/Maximum
  // IF *OTHERWISE
  IF *OTHERWISE;

  //?If Contract Unit type = Quantity
  CASE;

  // IF PAR.Total Quantity Ordered GT PAR.Maximum Contract Units
  IF PAR.Total_Quantity_Ordered > PAR.Maximum_Contract_Units;

  // PAR.Error Status = CND.yes
  PAR.Error_Status = 'Y';

  // LCL.Weight Allocated USR = PAR.Total Quantity Ordered - PAR.Maximum Contract Units
  LCL.Weight_Allocated_USR = PAR.Total_Quantity_Ordered - PAR.Maximum_Contract_Units;

  // Send error message - 'Max Units &3 for Item &4/Price Code &1 exceeded by &2.'
  ERROR(USR3320);
  MSGPARM(PAR.Price_Code);
  MSGPARM(LCL.Weight_Allocated_USR);
  MSGPARM(PAR.Maximum_Contract_Units);
  MSGPARM(PAR.Item_Code);

  ENDIF;

  ENDIF;

  //?Original code
  //?OUT: No Errors
  CASE;

  // IF PAR.Error Status is no
  IF PAR.Error_Status = 'N';

  // PAR.Price Overage Override = PAR.Customer Price /UM Prc
  PAR.Price_Overage_Override = PAR.Customer_Price_UM_Prc;

  CASE;

  // IF PAR.PMH Price Type is Invoice Price
  IF PAR.PMH_Price_Type = 'I';

  // PAR.Price Overage Override = PAR.Customer Price /UM Prc
  PAR.Price_Overage_Override = PAR.Customer_Price_UM_Prc;

  // PAR.OD Ceiling Price = CON.*ZERO
  PAR.OD_Ceiling_Price = *ZERO;

  // IF PAR.PMH Price Type is Ceiling Price
  IF PAR.PMH_Price_Type = 'C';

  // PAR.Price Overage Override = CON.*ZERO
  PAR.Price_Overage_Override = *ZERO;

  // PAR.OD Ceiling Price = PAR.Customer Price /UM Prc
  PAR.OD_Ceiling_Price = PAR.Customer_Price_UM_Prc;

  ENDIF;

  ENDIF;

 }

 ENDIF;

 ENDIF;

 ENDIF;

 //?VAL: Price Code
 // IF *OTHERWISE
 IF *OTHERWISE;

 //?VAL: Price Code Required
 CASE;

 // IF LCL.Price Method Type is Contract Pricing
 IF LCL.Price_Method_Type = 'Q';

 // PAR.Error Status = CND.yes
 PAR.Error_Status = 'Y';

 // Send error message - 'Price code required for Pricing Method &2'
 ERROR(USR3316);
 MSGPARM(PAR.Price_Code);
 MSGPARM(PAR.Price_Method_Code);

 CASE;

 // IF PAR.USR Display 4 is No
 IF PAR.USR_Display_4 = 'N';

 // PAR.USR Display 4 = CND.Yes
 PAR.USR_Display_4 = 'Y';

 ENDIF;

 ENDIF;

 ENDIF;

 //?VAL: Market Price Date/Range
 CASE;

 // IF PAR.Market Pricing Date is NE Zero
 IF PAR.Market_Pricing_Date <> *ZERO;

 // AND PAR.OD Market Begin Date is Entered
 AND ( PAR.OD_Market_Begin_Date <> *ZERO;

 // OR PAR.OD Market Ending Date is Entered
 OR PAR.OD_Market_Ending_Date <> *ZERO );

 // PAR.Error Status = CND.yes
 PAR.Error_Status = 'Y';

 // Send error message - 'A Market Pricing Date or Market Price Date Range may be entered; not both.
 ERROR(USR4331);
 MSGPARM(PAR.Market_Pricing_Date);
 MSGPARM(PAR.OD_Market_Begin_Date);
 MSGPARM(PAR.OD_Market_Ending_Date);

 //?VAL: Market Price Date/Range
 // IF PAR.OD Market Begin Date GT PAR.OD Market Ending Date
 IF PAR.OD_Market_Begin_Date > PAR.OD_Market_Ending_Date;

 CASE;

 // IF PAR.OD Market Ending Date is not entered
 IF PAR.OD_Market_Ending_Date = *ZERO;

 // PAR.Error Status = CND.yes
 PAR.Error_Status = 'Y';

 // Send error message - 'Market Price Date Range Invalid'
 ERROR(USR4332);
 MSGPARM(PAR.OD_Market_Begin_Date);
 MSGPARM(PAR.OD_Market_Ending_Date);

 ENDIF;

 ENDIF;

 //?VAL: Price Method Type = Published
 CASE;

 // IF LCL.Price Method Type is Published Pricing
 IF LCL.Price_Method_Type = 'P';

 //?VAL: Price Overage Override
 CASE;

 // IF PAR.Price Overage Override is Not Zeros
 IF PAR.Price_Overage_Override <> *ZERO;

 // PAR.Error Status = CND.yes
 PAR.Error_Status = 'Y';

 // Send error message - 'Price Override not allowed with Price Method chosen'
 ERROR(USR1807);
 MSGPARM(PAR.Price_Overage_Override);

 ENDIF;

 // PAR.Commodity Market Code = CND.Seaboard
 PAR.Commodity_Market_Code = 'SBD';

 //?VAL: Date Method Code
 CASE;

 // IF PAR.Date Method Code is Entered
 IF PAR.Date_Method_Code <> *BLANK;

 // PAR.Error Status = CND.yes
 PAR.Error_Status = 'Y';

 // Send error message - 'Date Meth Code not allowed for Price Method chosen'
 ERROR(USR1808);
 MSGPARM(PAR.Date_Method_Code);

 ENDIF;

 //?VAL: Ceiling Price
 CASE;

 // IF PAR.OD Ceiling Price is Not Zeros
 IF PAR.OD_Ceiling_Price <> *ZERO;

 // PAR.Error Status = CND.yes
 PAR.Error_Status = 'Y';

 // Send information message - 'Ceiling Price invalid for Pricing Method. Changed Ceiling Price to Z
 MESSAGE(USR4333 *INFO);
 MSGPARM(PAR.OD_Ceiling_Price);

 ENDIF;

 //?VAL: Market Date or Date Range
 CASE;

 // IF PAR.OD Market Begin Date is Entered
 IF PAR.OD_Market_Begin_Date <> *ZERO;

 // OR PAR.OD Market Ending Date is Entered
 OR PAR.OD_Market_Ending_Date <> *ZERO;

 // PAR.Error Status = CND.yes
 PAR.Error_Status = 'Y';

 // Send error message - 'Market Pricing Date Range must be zero for Pricing Method &3.'
 ERROR(USR4344);
 MSGPARM(PAR.OD_Market_Begin_Date);
 MSGPARM(PAR.OD_Market_Ending_Date);
 MSGPARM(PAR.Price_Method_Code);

 ENDIF;

 ENDIF;

 //?VAL: Price Method Type = Manual/Extended
 CASE;

 // IF LCL.Price Method Type is Manual Pricing
 IF LCL.Price_Method_Type = 'M';

 // OR LCL.Price Method Type is Extended Pricing
 OR LCL.Price_Method_Type = 'X';

 //?VAL: Price Overage Override for Price Method Type=Extended
 CASE;

 // IF PAR.Price Overage Override is Equal zero
 IF PAR.Price_Overage_Override = *ZERO;

 // AND LCL.Price Method Type is Extended Pricing
 AND LCL.Price_Method_Type = 'X';

 // PAR.Error Status = CND.yes
 PAR.Error_Status = 'Y';

 // Send error message - 'Price Override required for price method'
 ERROR(USR1805);
 MSGPARM(PAR.Price_Overage_Override);

 ENDIF;

 //?VAL: Commodity Market Code
 CASE;

 // IF PAR.Commodity Market Code is Entered
 IF PAR.Commodity_Market_Code <> *BLANK;

 // PAR.Error Status = CND.yes
 PAR.Error_Status = 'Y';

 // Send error message - 'Market Code not allowed for Price Method chosen'
 ERROR(USR1809);
 MSGPARM(PAR.Commodity_Market_Code);

 ENDIF;

 //?VAL: Date Method Code
 CASE;

 // IF PAR.Date Method Code is Entered
 IF PAR.Date_Method_Code <> *BLANK;

 // PAR.Error Status = CND.yes
 PAR.Error_Status = 'Y';

 // Send error message - 'Date Meth Code not allowed for Price Method chosen'
 ERROR(USR1808);
 MSGPARM(PAR.Date_Method_Code);

 ENDIF;

 //?VAL: Ceiling Price
 CASE;

 // IF PAR.OD Ceiling Price is Not Zeros
 IF PAR.OD_Ceiling_Price <> *ZERO;

 // Send information message - 'Ceiling Price invalid for Pricing Method. Changed Ceiling Price to Z
 MESSAGE(USR4333 *INFO);
 MSGPARM(PAR.OD_Ceiling_Price);

 // PAR.OD Ceiling Price = CON.*ZERO
 PAR.OD_Ceiling_Price = *ZERO;

 ENDIF;

 //?VAL: Market Date or Date Range
 CASE;

 // IF PAR.Market Pricing Date is NE Zero
 IF PAR.Market_Pricing_Date <> *ZERO;

 // OR PAR.OD Market Begin Date is Entered
 OR PAR.OD_Market_Begin_Date <> *ZERO;

 // OR PAR.OD Market Ending Date is Entered
 OR PAR.OD_Market_Ending_Date <> *ZERO;

 // PAR.Error Status = CND.yes
 PAR.Error_Status = 'Y';

 // Send error message - 'Market Price Date or Market Pricing Date Range must be zero for Pricing Me
 ERROR(USR4339);
 MSGPARM(PAR.Market_Pricing_Date);
 MSGPARM(PAR.OD_Market_Begin_Date);
 MSGPARM(PAR.OD_Market_Ending_Date);
 MSGPARM(PAR.Price_Method_Code);

 ENDIF;

 //?VAL: Manual Pricing
 CASE;

 // IF LCL.Price Method Type is Manual Pricing
 IF LCL.Price_Method_Type = 'M';

 //?VAL: Manual Price Range
 CASE;

 // IF PAR.Billing Activity Type is Not Warehouse Transfer
 IF PAR.Billing_Activity_Type = '2'/'3'/'1';

 CASE;

 // IF PAR.Primal Group Code is NE Samples or Cut Loss
 IF PAR.Primal_Group_Code <> 'UNID';

 //?RMC S14013 remove chk for type n= Promo/Samples- we want them validated
 EXECUTE FUNCTION(VAL Manual Price Range IF) TYPE(EXCINTFUN)                     AC1414607;
 PARAMETER(PAR.Company_Number);
 PARAMETER(PAR.Commodity_Market_Code);
 PARAMETER(PAR.Price_Overage_Override);
 PARAMETER(LCL.Commodity_Price_Group);
 PARAMETER(LCL.Projected_Market_Price);
 PARAMETER(PAR.Default_Commod_Mark_basis);
 PARAMETER(LCL.Market_Overage);
 PARAMETER(LCL.Error_Status_3);
 PARAMETER(LCL.Minimum_Price_USR);
 PARAMETER(LCL.Maximum_Price_USR);
 PARAMETER(PAR.Absorbed_Freight_Rate_CWT);
 {
  //?Execute internal function

  //?*---------------------------------------------------------------*
  //?Documentation:
  //?This internal function will determine if a manual price entered
  //?on an order detail line is within the Manual Pricing Acceptance
  //?Percentage from the Company Control file. If it does not fall
  //?within the percentage range then the market price will be used.
  //?If no market price is found then it is a manual price error
  //?*---------------------------------------------------------------*
  // PAR.Projected Market Price = CON.*ZERO
  PAR.Projected_Market_Price = *ZERO;

  // PAR.Minimum Price   USR = CON.*ZERO
  PAR.Minimum_Price_USR = *ZERO;

  // PAR.Maximum Price  USR = CON.*ZERO
  PAR.Maximum_Price_USR = *ZERO;

  // PAR.Error Status  3 = CND.Yes
  PAR.Error_Status_3 = 'Y';

  EXECUTE FUNCTION(RTV Manual Price Accpt RT) TYPE(RTVOBJ) FILE(CAASREP)          AC1414604;
  PARAMETER(PAR.Company_Number);
  PARAMETER(PAR.Manual_Price_Accept_Prcnt);
  PARAMETER(PAR.CoPk_FdSrv_ManPrc_Acpt_PT);
  {
   //?USER: Processing if Data record not found

   // PGM.*Return code = CND.*Record does not exist
   PGM.*Return_code = 'Y2U0005';

   MOVE *ALL (To: PAR From: CON);

   //?USER: Process Data record

   MOVE *ALL (To: PAR From: DB1);

  }

  //?Food Service and Co-Pack Items
  CASE;

  // IF PAR.Default Commod Mark basis is Food Service
  IF PAR.Default_Commod_Mark_basis = 'FSV';

  // OR PAR.Default Commod Mark basis is Co-Pack
  OR PAR.Default_Commod_Mark_basis = 'CPK';

  // PAR.Manual Price Accept Prcnt = PAR.CoPk/FdSrv ManPrc Acpt%
  PAR.Manual_Price_Accept_Prcnt = PAR.CoPk_FdSrv_ManPrc_Acpt_PT;

  ENDIF;

  EXECUTE FUNCTION(RTV Market Price       RT) TYPE(RTVOBJ) FILE(OMF0CPP)          AC1199313;
  PARAMETER(PAR.Commodity_Market_Code);
  PARAMETER(PAR.Commodity_Price_Group);
  PARAMETER(9999999);
  PARAMETER(PAR.Projected_Market_Price);
  PARAMETER(WRK.USR_Date_Priced);
  {
   //?USER: Processing if Data record not found

   // PGM.*Return code = CND.*Record does not exist
   PGM.*Return_code = 'Y2U0005';

   MOVE *ALL (To: PAR From: CON);

   //?USER: Process Data record

   // PAR.Commodity Market Price = DB1.Commodity Market Price
   PAR.Commodity_Market_Price = DB1.Commodity_Market_Price;

   // PAR.USR Date Priced = DB1.Market Price Date
   PAR.USR_Date_Priced = DB1.Market_Price_Date;

   QUIT;

  }

  // Projected Market Price
  PAR.Projected_Market_Price = ( PAR.Projected_Market_Price
  + PAR.Standard_Overage_Underage ) + ( PAR.Absorbed_Freight_Rate_CWT / 100 'H' );

  //?If a market price is found for co/cust market code default
  CASE;

  // IF PGM.*Return code is *Normal
  IF PGM.*Return_code = *BLANK;

  // Minimum price allowed
  PAR.Minimum_Price_USR = ( 1 - ( PAR.Manual_Price_Accept_Prcnt / 100 'H' ) )
  * PAR.Projected_Market_Price 'H';

  // Maximum price allowed
  PAR.Maximum_Price_USR = ( ( PAR.Manual_Price_Accept_Prcnt / 100 'H' ) + 1 )
  * PAR.Projected_Market_Price 'H';

  //?If the Price Override is within the range then error status is no
  CASE;

  // IF PAR.Price Overage Override GE PAR.Minimum Price   USR
  IF PAR.Price_Overage_Override >= PAR.Minimum_Price_USR;

  // AND PAR.Price Overage Override LE PAR.Maximum Price  USR
  AND PAR.Price_Overage_Override <= PAR.Maximum_Price_USR;

  // PAR.Error Status  3 = CND.No
  PAR.Error_Status_3 = 'N';

  ENDIF;

  //?If a market price is found for co/cust market code default
  // IF *OTHERWISE
  IF *OTHERWISE;

  //?If no price for co/cust market code then use co/item market code
  EXECUTE FUNCTION(RTV Market Price       RT) TYPE(RTVOBJ) FILE(OMF0CPP)          AC1199313;
  PARAMETER(PAR.Default_Commod_Mark_basis);
  PARAMETER(PAR.Commodity_Price_Group);
  PARAMETER(9999999);
  PARAMETER(PAR.Projected_Market_Price);
  PARAMETER(WRK.USR_Date_Priced);
  {
   //?USER: Processing if Data record not found

   // PGM.*Return code = CND.*Record does not exist
   PGM.*Return_code = 'Y2U0005';

   MOVE *ALL (To: PAR From: CON);

   //?USER: Process Data record

   // PAR.Commodity Market Price = DB1.Commodity Market Price
   PAR.Commodity_Market_Price = DB1.Commodity_Market_Price;

   // PAR.USR Date Priced = DB1.Market Price Date
   PAR.USR_Date_Priced = DB1.Market_Price_Date;

   QUIT;

  }

  CASE;

  // IF PGM.*Return code is *Normal
  IF PGM.*Return_code = *BLANK;

  // Minimum price allowed
  PAR.Minimum_Price_USR = ( PAR.Manual_Price_Accept_Prcnt / 100 'H' )
  * PAR.Projected_Market_Price 'H';

  // Maximum price allowed
  PAR.Maximum_Price_USR = ( ( PAR.Manual_Price_Accept_Prcnt / 100 'H' ) + 1 )
  * PAR.Projected_Market_Price 'H';

  //?If the Price Override is within the range then error status is no
  CASE;

  // IF PAR.Price Overage Override GE PAR.Minimum Price   USR
  IF PAR.Price_Overage_Override >= PAR.Minimum_Price_USR;

  // AND PAR.Price Overage Override LE PAR.Maximum Price  USR
  AND PAR.Price_Overage_Override <= PAR.Maximum_Price_USR;

  // PAR.Error Status  3 = CND.No
  PAR.Error_Status_3 = 'N';

  ENDIF;

  // IF *OTHERWISE
  IF *OTHERWISE;

  // PAR.Projected Market Price = CON.*ZERO
  PAR.Projected_Market_Price = *ZERO;

  ENDIF;

  ENDIF;

 }

 // PAR.Unit Price - Credit = LCL.Projected Market Price
 PAR.Unit_Price_Credit = LCL.Projected_Market_Price;

 ENDIF;

 CASE;

 // IF LCL.Error Status  3 is Yes
 IF LCL.Error_Status_3 = 'Y';

 CASE;

 // IF LCL.Projected Market Price is Not Zeros
 IF LCL.Projected_Market_Price <> *ZERO;

 // Send information message - 'Price Override not within valid range, Market Price will be defaulte
 MESSAGE(USR2351 *INFO);
 MSGPARM(PAR.Price_Overage_Override);

 // IF *OTHERWISE
 IF *OTHERWISE;

 // PAR.Error Status = CND.yes
 PAR.Error_Status = 'Y';

 // Send error message - 'No price found for market &2 and group &3. Price out of range.'
 ERROR(USR2353);
 MSGPARM(PAR.Price_Overage_Override);
 MSGPARM(PAR.Commodity_Market_Code);
 MSGPARM(PAR.Commodity_Price_Group);

 ENDIF;

 ENDIF;

 ENDIF;

 ENDIF;

 ENDIF;

 //?VAL: Price Method Type = Contract
 CASE;

 // IF LCL.Price Method Type is Contract Pricing
 IF LCL.Price_Method_Type = 'Q';

 //?VAL: Commodity Market Code
 CASE;

 // IF PAR.Commodity Market Code is Entered
 IF PAR.Commodity_Market_Code <> *BLANK;

 // AND LCL.PMH Price Type is Invoice Price
 AND LCL.PMH_Price_Type = 'I';

 // PAR.Error Status = CND.yes
 PAR.Error_Status = 'Y';

 // Send error message - 'Market Code not allowed for Price Method chosen'
 ERROR(USR1809);
 MSGPARM(PAR.Commodity_Market_Code);

 ENDIF;

 //?VAL: Date Method Code
 CASE;

 // IF PAR.Date Method Code is Entered
 IF PAR.Date_Method_Code <> *BLANK;

 // AND LCL.PMH Price Type is Invoice Price
 AND LCL.PMH_Price_Type = 'I';

 // PAR.Error Status = CND.yes
 PAR.Error_Status = 'Y';

 // Send error message - 'Date Meth Code not allowed for Price Method chosen'
 ERROR(USR1808);
 MSGPARM(PAR.Date_Method_Code);

 ENDIF;

 //?VAL: Ceiling Price
 CASE;

 // IF LCL.PMH Price Type is Invoice Price
 IF LCL.PMH_Price_Type = 'I';

 //?ERR: Ceiling Price not allowed
 CASE;

 // IF PAR.OD Ceiling Price is Not Zeros
 IF PAR.OD_Ceiling_Price <> *ZERO;

 // Send information message - 'Ceiling Price invalid for Pricing Method. Changed Ceiling Price to Z
 MESSAGE(USR4333 *INFO);
 MSGPARM(PAR.OD_Ceiling_Price);

 // PAR.OD Ceiling Price = CON.*ZERO
 PAR.OD_Ceiling_Price = *ZERO;

 ENDIF;

 //?VAL: Ceiling Price
 // IF *OTHERWISE
 IF *OTHERWISE;

 //?ERR: Ceiling Price Required
 CASE;

 // IF PAR.OD Ceiling Price is Equal zero
 IF PAR.OD_Ceiling_Price = *ZERO;

 // PAR.Error Status = CND.yes
 PAR.Error_Status = 'Y';

 // Send error message - 'Ceiling Price is required for Pricing Method.'
 ERROR(USR4340);
 MSGPARM(PAR.OD_Ceiling_Price);

 ENDIF;

 // PAR.Unit Price - Credit = PAR.OD Ceiling Price
 PAR.Unit_Price_Credit = PAR.OD_Ceiling_Price;

 ENDIF;

 //?VAL: Market Date or Date Range
 CASE;

 // IF PAR.Market Pricing Date is NE Zero
 IF PAR.Market_Pricing_Date <> *ZERO;

 // OR PAR.OD Market Begin Date is Entered
 OR PAR.OD_Market_Begin_Date <> *ZERO;

 // OR PAR.OD Market Ending Date is Entered
 OR PAR.OD_Market_Ending_Date <> *ZERO;

 // PAR.Error Status = CND.yes
 PAR.Error_Status = 'Y';

 // Send error message - 'Market Price Date or Market Pricing Date Range must be zero for Pricing Me
 ERROR(USR4339);
 MSGPARM(PAR.Market_Pricing_Date);
 MSGPARM(PAR.OD_Market_Begin_Date);
 MSGPARM(PAR.OD_Market_Ending_Date);
 MSGPARM(PAR.Price_Method_Code);

 ENDIF;

 ENDIF;

 //?VAL: Price Method Type = Market/Formula
 CASE;

 // IF LCL.Price Method Type is Market or Formula
 IF LCL.Price_Method_Type = 'F'/'K';

 //?VAL: Price Overage Override
 CASE;

 // IF PAR.Price Overage Override is Not Zeros
 IF PAR.Price_Overage_Override <> *ZERO;

 // PAR.Error Status = CND.yes
 PAR.Error_Status = 'Y';

 // Send error message - 'Price Override not allowed with Price Method chosen'
 ERROR(USR1807);
 MSGPARM(PAR.Price_Overage_Override);

 ENDIF;

 //?VAL: Commodity Market Code
 CASE;

 // IF PAR.Commodity Market Code is Not Entered
 IF PAR.Commodity_Market_Code = *BLANK;

 // PAR.Error Status = CND.yes
 PAR.Error_Status = 'Y';

 // Send error message - 'Market Code must be entered for Price method chosen.'
 ERROR(USR1750);
 MSGPARM(PAR.Commodity_Market_Code);

 ENDIF;

 //?VAL: Date Method Code
 CASE;

 // IF PAR.Date Method Code is Entered
 IF PAR.Date_Method_Code <> *BLANK;

 EXECUTE FUNCTION(VAL Date Method Exists RT) TYPE(RTVOBJ) FILE(PDIPREP)          AC1365305;
 PARAMETER(PAR.Company_Number);
 PARAMETER(PAR.Date_Method_Code);
 PARAMETER(NLL.Date_Method_Description);
 PARAMETER('O');
 {
  //?USER: Processing if Data record not found

  MOVE *ALL (To: PAR From: CON);

  // PGM.*Return code = CND.*Record does not exist
  PGM.*Return_code = 'Y2U0005';

  //?USER: Process Data record

  MOVE *ALL (To: PAR From: DB1);

 }

 //?ERR: Date Method Code Invalid
 CASE;

 // IF PGM.*Return code is *Record does not exist
 IF PGM.*Return_code = 'Y2U0005';

 // PAR.Error Status = CND.yes
 PAR.Error_Status = 'Y';

 // Send error message - 'Date Method is invalid.'
 ERROR(USR2161);
 MSGPARM(PAR.Date_Method_Code);

 ENDIF;

 ENDIF;

 //?ERR: Date Method Entered & Market Price Date/Range Entered
 CASE;

 // IF PAR.Date Method Code is Entered
 IF ( PAR.Date_Method_Code <> *BLANK;

 // AND PAR.Market Pricing Date is NE Zero
 AND PAR.Market_Pricing_Date <> *ZERO );

 // OR PAR.Date Method Code is Entered
 OR ( PAR.Date_Method_Code <> *BLANK;

 // AND PAR.OD Market Begin Date is Entered
 AND PAR.OD_Market_Begin_Date <> *ZERO;

 // AND PAR.OD Market Ending Date is Entered
 AND PAR.OD_Market_Ending_Date <> *ZERO );

 // PAR.Error Status = CND.yes
 PAR.Error_Status = 'Y';

 // Send error message - 'Date Method and Market Price Date or Range are not allowed.'
 ERROR(USR2097);
 MSGPARM(PAR.Market_Pricing_Date);
 MSGPARM(PAR.Date_Method_Code);

 ENDIF;

 //?ERR: Date Method = Blank and Market Price Date/Rage = Zero
 CASE;

 // IF PAR.Date Method Code is Not Entered
 IF PAR.Date_Method_Code = *BLANK;

 // AND PAR.Market Pricing Date is EQ Zero
 AND PAR.Market_Pricing_Date = *ZERO;

 // AND PAR.OD Market Begin Date is not entered
 AND PAR.OD_Market_Begin_Date = *ZERO;

 // AND PAR.OD Market Ending Date is not entered
 AND PAR.OD_Market_Ending_Date = *ZERO;

 // PAR.Error Status = CND.yes
 PAR.Error_Status = 'Y';

 // Send error message - 'Date Method is invalid.'
 ERROR(USR2161);
 MSGPARM(PAR.Date_Method_Code);

 ENDIF;

 //?ERR: Market Price Date & Market Price Date Range Entered
 CASE;

 // IF PAR.Market Pricing Date is NE Zero
 IF PAR.Market_Pricing_Date <> *ZERO;

 // AND PAR.OD Market Begin Date is Entered
 AND ( PAR.OD_Market_Begin_Date <> *ZERO;

 // OR PAR.OD Market Ending Date is Entered
 OR PAR.OD_Market_Ending_Date <> *ZERO );

 // PAR.Error Status = CND.yes
 PAR.Error_Status = 'Y';

 // Send error message - 'A Market Pricing Date or Market Price Date Range may be entered; not both.
 ERROR(USR4331);
 MSGPARM(PAR.Market_Pricing_Date);
 MSGPARM(PAR.OD_Market_Begin_Date);
 MSGPARM(PAR.OD_Market_Ending_Date);

 ENDIF;

 //?ERR: Market Price Begin Date > Market Price Ending Date
 CASE;

 // IF PAR.OD Market Begin Date GT PAR.OD Market Ending Date
 IF PAR.OD_Market_Begin_Date > PAR.OD_Market_Ending_Date;

 // PAR.Error Status = CND.yes
 PAR.Error_Status = 'Y';

 // Send error message - 'Market Price Date Range Invalid'
 ERROR(USR4332);
 MSGPARM(PAR.OD_Market_Begin_Date);
 MSGPARM(PAR.OD_Market_Ending_Date);

 ENDIF;

 EXECUTE FUNCTION(VAL Market Cd & Group  RT) TYPE(RTVOBJ) FILE(OMF0CPP)          AC1414484;
 PARAMETER(PAR.Commodity_Market_Code);
 PARAMETER(LCL.Commodity_Price_Group);
 {
  //?USER: Processing if Data record not found

  // PGM.*Return code = CND.*Record does not exist
  PGM.*Return_code = 'Y2U0005';

  //?USER: Process Data record

  // PGM.*Return code = CND.*Normal
  PGM.*Return_code = *BLANK;

  QUIT;

 }

 //?VAL: Commodity Market Price Exists
 CASE;

 // IF PGM.*Return code is *Record does not exist
 IF PGM.*Return_code = 'Y2U0005';

 CASE;

 // IF PAR.Commodity Market Code NE PAR.Default Commod Mark basis
 IF PAR.Commodity_Market_Code <> PAR.Default_Commod_Mark_basis;

 EXECUTE FUNCTION(VAL Market Cd & Group  RT) TYPE(RTVOBJ) FILE(OMF0CPP)          AC1414484;
 PARAMETER(PAR.Default_Commod_Mark_basis);
 PARAMETER(LCL.Commodity_Price_Group);
 {
  //?USER: Processing if Data record not found

  // PGM.*Return code = CND.*Record does not exist
  PGM.*Return_code = 'Y2U0005';

  //?USER: Process Data record

  // PGM.*Return code = CND.*Normal
  PGM.*Return_code = *BLANK;

  QUIT;

 }

 //?Use Company Item
 CASE;

 // IF PGM.*Return code is *Record does not exist
 IF PGM.*Return_code = 'Y2U0005';

 // PAR.Error Status = CND.yes
 PAR.Error_Status = 'Y';

 // Send error message - 'No price can be found for market code &1 and group code &2.'
 ERROR(USR2349);
 MSGPARM(PAR.Commodity_Market_Code);
 MSGPARM(LCL.Commodity_Price_Group);

 //?Use Company Item
 // IF *OTHERWISE
 IF *OTHERWISE;

 // Send information message - 'No price found for market &1 and group &2, so market &3 will be used
 MESSAGE(USR2350 *INFO);
 MSGPARM(PAR.Commodity_Market_Code);
 MSGPARM(LCL.Commodity_Price_Group);
 MSGPARM(PAR.Default_Commod_Mark_basis);

 ENDIF;

 // IF *OTHERWISE
 IF *OTHERWISE;

 // PAR.Error Status = CND.yes
 PAR.Error_Status = 'Y';

 // Send error message - 'No price can be found for market code &1 and group code &2.'
 ERROR(USR2349);
 MSGPARM(PAR.Commodity_Market_Code);
 MSGPARM(LCL.Commodity_Price_Group);

 ENDIF;

 ENDIF;

 ENDIF;

}


//?USER: Validate relations

CASE;

// IF DTL.Commodity Market Code is Seaboard
IF DTL.Commodity_Market_Code = 'SBD';

EXECUTE FUNCTION(RTV IP Item Prcing Dt RT) TYPE(RTVOBJ) FILE(PNFZREP)           AC1981129;
PARAMETER(DTL.Item_Code);
PARAMETER(LCL.Price_Sheet_Item_Sts);
PARAMETER(LCL.IPD_Price_Sheet_Price_Mth);
{
 //?USER: Processing if Data record not found

 // PGM.*Return code = CND.*Record does not exist
 PGM.*Return_code = 'Y2U0005';

 //?USER: Process Data record

 MOVE *ALL (To: PAR From: DB1);

}


// IF *OTHERWISE
IF *OTHERWISE;

EXECUTE FUNCTION(Rtv Item Com Grp/Sts  RT) TYPE(RTVOBJ) FILE(OMBYREP)           AC1843776;
PARAMETER(DTL.Item_Code);
PARAMETER(DTL.Commodity_Price_Group);
PARAMETER(LCL.Record_Status);
{
 //?USER: Processing if Data record not found

 MOVE *ALL (To: PAR From: CON);

 //?USER: Process Data record

 MOVE *ALL (To: PAR From: DB1);

}


ENDIF;

//?USER: User defined action

// PAR.Event Called From = CND.Price Only
PAR.Event_Called_From = 99;

// DTL.Unit Price = CON.*ZERO
DTL.Unit_Price = *ZERO;

// DTL.Pricing Retrieved Amount = WRK.ZERO
DTL.Pricing_Retrieved_Amount = WRK.ZERO;

// DTL.Error Return = WRK.BLANK
DTL.Error_Return = WRK.BLANK;

// DTL.U/M - Primary = WRK.BLANK
DTL.UOM_Primary = WRK.BLANK;

// DTL.U/M - Second = WRK.BLANK
DTL.UOM_Second = WRK.BLANK;

// DTL.U/M - Third = WRK.BLANK
DTL.UOM_Third = WRK.BLANK;

// DTL.U/M - Pricing = WRK.BLANK
DTL.UOM_Pricing = WRK.BLANK;

// DTL.Price based on U/M1 S = WRK.ZERO
DTL.Price_based_on_U_M1_S = WRK.ZERO;

// DTL.Price based on U/M2 S = WRK.ZERO
DTL.Price_based_on_U_M2_S = WRK.ZERO;

// DTL.Price based on U/M3 S = WRK.ZERO
DTL.Price_based_on_U_M3_S = WRK.ZERO;

// DTL.Price Status = CND.Priced
DTL.Price_Status = 'P';

CASE;

// IF DTL.Price Method Componant is CICRDV
IF DTL.Price_Method_Componant = 'CICRDV';

// Call program RTV Pricing: CICRDV   XF.
CALL PROGRAM(RTV Pricing: CICRDV   XF) ('PNQXXFR');
PARAMETER(DTL.Company_Number);
PARAMETER(DTL.Ship_To_Customer);
PARAMETER(DTL.Actual_Shipped_Date);
PARAMETER(DTL.Requested_Delivery_Date);
PARAMETER(DTL.Pricing_Retrieved_Amount);
PARAMETER(PAR.Event_Called_From);
PARAMETER(DTL.Commodity_Price_Group);
PARAMETER(DTL.OD_Market_Begin_Date);
PARAMETER(DTL.OD_Market_Ending_Date);
PARAMETER(DTL.Error_Return);

// IF DTL.Price Method Componant is CIMSLV
IF DTL.Price_Method_Componant = 'CIMSLV';

// Call program RTV Pricing: CIMSLV   XF.
CALL PROGRAM(RTV Pricing: CIMSLV   XF) ('PNQ4XFR');
PARAMETER(DTL.Company_Number);
PARAMETER(DTL.Ship_To_Customer);
PARAMETER(DTL.Actual_Shipped_Date);
PARAMETER(DTL.Requested_Delivery_Date);
PARAMETER(DTL.Pricing_Retrieved_Amount);
PARAMETER(PAR.Event_Called_From);
PARAMETER(DTL.Commodity_Price_Group);
PARAMETER(*ZERO);
PARAMETER(*ZERO);
PARAMETER(*ZERO);
PARAMETER(DTL.OD_Market_Begin_Date);
PARAMETER(DTL.OD_Market_Ending_Date);
PARAMETER(DTL.Error_Return);

// IF *OTHERWISE
IF *OTHERWISE;

// Call program CLC Read/Proc. Detail  XF.
CALL PROGRAM(CLC Read/Proc. Detail  XF) ('PDPBXFR');
PARAMETER(DTL.Price_Method_Type);
PARAMETER(DTL.Decimal_Places_Rounded);
PARAMETER(DTL.PMH_Price_Type);
PARAMETER(DTL.Company_Number);
PARAMETER(DTL.Price_Method_Code);
PARAMETER(DTL.Ship_To_Customer);
PARAMETER(DTL.Actual_Shipped_Date);
PARAMETER(DTL.Requested_Delivery_Date);
PARAMETER(DTL.Pricing_Retrieved_Amount);
PARAMETER(02);
PARAMETER(DTL.OD_Ceiling_Price);
PARAMETER(DTL.OD_Market_Begin_Date);
PARAMETER(DTL.OD_Market_Ending_Date);
PARAMETER(DTL.Error_Return);
PARAMETER(DTL.Order_Number);
PARAMETER(DTL.Order_Sequence_Number);
PARAMETER(DTL.Order_Secondary_Line_Seq);
PARAMETER(DTL.Price_Overage_Override);
PARAMETER(DTL.UOM_Primary);
PARAMETER(DTL.UOM_Second);
PARAMETER(DTL.UOM_Third);
PARAMETER(DTL.UOM_Pricing);
PARAMETER(DTL.Price_based_on_U_M1_S);
PARAMETER(DTL.Price_based_on_U_M2_S);
PARAMETER(DTL.Price_based_on_U_M3_S);
PARAMETER('S');

ENDIF;

// DTL.Error Reason Descript 1 = Condition name of DTL.Error Return
DTL.Error_Reason_Descript_1 = RTVCND(DTL.Error_Return);

