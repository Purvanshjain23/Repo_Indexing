// ?------------------------------------------------------------------------------------------------
// ?Synon action diagram for PDTXE1R
// ?Date: 14.08.2025 Time: 03:29:55
// ?------------------------------------------------------------------------------------------------

//?USER: Initialize program

//?***** Change log and comments
DO;

//?**** MODIFICATIONS ****
//?CSTAR01 AB 05/31/2024 - Removing QRY Access Path PDNEREL6 Dependency
//?- Replaced 'Val Vndr# for Customr RT' function from 'Customer Ext'
//?- file to the function 'Val Vndr# for Customr RT' from 'Customer Master'
//?- Also, comment Rose's 04/05/2023 changes so that we can promote PDNEREL6
//?***********************
//?RMC 4/05/23 S12308 -- for 360 PAY allow change to A/R TF Exempt Sts
//?   so they can override NE to EX to dist cash to exempt for corrxs
//?***********************
//?RMC 1/11/18 S12308 -- RB/CB need to use originl order's exempt sts
//?   goto the ar hdr ext to get it
//?***********************
//?JBB 07/13/16  E6458 - Fix Duplicate Charge Back Explanations
//?- When creating the A/R Detail record for the Charge Back, write
//?  the Charge Back Reference Number to the Unused Date 3 field.
//?***********************
//?RMC 2/25/15  C3977 -- ref C3277 --
//?Make sure all trans regarding the CB have the Original inv for Cb
//?***********************
//?RMC 8/01/14  C3277
//?in CHG Header Cash Applie RT - A/R Header  *-> chg wrk.original inv for Cb
//?  to db1.original inv for CB
//?***********************
//?RMC 1/24/14  E2991
//?    Chg numbering scheme for CB to a seq# from company control
//?    Output to AR Detail and AR Header in Orig Inv for CB
//?***********************
//?** 02/15/2010 SLM C000000
//?** IF user enter the transaction from prior program then allow user
//?** to load this informaiton.
//?***********************
//?** 08/09/2010 LJB E000662
//?** For ITC only, give the user the option of entering an invalid
//?** sub-ledger. Prompt for confirmation. Allow processing to continue
//?** if user specifically enters Yes on the confirmation window.
//?***
//?** 06/14/2010 LJB C000789   Post install change - Dailys only has
//?** 5 digits for invoice numbers and they want to be able to
//?** add up to 19 or 20 shortpays on their Chargebacks.
//?***
//?** 06/07/2010 LJB C000789   Change Chargeback Ref# to output only.
//?** Create it by appending A/R Detail seq# to end of invoice#.
//?** Create the Chargeback Header record with this new invoice#.
//?** If sequence# exists in A/R Detail, increment until it is uniqye
//?** and update the PAR. & DTL. context with final result.
//?** This way the A/R Detail will stay in sync with the Header CBs.
//?***
//?** 02/18/2010 LJB E000512   If G/L Posting Code = "L" then
//?** Sub Ledger is required. Update VAL JDE Account No.s UP to accept
//?** new JDE G/L Posting Code parm
//?RMC S00877 7/22/09 Chg RTV Check invc exists  RT to chk inv sans company
//?LJB 12/18/2008 E00039  Add G/L Sub-Ledger Code to screen, validate
//?    to G/L Vendor Number in Customer EXT record. Add F4 to select
//?04/26/2008 slm Get the TF Exempt from the 1st Sales Hist
//?RMC 3/8/05 Default the trans amt & added some edits
//?RMC 3/30/05 move company down to above invoice #; added deposit time
//?***********************
ENDDO;

EXECUTE FUNCTION(VAL Set Inter. Access  IF) TYPE(EXCINTFUN)                     AC1144606;
PARAMETER('A/R');
PARAMETER(WRK.Company_Number);
PARAMETER(PAR.Warehouse_Code);
PARAMETER(PAR.Allow_Multi_Company);
PARAMETER(PAR.Default_Printer);
PARAMETER(PAR.Salesperson_Code);
{
 //?Execute internal function

 // PAR.User Profile Name = JOB.*USER
 PAR.User_Profile_Name = JOB.*USER;

 EXECUTE FUNCTION(VAL User/Application   IF) TYPE(EXCINTFUN)                     AC1144188;
 PARAMETER(PAR.User_Profile_Name);
 PARAMETER(PAR.Application_Code);
 PARAMETER(PAR.Company_Number);
 PARAMETER(PAR.Warehouse_Code);
 PARAMETER(PAR.Allow_Multi_Company);
 PARAMETER(PAR.Default_Printer);
 PARAMETER(PAR.Salesperson_Code);
 {
  //?Execute internal function

  //?RMC 5/11/09 Rtv default company from user profile --
  //?  Override user code model company if it exists
  EXECUTE FUNCTION(RTV Program Setup w/Co RT) TYPE(RTVOBJ) FILE(CADRREP)          AC1935572;
  PARAMETER(PAR.User_Profile_Name);
  PARAMETER(PAR.Allow_Multi_Company);
  PARAMETER(PAR.Default_Printer);
  PARAMETER(PAR.Salesperson_Code);
  PARAMETER(LCL.Company_Number);
  PARAMETER(PAR.User_Code_Model);
  {
   //?USER: Processing if Data record not found

   // PGM.*Return code = CND.*Record does not exist
   PGM.*Return_code = 'Y2U0005';

   //?USER: Process Data record

   MOVE *ALL (To: PAR From: DB1);

  }

  //?User Profile Record Not found
  CASE;

  // IF PGM.*Return code is *Record does not exist
  IF PGM.*Return_code = 'Y2U0005';

  // Execute function SET Message Queue Dest US.
  EXECUTE FUNCTION(SET Message Queue Dest US) TYPE(EXCUSRSRC) ('USNCUFR');
  {
   C                     MOVEL'*PRV '   ZAPGRL           PREVIOUS
  }

  // Send completion message - 'Application access denied for user &1 in application area &2'
  MESSAGE(USR0810 *COMPLETION);
  MSGPARM(PAR.User_Profile_Name);
  MSGPARM(PAR.Application_Code);

  PGM.*Return_code = 'Y2U9999';

  RETURN;

  ENDIF;

  CASE;

  // IF PAR.User Code Model is equal to blank
  IF PAR.User_Code_Model = *BLANK;

  EXECUTE FUNCTION(RTV Appl. Profile      RT) TYPE(RTVOBJ) FILE(CADTREP)          AC1143177;
  PARAMETER(PAR.User_Profile_Name);
  PARAMETER(PAR.Application_Code);
  PARAMETER(PAR.Company_Number);
  PARAMETER(LCL.Warehouse_Code);
  {
   //?USER: Process Data record

   MOVE *ALL (To: PAR From: DB1);

  }

  // IF *OTHERWISE
  IF *OTHERWISE;

  EXECUTE FUNCTION(RTV Appl. Profile      RT) TYPE(RTVOBJ) FILE(CADTREP)          AC1143177;
  PARAMETER(PAR.User_Code_Model);
  PARAMETER(PAR.Application_Code);
  PARAMETER(PAR.Company_Number);
  PARAMETER(LCL.Warehouse_Code);
  {
   //?USER: Process Data record

   MOVE *ALL (To: PAR From: DB1);

  }

  ENDIF;

  // PAR.Warehouse Code = LCL.Warehouse Code
  PAR.Warehouse_Code = LCL.Warehouse_Code;

  //?Return code when not normal for Application Profile
  CASE;

  // IF PGM.*Return code is *Normal
  IF PGM.*Return_code = *BLANK;

  //?Return code when not normal for Application Profile
  // IF *OTHERWISE
  IF *OTHERWISE;

  // Execute function SET Message Queue Dest US.
  EXECUTE FUNCTION(SET Message Queue Dest US) TYPE(EXCUSRSRC) ('USNCUFR');
  {
   C                     MOVEL'*PRV '   ZAPGRL           PREVIOUS
  }

  // Send completion message - 'Application access denied for user &1 in application area &2'
  MESSAGE(USR0810 *COMPLETION);
  MSGPARM(PAR.User_Profile_Name);
  MSGPARM(PAR.Application_Code);

  PGM.*Return_code = 'Y2U9999';

  RETURN;

  ENDIF;

  //?Override company with User profile control's company if found
  CASE;

  // IF LCL.Company Number is not equal to zero
  IF LCL.Company_Number <> *ZERO;

  // PAR.Company Number = LCL.Company Number
  PAR.Company_Number = LCL.Company_Number;

  //?Get prod warehouse, if the appl got a warehouse
  CASE;

  // IF LCL.Warehouse Code is Not Blanks
  IF LCL.Warehouse_Code <> *BLANK;

  // Call program RTV Prod Whse for Co  XF.
  CALL PROGRAM(RTV Prod Whse for Co  XF) ('PNKDXFR');
  PARAMETER(PAR.Warehouse_Code);
  PARAMETER(LCL.Company_Number);

  ENDIF;

  ENDIF;

 }

 EXECUTE FUNCTION(SET Screen Headings    IF) TYPE(EXCINTFUN)                     AC1248058;
 PARAMETER(PAR.Application_Code);
 {
  //?Execute internal function

  EXECUTE FUNCTION(RTV Applic. Group Desc RT) TYPE(RTVOBJ) FILE(CADNREP)          AC1274118;
  PARAMETER(PAR.Application_Code);
  PARAMETER(WRK.Description);
  {
   //?USER: Process Data record

   CASE;

   // IF DB1.Application Group is Blank
   IF DB1.Application_Group = *BLANK;

   MOVE *ALL (To: PAR From: DB1);

   // IF *OTHERWISE
   IF *OTHERWISE;

   EXECUTE FUNCTION(RTV Application Desc   RT) TYPE(RTVOBJ) FILE(CADNREP)          AC1249881;
   PARAMETER(DB1.Application_Group);
   PARAMETER(PAR.Description);
   {
    //?USER: Processing if Data record not found

    MOVE *ALL (To: PAR From: CON);

    // PGM.*Return code = CND.*Record does not exist
    PGM.*Return_code = 'Y2U0005';

    //?USER: Process Data record

    MOVE *ALL (To: PAR From: DB1);

   }

   ENDIF;

  }

  // WRK.USR Description 40 = WRK.Description
  WRK.USR_Description_40 = WRK.Description;

  // Execute function CLC Center Txt Str 40  US.
  EXECUTE FUNCTION(CLC Center Txt Str 40  US) TYPE(EXCUSRSRC) ('PDYJUFR');
  PARAMETER(WRK.USR_Description_40);
  PARAMETER(WRK.USR_Description_40_2);
  {
   E                    UCT        40  1               CENTER TABLE
   C                     MOVEA#IDSC4    UCT              LOAD ARRAY
   C                     Z-ADD40        UX      20       SET COUNTER
   C           UX        DOWGT0
   C           UCT,UX    IFEQ ' '
   C                     SUB  1         UX
   C                     ELSE
   C                     Z-ADDUX        UXH     20
   C                     Z-ADD0         UX
   C                     END
   C                     END
   C           40        SUB  UXH       UX
   C           UX        DIV  2         UX
   C           UX        IFGT 0
   C                     MOVE *BLANKS   UCT
   C                     MOVEA#IDSC4    UCT,UX
   C                     END
   C                     MOVEAUCT       #ODE40           LOAD OUTPUT
  }

  // Execute function MOV Appl Desc-Co Head  US.
  EXECUTE FUNCTION(MOV Appl Desc-Co Head  US) TYPE(EXCUSRSRC) ('PDYKUFR');
  PARAMETER(WRK.USR_Description_40_2);
  {
   C                     MOVE #IDE40    ##CMP
  }

 }

}


// PAR.Access Denied (Y/N) = CND.yes
PAR.Access_Denied_Y_N = 'Y';

// WRK.Transaction Amount = PAR.Transaction Amount
WRK.Transaction_Amount = PAR.Transaction_Amount;

//?USER: Initialize key screen

// KEY.Deposit Date = PAR.Deposit Date
KEY.Deposit_Date = PAR.Deposit_Date;

// KEY.Company Number = PAR.Company Number
KEY.Company_Number = PAR.Company_Number;

// KEY.Invoice Number = PAR.Invoice Number
KEY.Invoice_Number = PAR.Invoice_Number;

// KEY.Invoice Suffix = PAR.Invoice Suffix
KEY.Invoice_Suffix = PAR.Invoice_Suffix;

// KEY.Sequence Number = PAR.Sequence Number
KEY.Sequence_Number = PAR.Sequence_Number;

//?Next sequence number
CASE;

// IF PAR.Sequence Number is zero
IF PAR.Sequence_Number = *ZERO;

EXECUTE FUNCTION(RTV Next Seq. No.      RT) TYPE(RTVOBJ) FILE(ARBECPP)          AC1336580;
PARAMETER(KEY.Company_Number);
PARAMETER(KEY.Invoice_Number);
PARAMETER(KEY.Invoice_Suffix);
PARAMETER(KEY.Sequence_Number);
{
 //?USER: Processing if Data record not found

 // PAR.Sequence Number = CON.1
 PAR.Sequence_Number = 1;

 //?USER: Process Data record

 // PAR.Sequence Number = DB1.Sequence Number
 PAR.Sequence_Number = DB1.Sequence_Number;

 //?USER: Exit processing

 // PAR.Sequence Number = PAR.Sequence Number + CON.1
 PAR.Sequence_Number = PAR.Sequence_Number + 1;

}


ENDIF;

//?USER: Initialize detail screen (new record)

// DTL.Cost Center. . . . . . . = CND.Not Entered
DTL.Cost_Center = *BLANK;

// DTL.Object Account . . . . . = CND.Not Entered
DTL.Object_Account = *BLANK;

// DTL.Subsidiary . . . . . . . = CND.Not Entered
DTL.Subsidiary = *BLANK;

// DTL.G/L Account Description = CND.equal to blank
DTL.G_L_Account_Description = *BLANK;

//?** Default sub-ledger code to zeros                    E00039
// DTL.G/L Sub-Ledger Code = CND.equal to zero
DTL.G_L_Sub_Ledger_Code = *ZERO;

// DTL.Bank Code = PAR.Bank Code
DTL.Bank_Code = PAR.Bank_Code;

// KEY.Deposit Date = PAR.Deposit Date
KEY.Deposit_Date = PAR.Deposit_Date;

EXECUTE FUNCTION(RTV Company Name       RT) TYPE(RTVOBJ) FILE(CAABREP)          AC1255767;
PARAMETER(KEY.Company_Number);
PARAMETER(DTL.Company_Name);
{
 //?USER: Processing if Data record not found

 MOVE *ALL (To: PAR From: CON);

 //?USER: Process Data record

 MOVE *ALL (To: PAR From: DB1);

}


EXECUTE FUNCTION(RTV Bank Description   RT) TYPE(RTVOBJ) FILE(CAEBREP)          AC1333216;
PARAMETER(DTL.Bank_Code);
PARAMETER(DTL.Description);
{
 //?USER: Processing if Data record not found

 // PGM.*Return code = CND.*Record does not exist
 PGM.*Return_code = 'Y2U0005';

 //?USER: Process Data record

 MOVE *ALL (To: PAR From: DB1);

}


EXECUTE FUNCTION(RTV Customer Name      RT) TYPE(RTVOBJ) FILE(CABBREP)          AC1108159;
PARAMETER(PAR.AR_Customer_Number);
PARAMETER(DTL.Customer_Name);
{
 //?USER: Processing if Data record not found

 MOVE *ALL (To: PAR From: CON);

 // PGM.*Return code = CND.*Record does not exist
 PGM.*Return_code = 'Y2U0005';

 //?USER: Process Data record

 MOVE *ALL (To: PAR From: DB1);

}


EXECUTE FUNCTION(RTV Deposit Amounts    RT) TYPE(RTVOBJ) FILE(PDJ2CPP)          AC1334003;
PARAMETER(DTL.Bank_Code);
PARAMETER(DTL.Deposit_Date);
PARAMETER(DTL.Deposit_Time);
PARAMETER(PAR.Deposit_Amount);
PARAMETER(PAR.Total_Cash_Applied);
PARAMETER(PAR.Number_of_Deposit_Checks);
PARAMETER(PAR.Number_of_Applied_Checks);
{
 //?USER: Process Data record

 MOVE *ALL (To: PAR From: DB1);

}


// DTL.Deposit Amount = PAR.Deposit Amount
DTL.Deposit_Amount = PAR.Deposit_Amount;

// DTL.Total Cash Applied = PAR.Total Cash Applied
DTL.Total_Cash_Applied = PAR.Total_Cash_Applied;

// DTL.Remaining to Apply = PAR.Deposit Amount - PAR.Total Cash Applied
DTL.Remaining_to_Apply = PAR.Deposit_Amount - PAR.Total_Cash_Applied;

// DTL.Transaction Amount = PAR.Transaction Amount
DTL.Transaction_Amount = PAR.Transaction_Amount;

// DTL.Adjustment Type Code = PAR.Adjustment Type Code
DTL.Adjustment_Type_Code = PAR.Adjustment_Type_Code;

// DTL.A/R Customer Number = PAR.A/R Customer Number
DTL.AR_Customer_Number = PAR.AR_Customer_Number;

// DTL.A/R Check Number = PAR.A/R Check Number
DTL.A_R_Check_Number = PAR.A_R_Check_Number;

//?RMC 3/8/05 Trans amt > remaining to apply,then default the remaining to ap
CASE;

// IF DTL.Transaction Amount GT DTL.Remaining to Apply
IF DTL.Transaction_Amount > DTL.Remaining_to_Apply;

// OR DTL.Transaction Amount GT PAR.USR Cust Remain
OR DTL.Transaction_Amount > PAR.USR_Cust_Remain;

CASE;

// IF DTL.Remaining to Apply LT PAR.USR Cust Remain
IF DTL.Remaining_to_Apply < PAR.USR_Cust_Remain;

// DTL.Transaction Amount = DTL.Remaining to Apply
DTL.Transaction_Amount = DTL.Remaining_to_Apply;

// IF *OTHERWISE
IF *OTHERWISE;

// DTL.Transaction Amount = PAR.USR Cust Remain
DTL.Transaction_Amount = PAR.USR_Cust_Remain;

ENDIF;

ENDIF;

//?RMC 2/25/15  C3977
CASE;

// IF DTL.Invoice Suffix is Charge Backs
IF DTL.Invoice_Suffix = 'CB';

// LCL.A/R Orig Inv for CB = PAR.Original Inv for CB
LCL.A_R_Orig_Inv_for_CB = PAR.Original_Inv_for_CB;

ENDIF;

//?slm 2/14/2011 if trans from par move to entry for 1st time only
CASE;

// IF WRK.Transaction Amount is not equal to zeros
IF WRK.Transaction_Amount <> *ZERO;

// DTL.Transaction Amount = WRK.Transaction Amount
DTL.Transaction_Amount = WRK.Transaction_Amount;

// WRK.Transaction Amount = CON.*ZERO
WRK.Transaction_Amount = *ZERO;

ENDIF;

// DTL.USR Cust Remain = PAR.USR Cust Remain
DTL.USR_Cust_Remain = PAR.USR_Cust_Remain;

//?04/26/2008 slm Get the TF Exempt from the 1st Sales Hist
//?02/17/2014 RMC IF CB,dont go to sales history.dont want that sls hist rcd
//?02/22/2018 RMC S12308 for RB and CB get orig inv/order's exempt sts
CASE;

// IF PAR.Invoice Suffix is Charge Backs
IF PAR.Invoice_Suffix = 'CB';

// OR PAR.Invoice Suffix is Rebill
OR PAR.Invoice_Suffix = 'RB';

EXECUTE FUNCTION(Rtv Orig Order/Inv    RT) TYPE(RTVOBJ) FILE(PBC0CPP)           AC2146735;
PARAMETER(PAR.Company_Number);
PARAMETER(PAR.Invoice_Number);
PARAMETER(PAR.Invoice_Suffix);
PARAMETER(LCL.Attach_to_Invoice_Number);
PARAMETER(LCL.Attach_to_Order_Number);
{
 //?USER: Processing if Data record not found

 MOVE *ALL (To: PAR From: CON);

 //?USER: Process Data record

 MOVE *ALL (To: PAR From: DB1);

}


EXECUTE FUNCTION(RTV TF AR Exempt f/ordRT) TYPE(RTVOBJ) FILE(OMHSTPP)           AC2146736;
PARAMETER(PAR.Company_Number);
PARAMETER(LCL.Attach_to_Order_Number);
PARAMETER(DTL.A_R_TF_Exempt_Code);
{
 //?USER: Processing if Data record not found

 MOVE *ALL (To: PAR From: CON);

 //?USER: Process Data record

 MOVE *ALL (To: PAR From: DB1);

 QUIT;

}


CASE;

// IF DTL.A/R TF Exempt Code is *ALL values
IF DTL.A_R_TF_Exempt_Code = 'NE'/'PC'/'EC'/'EP';

// IF *OTHERWISE
IF *OTHERWISE;

// DTL.A/R TF Exempt Code = CND.Not Exempt
DTL.A_R_TF_Exempt_Code = 'NE';

ENDIF;

// IF *OTHERWISE
IF *OTHERWISE;

// Call program Rtv TF Exempt By Inv  XF.
CALL PROGRAM(Rtv TF Exempt By Inv  XF) ('PMUJXFR');
PARAMETER(PAR.Invoice_Number);
PARAMETER(DTL.A_R_TF_Exempt_Code);

ENDIF;

// Call program Rtv Plant Co/Org      XF.
CALL PROGRAM(Rtv Plant Co/Org      XF) ('PMOVXFR');
PARAMETER(KEY.Company_Number);
PARAMETER(NLL.Plant_Company_Sts);
PARAMETER(WRK.Company_Organization);

//?CSTAR01-Commenting Rose's Changes so that we can promote DDL file PDNEREL6
//?USER: Initialize detail screen (existing record)

// DTL.Bank Code = PAR.Bank Code
DTL.Bank_Code = PAR.Bank_Code;

// KEY.Deposit Date = PAR.Deposit Date
KEY.Deposit_Date = PAR.Deposit_Date;

EXECUTE FUNCTION(RTV Company Name       RT) TYPE(RTVOBJ) FILE(CAABREP)          AC1255767;
PARAMETER(DTL.Company_Number);
PARAMETER(DTL.Company_Name);
{
 //?USER: Processing if Data record not found

 MOVE *ALL (To: PAR From: CON);

 //?USER: Process Data record

 MOVE *ALL (To: PAR From: DB1);

}


EXECUTE FUNCTION(RTV Bank Description   RT) TYPE(RTVOBJ) FILE(CAEBREP)          AC1333216;
PARAMETER(DTL.Bank_Code);
PARAMETER(DTL.Description);
{
 //?USER: Processing if Data record not found

 // PGM.*Return code = CND.*Record does not exist
 PGM.*Return_code = 'Y2U0005';

 //?USER: Process Data record

 MOVE *ALL (To: PAR From: DB1);

}


EXECUTE FUNCTION(RTV Customer Name      RT) TYPE(RTVOBJ) FILE(CABBREP)          AC1108159;
PARAMETER(PAR.AR_Customer_Number);
PARAMETER(DTL.Customer_Name);
{
 //?USER: Processing if Data record not found

 MOVE *ALL (To: PAR From: CON);

 // PGM.*Return code = CND.*Record does not exist
 PGM.*Return_code = 'Y2U0005';

 //?USER: Process Data record

 MOVE *ALL (To: PAR From: DB1);

}


EXECUTE FUNCTION(RTV Deposit Amounts    RT) TYPE(RTVOBJ) FILE(PDJ2CPP)          AC1334003;
PARAMETER(DTL.Bank_Code);
PARAMETER(KEY.Deposit_Date);
PARAMETER(DB1.Deposit_Time);
PARAMETER(PAR.Deposit_Amount);
PARAMETER(PAR.Total_Cash_Applied);
PARAMETER(PAR.Number_of_Deposit_Checks);
PARAMETER(PAR.Number_of_Applied_Checks);
{
 //?USER: Process Data record

 MOVE *ALL (To: PAR From: DB1);

}


// DTL.Deposit Amount = PAR.Deposit Amount
DTL.Deposit_Amount = PAR.Deposit_Amount;

// DTL.Total Cash Applied = PAR.Total Cash Applied
DTL.Total_Cash_Applied = PAR.Total_Cash_Applied;

// DTL.Remaining to Apply = PAR.Deposit Amount - PAR.Total Cash Applied
DTL.Remaining_to_Apply = PAR.Deposit_Amount - PAR.Total_Cash_Applied;

// DTL.USR Cust Remain = PAR.USR Cust Remain
DTL.USR_Cust_Remain = PAR.USR_Cust_Remain;

//?** E00039 put the transaction amount on the screen
// DTL.Transaction Amount = PAR.Transaction Amount
DTL.Transaction_Amount = PAR.Transaction_Amount;

//?LJB 12/18/08  Trans amt > remain to apply,default remain to apply
CASE;

// IF DTL.Transaction Amount GT DTL.Remaining to Apply
IF DTL.Transaction_Amount > DTL.Remaining_to_Apply;

// OR DTL.Transaction Amount GT PAR.USR Cust Remain
OR DTL.Transaction_Amount > PAR.USR_Cust_Remain;

CASE;

// IF DTL.Remaining to Apply LT PAR.USR Cust Remain
IF DTL.Remaining_to_Apply < PAR.USR_Cust_Remain;

// DTL.Transaction Amount = DTL.Remaining to Apply
DTL.Transaction_Amount = DTL.Remaining_to_Apply;

// IF *OTHERWISE
IF *OTHERWISE;

// DTL.Transaction Amount = PAR.USR Cust Remain
DTL.Transaction_Amount = PAR.USR_Cust_Remain;

ENDIF;

ENDIF;

//?slm 2/14/2011 if trans from par move to entry for 1st time only
CASE;

// IF WRK.Transaction Amount is not equal to zeros
IF WRK.Transaction_Amount <> *ZERO;

// DTL.Transaction Amount = WRK.Transaction Amount
DTL.Transaction_Amount = WRK.Transaction_Amount;

// WRK.Transaction Amount = CON.*ZERO
WRK.Transaction_Amount = *ZERO;

ENDIF;

// DTL.G/L Vendor Number USR = DB1.G/L Sub-Ledger Code
DTL.G_L_Vendor_Number_USR = DB1.G_L_Sub_Ledger_Code;

// DTL.G/L Sub-Ledger Code = DTL.G/L Vendor Number USR
DTL.G_L_Sub_Ledger_Code = DTL.G_L_Vendor_Number_USR;

// Call program Rtv Plant Co/Org      XF.
CALL PROGRAM(Rtv Plant Co/Org      XF) ('PMOVXFR');
PARAMETER(DTL.Company_Number);
PARAMETER(NLL.Plant_Company_Sts);
PARAMETER(WRK.Company_Organization);

//?CSTAR01 - Commenting Rose's changes to promote PDNEREL6 DDL version
//?USER: Validate detail screen fields

// PAR.Error Status = CND.no
PAR.Error_Status = 'N';

// PAR.USR Adj Temp Total = CND.Zero
PAR.USR_Adj_Temp_Total = *ZERO;

// PAR.USR Cust Temp Apply = CND.Zero
PAR.USR_Cust_Temp_Apply = *ZERO;

// PAR.USR Cash Temp Appl = CND.Zero
PAR.USR_Cash_Temp_Appl = *ZERO;

//?** Validate Sub Ledger Required                       E000512
// LCL.JDE Posting Edit Code USR = CND.Ledger Required
LCL.JDE_Posting_Edit_Code_USR = 'L';

//?F13=Chart of Accounts
CASE;

// IF DTL.*CMD key is CF13
IF DTL.*CMD_key = '13';

// PAR.Company Number Alpha = CVTVAR(DTL.Company Number)
PAR.Company_Number_Alpha = CVTVAR(DTL.Company_Number);

// Call program SEL Chart of Accounts  UP.
CALL PROGRAM(SEL Chart of Accounts  UP) ('ARACTSEL');
PARAMETER(PAR.Company_Number_Alpha);
PARAMETER(DTL.Cost_Center);
PARAMETER(DTL.Object_Account);
PARAMETER(DTL.Subsidiary);
PARAMETER(DTL.G_L_ID_Code_JDE);
PARAMETER(DTL.G_L_Account_Description);
PARAMETER(WRK.Error_Return_text);

// PGM.*Reload subfile = CND.*YES
PGM.*Reload_subfile = 'Y';

ENDIF;

EXECUTE FUNCTION(RTV Adj Limits         RT) TYPE(RTVOBJ) FILE(PDJ3CPP)          AC1334715;
PARAMETER(DTL.Company_Number);
PARAMETER(DTL.Adjustment_Type_Code);
PARAMETER(DTL.Adjustment_Description);
PARAMETER(DTL.Effect_on_Account);
PARAMETER(DTL.G_L_ID_Code_JDE);
PARAMETER(PAR.Adjustment_Limit_Amount);
PARAMETER(DTL.Cash_Adj);
PARAMETER(PAR.User_Enter_G_L_Status);
{
 //?USER: Processing if Data record not found

 // PGM.*Return code = CND.*Record does not exist
 PGM.*Return_code = 'Y2U0005';

 //?USER: Process Data record

 MOVE *ALL (To: PAR From: DB1);

}


EXECUTE FUNCTION(RTV Company Name       RT) TYPE(RTVOBJ) FILE(CAABREP)          AC1255767;
PARAMETER(DTL.Company_Number);
PARAMETER(DTL.Company_Name);
{
 //?USER: Processing if Data record not found

 MOVE *ALL (To: PAR From: CON);

 //?USER: Process Data record

 MOVE *ALL (To: PAR From: DB1);

}


EXECUTE FUNCTION(RTV Bank Description   RT) TYPE(RTVOBJ) FILE(CAEBREP)          AC1333216;
PARAMETER(DTL.Bank_Code);
PARAMETER(DTL.Description);
{
 //?USER: Processing if Data record not found

 // PGM.*Return code = CND.*Record does not exist
 PGM.*Return_code = 'Y2U0005';

 //?USER: Process Data record

 MOVE *ALL (To: PAR From: DB1);

}


EXECUTE FUNCTION(RTV Check Active Adj   RT) TYPE(RTVOBJ) FILE(PDJ3CPP)          AC1399560;
PARAMETER(DTL.Company_Number);
PARAMETER(DTL.Adjustment_Type_Code);
PARAMETER(WRK.System_Control);
PARAMETER(WRK.Record_Status);
{
 //?USER: Processing if Data record not found

 // PGM.*Return code = CND.*Record does not exist
 PGM.*Return_code = 'Y2U0005';

 //?USER: Process Data record

 // PGM.*Return code = CND.*Record already exists
 PGM.*Return_code = 'Y2U0003';

 MOVE *ALL (To: PAR From: DB1);

}


//?Adjustment Code N/F
CASE;

// IF PGM.*Return code is *Record does not exist
IF PGM.*Return_code = 'Y2U0005';

// Send error message - 'AR Adjustment Type not found.'
ERROR(USR2041);
MSGPARM(DTL.Adjustment_Type_Code);

// PAR.Error Status = CND.yes
PAR.Error_Status = 'Y';

ENDIF;

// DTL.Deposit Amount = PAR.Deposit Amount
DTL.Deposit_Amount = PAR.Deposit_Amount;

//?Check for Invalid adjustment types
CASE;

// IF DTL.Adjustment Type Code is A/R Entry by Customer
IF DTL.Adjustment_Type_Code = 'ARC';

// OR DTL.Adjustment Type Code is A/R Miscellaneous Acct
OR DTL.Adjustment_Type_Code = 'ARM';

// OR DTL.Adjustment Type Code is ACM Apply Credit Memo
OR DTL.Adjustment_Type_Code = 'ACM';

// OR DTL.Adjustment Type Code is CRM Credit Memo
OR DTL.Adjustment_Type_Code = 'CRM';

// OR DTL.Adjustment Type Code is DBM Debit Memo
OR DTL.Adjustment_Type_Code = 'DBM';

// OR DTL.Adjustment Type Code is INV Invoice
OR DTL.Adjustment_Type_Code = 'INV';

// OR DTL.Adjustment Type Code is OA On Account Cash
OR DTL.Adjustment_Type_Code = 'OA';

// OR DTL.Adjustment Type Code is Rebill
OR DTL.Adjustment_Type_Code = 'RB';

// Send error message - 'Adjustment Type is invalid for this operation.'
ERROR(USR2263);
MSGPARM(DTL.Adjustment_Type_Code);

// PAR.Error Status = CND.yes
PAR.Error_Status = 'Y';

ENDIF;

//?Put in Paid or Adjusted
CASE;

// IF DTL.Cash/Adj is Adjustment Amount
IF DTL.Cash_Adj = 'ADJ';

CASE;

// IF PAR.Error Status is no
IF PAR.Error_Status = 'N';

// PAR.USR Adj Temp Total = DTL.Transaction Amount
PAR.USR_Adj_Temp_Total = DTL.Transaction_Amount;

ENDIF;

//?Put in Paid or Adjusted
// IF *OTHERWISE
IF *OTHERWISE;

EXECUTE FUNCTION(RTV Bank G/L           RT) TYPE(RTVOBJ) FILE(CAEBREP)          AC1333234;
PARAMETER(DTL.Bank_Code);
PARAMETER(PAR.G_L_ID_Code_Alpha);
{
 //?USER: Process Data record

 // PAR.G/L Alpha Code = DB1.G/L Alpha Code
 PAR.G_L_Alpha_Code = DB1.G_L_Alpha_Code;

}


// Call program Val G/L Act Cde 2 HPE XF.
CALL PROGRAM(Val G/L Act Cde 2 HPE XF) ('PKVBXFR');
PARAMETER(DTL.Company_Number);
PARAMETER(PAR.G_L_ID_Code_Alpha);
PARAMETER(DTL.G_L_Account_Description);
PARAMETER(DTL.G_L_ID_Code_JDE);
PARAMETER(WRK.G_L_Account_Type_1_USR);
PARAMETER(WRK.G_L_Account_Type_2_USR);
PARAMETER(WRK.Record_Found_USR);

// PAR.USR Cash Temp Appl = DTL.Transaction Amount
PAR.USR_Cash_Temp_Appl = DTL.Transaction_Amount;

// PAR.USR Cust Temp Apply = PAR.USR Cust Apply + DTL.Transaction Amount
PAR.USR_Cust_Temp_Apply = PAR.USR_Cust_Apply + DTL.Transaction_Amount;

ENDIF;

//?Transaction amount over the Adjustment Limit
CASE;

// IF DTL.Transaction Amount GT PAR.Adjustment Limit Amount
IF DTL.Transaction_Amount > PAR.Adjustment_Limit_Amount;

// AND PAR.Adjustment Limit Amount is Greater than zero
AND PAR.Adjustment_Limit_Amount > *ZERO;

// Send error message - 'Adj. > Adj. Limit Amount'
ERROR(USR2066);
MSGPARM(DTL.Transaction_Amount);

// PAR.Error Status = CND.yes
PAR.Error_Status = 'Y';

ENDIF;

//?If Apply more than check amount for cash
CASE;

// IF DTL.Cash/Adj is Cash Adjustment
IF DTL.Cash_Adj = 'CSH';

//?If apply more than check amount
CASE;

// IF PAR.USR Cust Temp Apply GT PAR.USR Check Amount
IF PAR.USR_Cust_Temp_Apply > PAR.USR_Check_Amount;

// OR PAR.USR Adj Temp Total GT PAR.USR Check Amount
OR PAR.USR_Adj_Temp_Total > PAR.USR_Check_Amount;

//?RMC 3/8/05 make a hard error
// Send error message - 'Amount Applied is greater than Check Amount &2'
ERROR(USR3444);
MSGPARM(DTL.Transaction_Amount);
MSGPARM(PAR.USR_Check_Amount);

// PAR.Error Status = CND.yes
PAR.Error_Status = 'Y';

ENDIF;

ENDIF;

//?Transaction amount over the Invoice $ Remaining      RMC 3/8/05
CASE;

// IF DTL.Transaction Amount GT DTL.Remaining Balance Due
IF DTL.Transaction_Amount > DTL.Remaining_Balance_Due;

// Send error message - 'Adjustment cannot be greater than Invoice $ Remaining.'
ERROR(USR3442);
MSGPARM(DTL.Transaction_Amount);

// PAR.Error Status = CND.yes
PAR.Error_Status = 'Y';

ENDIF;

//?CSTAR01 - Commenting Rose's changes to promote PDNEREL6 DDL version
// WRK.Total Cash Applied = DTL.Total Cash Applied
WRK.Total_Cash_Applied = DTL.Total_Cash_Applied;

//?error status = no calcs
CASE;

// IF PAR.Error Status is no
IF PAR.Error_Status = 'N';

// DTL.Total Cash Applied = PAR.Total Cash Applied + PAR.USR Cash Temp Appl
DTL.Total_Cash_Applied = PAR.Total_Cash_Applied + PAR.USR_Cash_Temp_Appl;

// DTL.Remaining to Apply = PAR.Deposit Amount - DTL.Total Cash Applied
DTL.Remaining_to_Apply = PAR.Deposit_Amount - DTL.Total_Cash_Applied;

// DTL.USR Cust Remain = PAR.USR Cust Remain - PAR.USR Cash Temp Appl
DTL.USR_Cust_Remain = PAR.USR_Cust_Remain - PAR.USR_Cash_Temp_Appl;

ENDIF;

//?** F4=Select G/L Vendor#                     E00039
CASE;

// IF DTL.*CMD key is *Prompt
IF DTL.*CMD_key = '04';

CASE;

// IF PGM.*Cursor field <IS> DTL.G/L Vendor Number USR
IF PGM.*Cursor_field = DTL.G_L_Vendor_Number_USR;

// Call program SEL A/R Cust W/Vendor# SR.
CALL PROGRAM(SEL A/R Cust W/Vendor# SR) ('PMFRSRR');
PARAMETER(DTL.AR_Customer_Number);
PARAMETER(DTL.G_L_Vendor_Number_USR);

ENDIF;

ENDIF;

//?User Defined G/L Code                                 E000512
CASE;

// IF PAR.User Enter G/L Status is yes
IF PAR.User_Enter_G_L_Status = 'Y';

CASE;

// IF DTL.Cost Center. . . . . . . is Not Entered
IF DTL.Cost_Center = *BLANK;

// AND DTL.Object Account . . . . . is Not Entered
AND DTL.Object_Account = *BLANK;

// AND DTL.Subsidiary . . . . . . . is Not Entered
AND DTL.Subsidiary = *BLANK;

// Send error message - 'G/L Account Must be entered.'
ERROR(USR2051);
MSGPARM(DTL.Cost_Center);
MSGPARM(DTL.Object_Account);
MSGPARM(DTL.Subsidiary);

// PAR.Error Status = CND.yes
PAR.Error_Status = 'Y';

// IF *OTHERWISE
IF *OTHERWISE;

// PAR.Company Number Alpha = CVTVAR(PAR.Company Number)
PAR.Company_Number_Alpha = CVTVAR(PAR.Company_Number);

// WRK.Error Return text = CND.Blank
WRK.Error_Return_text = *BLANK;

//?** Post Edit Code added to this function              E000512
// Call program VAL JDE Account No.s   UP.
CALL PROGRAM(VAL JDE Account No.s   UP) ('ARACTEDT');
PARAMETER(PAR.Company_Number_Alpha);
PARAMETER(DTL.Cost_Center);
PARAMETER(DTL.Object_Account);
PARAMETER(DTL.Subsidiary);
PARAMETER(DTL.G_L_ID_Code_JDE);
PARAMETER(PAR.JDE_Posting_Edit_Code_USR);
PARAMETER(DTL.G_L_Account_Description);
PARAMETER(WRK.Error_Return_text);

// PAR.G/L ID Code Alpha = DTL.G/L ID Code JDE
PAR.G_L_ID_Code_Alpha = DTL.G_L_ID_Code_JDE;

//?G/L Account Code Error
CASE;

// IF WRK.Error Return text is Error Return
IF WRK.Error_Return_text = 'ERR';

// Send error message - 'G/L Account Code is in Error'
ERROR(USR2070);
MSGPARM(WRK.G_L_Alpha_Code);

// PAR.Error Status = CND.yes
PAR.Error_Status = 'Y';

ENDIF;

//?** If G/L Posting Code = "L" then Sub Ledger is required  E000512
CASE;

// IF PAR.JDE Posting Edit Code USR EQ LCL.JDE Posting Edit Code USR
IF PAR.JDE_Posting_Edit_Code_USR = LCL.JDE_Posting_Edit_Code_USR;

//?** If Sub Ledger is zeros, see if it is required      E000512
CASE;

// IF DTL.G/L Vendor Number USR is Not Entered
IF DTL.G_L_Vendor_Number_USR = *ZERO;

// Send error message - 'G/L Sub-Ledger code (G/L Vendor #) is Required'
ERROR(USR4263);
MSGPARM(DTL.G_L_Vendor_Number_USR);

ENDIF;

//?** If G/L Posting Code = "L" then Sub Ledger is required  E000512
// IF *OTHERWISE
IF *OTHERWISE;

//?** Error if Sub Ledger is entered & not required      E000512
CASE;

// IF DTL.G/L Vendor Number USR is Entered
IF DTL.G_L_Vendor_Number_USR <> *ZERO;

// Send error message - 'G/L SubLedger Not Req'd, should be zeros'
ERROR(USR4264);
MSGPARM(DTL.G_L_Vendor_Number_USR);

ENDIF;

ENDIF;

ENDIF;

//?User Defined G/L Code                                 E000512
// IF *OTHERWISE
IF *OTHERWISE;

// Call program VAL Acct ID JDE-8 dgt  UP.
CALL PROGRAM(VAL Acct ID JDE-8 dgt  UP) ('ARACTRET');
PARAMETER(DTL.G_L_ID_Code_JDE);
PARAMETER(WRK.Cost_Center);
PARAMETER(WRK.Object_Account);
PARAMETER(WRK.Subsidiary);
PARAMETER(DTL.G_L_Account_Description);
PARAMETER(DTL.G_L_Posting_Company);
PARAMETER(PAR.JDE_Posting_Edit_Code_USR);
PARAMETER(WRK.Error_Return_text);

//?** If G/L Posting Code = "L" then Sub Ledger is required  E000512
CASE;

// IF PAR.JDE Posting Edit Code USR EQ LCL.JDE Posting Edit Code USR
IF PAR.JDE_Posting_Edit_Code_USR = LCL.JDE_Posting_Edit_Code_USR;

//?** If Sub Ledger is zeros, see if it is required      E000512
CASE;

// IF DTL.G/L Vendor Number USR is Not Entered
IF DTL.G_L_Vendor_Number_USR = *ZERO;

// Send error message - 'G/L Sub-Ledger code (G/L Vendor #) is Required'
ERROR(USR4263);
MSGPARM(DTL.G_L_Vendor_Number_USR);

ENDIF;

//?** If G/L Posting Code = "L" then Sub Ledger is required  E000512
// IF *OTHERWISE
IF *OTHERWISE;

//?** Error if Sub Ledger is entered & not required      E000512
CASE;

// IF DTL.G/L Vendor Number USR is Entered
IF DTL.G_L_Vendor_Number_USR <> *ZERO;

// Send error message - 'G/L SubLedger Not Req'd, should be zeros'
ERROR(USR4264);
MSGPARM(DTL.G_L_Vendor_Number_USR);

ENDIF;

ENDIF;

ENDIF;

//?** 08/09/2010 LJB E000662
//?** For ITC only, the user has the option of entering an invalid
//?** sub-ledger. Prompt for confirmation. Allow processing to continue
//?** if user specifically enters Yes on the confirmation window.
//?** Validate G/L Vendor number if entered     E00039
CASE;

// IF DTL.G/L Vendor Number USR is Entered
IF DTL.G_L_Vendor_Number_USR <> *ZERO;

//?CSTAR01 Change St:Replace 'Customer Ext' logical with 'Customer Master's
EXECUTE FUNCTION(Val Vndr# for Customr RT) TYPE(RTVOBJ) FILE(CABBREP)           AC2228000;
PARAMETER(DTL.AR_Customer_Number);
PARAMETER(*ZERO);
PARAMETER(DTL.G_L_Vendor_Number_USR);
{
 //?USER: Initialize routine

 // PGM.*Return code = CND.*Record does not exist
 PGM.*Return_code = 'Y2U0005';

 //?USER: Processing if Data record not found

 // PGM.*Return code = CND.*Record does not exist
 PGM.*Return_code = 'Y2U0005';

 //?USER: Process Data record

 // LCL.Customer G_L Vendor Num = CND.Not Entered
 LCL.Customer_G_L_Vendor_Num = *ZERO;

 EXECUTE FUNCTION(Rtv Broker/ GL Vendor RT) TYPE(RTVOBJ) FILE(PDNEREP)           AC1684471;
 PARAMETER(DB1.Ship_To_Customer);
 PARAMETER(LCL.Customer_G_L_Vendor_Num);
 {
  //?USER: Processing if Data record not found

  MOVE *ALL (To: PAR From: CON);

  //?USER: Process Data record

  MOVE *ALL (To: PAR From: DB1);

 }

 // PGM.*Return code = CND.*Record does not exist
 PGM.*Return_code = 'Y2U0005';

 CASE;

 // IF LCL.Customer G_L Vendor Num EQ PAR.Customer G_L Vendor Num
 IF LCL.Customer_G_L_Vendor_Num = PAR.Customer_G_L_Vendor_Num;

 // PGM.*Return code = CND.*Record already exists
 PGM.*Return_code = 'Y2U0003';

 QUIT;

 ENDIF;

}


//?CSTAR01 Changes End
CASE;

// IF PGM.*Return code is *Record does not exist
IF PGM.*Return_code = 'Y2U0005';

//?** ITC can have an invalid sub-ledger but it must be accepted  E000662
CASE;

// IF DTL.Adjustment Type Code is Inter Company
IF DTL.Adjustment_Type_Code = 'ITC';

// WRK.USR Confirm Status (Y/N) = CND.No
WRK.USR_Confirm_Status_Y_N = 'N';

// Call program PMT Allow Invld YN wndwPV.
CALL PROGRAM(PMT Allow Invld YN wndwPV) ('PNT0PVR');
PARAMETER(WRK.USR_Confirm_Status_Y_N);

//?** If User opts to allow an invalid sub-ledger, let it through   E000662
CASE;

// IF WRK.USR Confirm Status (Y/N) is Yes
IF WRK.USR_Confirm_Status_Y_N = 'Y';

// DTL.G/L Sub-Ledger Code = DTL.G/L Vendor Number USR
DTL.G_L_Sub_Ledger_Code = DTL.G_L_Vendor_Number_USR;

// PAR.Error Status = CND.no
PAR.Error_Status = 'N';

//?** If User opts to allow an invalid sub-ledger, let it through   E000662
// IF *OTHERWISE
IF *OTHERWISE;

// Send error message - 'G/L Sub-Ledger code (G/L Vendor #) is invalid'
ERROR(USR4118);
MSGPARM(DTL.G_L_Vendor_Number_USR);

// PAR.Error Status = CND.yes
PAR.Error_Status = 'Y';

ENDIF;

//?** ITC can have an invalid sub-ledger but it must be accepted  E000662
// IF *OTHERWISE
IF *OTHERWISE;

// Send error message - 'G/L Sub-Ledger code (G/L Vendor #) is invalid'
ERROR(USR4118);
MSGPARM(DTL.G_L_Vendor_Number_USR);

// PAR.Error Status = CND.yes
PAR.Error_Status = 'Y';

ENDIF;

// IF *OTHERWISE
IF *OTHERWISE;

// DTL.G/L Sub-Ledger Code = DTL.G/L Vendor Number USR
DTL.G_L_Sub_Ledger_Code = DTL.G_L_Vendor_Number_USR;

ENDIF;

ENDIF;

//?** Create Chargeback Ref#. If it exists, increment til valid. C000789
//?E2991 RMC 1/24/14 Use seq# from Company control
CASE;

// IF DTL.USR Invoice Number is Not Entered
IF DTL.USR_Invoice_Number = *ZERO;

// AND DTL.Adjustment Type Code is Chargeback
AND ( DTL.Adjustment_Type_Code = 'CB';

// OR DTL.Adjustment Type Code is Accrual Chargeback
OR DTL.Adjustment_Type_Code = 'ACB' );

//?get from Company 000 record
EXECUTE FUNCTION(RTV Next CB Number     RT) TYPE(RTVOBJ) FILE(CAASREP)          AC2082405;
PARAMETER(*ZERO);
PARAMETER(LCL.Next_Charge_Back_Number);
{
 //?USER: Processing if Data record not found

 MOVE *ALL (To: PAR From: CON);

 //?USER: Process Data record

 MOVE *ALL (To: PAR From: DB1);

}


// LCL.Next Charge Back Number = LCL.Next Charge Back Number + CON.1
LCL.Next_Charge_Back_Number = LCL.Next_Charge_Back_Number + 1;

EXECUTE FUNCTION(RTV Check invc exists  RT) TYPE(RTVOBJ) FILE(ARBDCPP)          AC1263564;
PARAMETER(LCL.Next_Charge_Back_Number);
{
 //?USER: Processing if Data record not found

 // PGM.*Return code = CND.*Record does not exist
 PGM.*Return_code = 'Y2U0005';

 //?USER: Process Data record

 // PGM.*Return code = CND.*Record already exists
 PGM.*Return_code = 'Y2U0003';

}


// DOW PGM.*Return code is *Record already exists
DOW PGM.*Return_code = 'Y2U0003';

// LCL.Next Charge Back Number = LCL.Next Charge Back Number + CON.1
LCL.Next_Charge_Back_Number = LCL.Next_Charge_Back_Number + 1;

EXECUTE FUNCTION(RTV Check invc exists  RT) TYPE(RTVOBJ) FILE(ARBDCPP)          AC1263564;
PARAMETER(LCL.Next_Charge_Back_Number);
{
 //?USER: Processing if Data record not found

 // PGM.*Return code = CND.*Record does not exist
 PGM.*Return_code = 'Y2U0005';

 //?USER: Process Data record

 // PGM.*Return code = CND.*Record already exists
 PGM.*Return_code = 'Y2U0003';

}


ENDDO;

EXECUTE FUNCTION(RTV Next Charge Back# CH) TYPE(CHGOBJ) FILE(CAASREP)           AC2082404;
PARAMETER(*ZERO);
PARAMETER(LCL.Next_Charge_Back_Number);
{
 //?USER: Processing before Data update

 EXECUTE FUNCTION(Set Date/Time Stamp   IF) TYPE(EXCINTFUN)                      AC1142219;
 {
  //?Execute internal function

  // PAR.Job Time = JOB.*Job time
  PAR.Job_Time = JOB.*Job_time;

  // PAR.User Id = JOB.*USER
  PAR.User_Id = JOB.*USER;

  // PAR.Job Name = JOB.*JOB
  PAR.Job_Name = JOB.*JOB;

  // PAR.Job Date = JOB.*Job date
  PAR.Job_Date = JOB.*Job_date;

 }

}


//?** Update PAR context so A/R Detail stays in sync
// DTL.USR Invoice Number = CVTVAR(LCL.Next Charge Back Number)
DTL.USR_Invoice_Number = CVTVAR(LCL.Next_Charge_Back_Number);

EXECUTE FUNCTION(RTV Last Seq. No.      RT) TYPE(RTVOBJ) FILE(ARBECPP)          AC1972737;
PARAMETER(DTL.Company_Number);
PARAMETER(DTL.Invoice_Number);
PARAMETER(DTL.Invoice_Suffix);
PARAMETER(LCL.Sequence_Number);
{
 //?USER: Processing if Data record not found

 // PAR.Sequence Number = CON.1
 PAR.Sequence_Number = 1;

 //?USER: Process Data record

 // PAR.Sequence Number = DB1.Sequence Number
 PAR.Sequence_Number = DB1.Sequence_Number;

}


// DTL.Sequence Number = LCL.Sequence Number + CON.1
DTL.Sequence_Number = LCL.Sequence_Number + 1;

// LCL.A/R Orig Inv for CB = DTL.Invoice Number
LCL.A_R_Orig_Inv_for_CB = DTL.Invoice_Number;

ENDIF;

//?12/28/07 PKD Do not allow Negative Charge Back
//?VAL: Chargeback Transaction Amount
CASE;

// IF DTL.Adjustment Type Code is Chargeback
IF DTL.Adjustment_Type_Code = 'CB';

CASE;

// IF DTL.Transaction Amount is less than zero
IF DTL.Transaction_Amount < *ZERO;

// Send error message - 'Transactions Amount must be positive.'
ERROR(USR3870);
MSGPARM(DTL.Transaction_Amount);

// PAR.Error Status = CND.yes
PAR.Error_Status = 'Y';

ENDIF;

ENDIF;

//?RMC 12/23/05 get g/l posting co too
// Call program VAL Acct ID JDE-8 dgt  UP.
CALL PROGRAM(VAL Acct ID JDE-8 dgt  UP) ('ARACTRET');
PARAMETER(DTL.G_L_ID_Code_JDE);
PARAMETER(WRK.Cost_Center);
PARAMETER(WRK.Object_Account);
PARAMETER(WRK.Subsidiary);
PARAMETER(DTL.G_L_Account_Description);
PARAMETER(DTL.G_L_Posting_Company);
PARAMETER(NLL.JDE_Posting_Edit_Code_USR);
PARAMETER(NLL.Error_Return_text);

// WRK.Adjustment Type Code = DTL.Adjustment Type Code
WRK.Adjustment_Type_Code = DTL.Adjustment_Type_Code;

// WRK.Cash/Adj = DTL.Cash/Adj
WRK.Cash_Adj = DTL.Cash_Adj;

// WRK.USR Invoice Number = DTL.USR Invoice Number
WRK.USR_Invoice_Number = DTL.USR_Invoice_Number;

// WRK.Transaction Amount = DTL.Transaction Amount
WRK.Transaction_Amount = DTL.Transaction_Amount;

// WRK.A/R Check Number = DTL.A/R Check Number
WRK.A_R_Check_Number = DTL.A_R_Check_Number;

//?USER: Create DBF record

EXECUTE FUNCTION(CRT A/R Detail Appl    CR) TYPE(CRTOBJ) FILE(ARBECPP)          AC1338635;
PARAMETER(DTL.Company_Number);
PARAMETER(DTL.Invoice_Number);
PARAMETER(DTL.Invoice_Suffix);
PARAMETER(DTL.Sequence_Number);
PARAMETER(DTL.Adjustment_Type_Code);
PARAMETER(DTL.Transaction_Amount);
PARAMETER(DTL.A_R_Check_Number);
PARAMETER(DTL.Explanation);
PARAMETER(JOB.*Job_date);
PARAMETER(PAR.Deposit_Date);
PARAMETER(DTL.Deposit_Time);
PARAMETER(DTL.G_L_Post_Date);
PARAMETER(PAR.Bank_Code);
PARAMETER(DTL.GL_Document_Number);
PARAMETER(DTL.Cash_Adj);
PARAMETER('E');
PARAMETER('PDTXE1R');
PARAMETER(DTL.Effect_on_Account);
PARAMETER(DTL.G_L_Posting_Company);
PARAMETER(DTL.G_L_ID_Code_JDE);
PARAMETER('N');
PARAMETER(DTL.A_R_TF_Exempt_Code);
PARAMETER(DTL.A_R_Dtl_UnUsed_Sts_1_1);
PARAMETER(DTL.A_R_Dtl_UnUsed_Sts_2_1);
PARAMETER(DTL.A_R_Dtl_UnUsed_Sts_3_1);
PARAMETER(DTL.A_R_Dtl_UnUsed_Sts_4_2);
PARAMETER(DTL.A_R_Dtl_UnUsed_Sts_5_2);
PARAMETER(DTL.TFS_Adj_Week_Ending_Date);
PARAMETER(LCL.A_R_Orig_Inv_for_CB);
PARAMETER(DTL.USR_Invoice_Number);
PARAMETER(DTL.A_R_Dtl_UnUsed_Date_4);
PARAMETER(DTL.A_R_Dtl_UnUsed_Date_5);
PARAMETER(DTL.G_L_Vendor_Number_USR);
PARAMETER(DTL.A_R_Dtl_UnUsed_AMT_2);
PARAMETER(DTL.A_R_Dtl_UnUsed_AMT_3);
PARAMETER(DTL.A_R_Dtl_UnUsed_AMT_4);
PARAMETER(DTL.A_R_Dtl_UnUsed_AMT_5);
PARAMETER(DTL.EDI_Status_1);
PARAMETER(DTL.EDI_Status_2);
PARAMETER(DTL.EDI_Status_3);
PARAMETER(DTL.AR_Customer_Number);
PARAMETER(PAR.Access_Denied_Y_N);
{
 //?USER: Processing before Data update

 EXECUTE FUNCTION(Set Date/Time Stamp   IF) TYPE(EXCINTFUN)                      AC1142219;
 PARAMETER(DB1.Job_Time);
 PARAMETER(DB1.User_Id);
 PARAMETER(DB1.Job_Name);
 PARAMETER(DB1.Job_Date);
 {
  //?Execute internal function

  // PAR.Job Time = JOB.*Job time
  PAR.Job_Time = JOB.*Job_time;

  // PAR.User Id = JOB.*USER
  PAR.User_Id = JOB.*USER;

  // PAR.Job Name = JOB.*JOB
  PAR.Job_Name = JOB.*JOB;

  // PAR.Job Date = JOB.*Job date
  PAR.Job_Date = JOB.*Job_date;

 }

 //?USER: Processing after Data update

 // PAR.Access Denied (Y/N) = CND.no
 PAR.Access_Denied_Y_N = 'N';

}


//?USER: Change DBF record

EXECUTE FUNCTION(CHG A/R Detail         CH) TYPE(CHGOBJ) FILE(ARBECPP)          AC1109992;
PARAMETER(DTL.Company_Number);
PARAMETER(DTL.Invoice_Number);
PARAMETER(DTL.Invoice_Suffix);
PARAMETER(DTL.Sequence_Number);
PARAMETER(DTL.Adjustment_Type_Code);
PARAMETER(DTL.Transaction_Amount);
PARAMETER(DTL.A_R_Check_Number);
PARAMETER(DTL.Explanation);
PARAMETER(DTL.Transaction_Date_Code);
PARAMETER(DTL.Payment_Deposit_Date);
PARAMETER(DTL.Deposit_Time);
PARAMETER(DTL.G_L_Post_Date);
PARAMETER(DTL.Bank_Code);
PARAMETER(DTL.GL_Document_Number);
PARAMETER(DTL.Cash_Adj);
PARAMETER(DTL.A_R_Processing_Status);
PARAMETER(DTL.Originating_Program_Name);
PARAMETER(DTL.Effect_on_Account);
PARAMETER(DTL.G_L_Posting_Company);
PARAMETER(DTL.G_L_ID_Code_JDE);
PARAMETER(DTL.Post_Adjustments);
PARAMETER(DTL.A_R_TF_Exempt_Code);
PARAMETER(DTL.A_R_Orig_Inv_for_CB);
PARAMETER(DTL.G_L_Vendor_Number_USR);
PARAMETER(DTL.EDI_Status_1);
PARAMETER(DTL.EDI_Status_2);
PARAMETER(DTL.EDI_Status_3);
PARAMETER(DTL.Job_Time);
PARAMETER(DTL.User_Id);
PARAMETER(DTL.Job_Name);
PARAMETER(DTL.Job_Date);
{
 //?USER: Processing before Data update

 EXECUTE FUNCTION(Set Record Stamp CHGOB IF) TYPE(EXCINTFUN)                     AC1283156;
 PARAMETER(DB1.Job_Time);
 PARAMETER(DB1.User_Id);
 PARAMETER(DB1.Job_Name);
 PARAMETER(DB1.Job_Date);
 {
  //?Execute internal function

  // PAR.Job Time = JOB.*Job time
  PAR.Job_Time = JOB.*Job_time;

  // PAR.User Id = JOB.*USER
  PAR.User_Id = JOB.*USER;

  // PAR.Job Name = JOB.*PROGRAM
  PAR.Job_Name = JOB.*PROGRAM;

  // PAR.Job Date = JOB.*Job date
  PAR.Job_Date = JOB.*Job_date;

 }

}


//?USER: Exit program processing

//?set access denied flag to *yes if errors exist
CASE;

// IF PAR.Error Status is yes
IF PAR.Error_Status = 'Y';

// PAR.Access Denied (Y/N) = CND.yes
PAR.Access_Denied_Y_N = 'Y';

ENDIF;

//?New 12/17/01 (skip updates if *F3 to exit)
CASE;

// IF DTL.*CMD key is *Exit
IF DTL.*CMD_key = '03';

// PAR.Access Denied (Y/N) = CND.yes
PAR.Access_Denied_Y_N = 'Y';

ENDIF;

//?perform file updates if no errors
CASE;

// IF PAR.Access Denied (Y/N) is no
IF PAR.Access_Denied_Y_N = 'N';

// PAR.USR Cash Appl Amount = PAR.USR Cash Temp Appl
PAR.USR_Cash_Appl_Amount = PAR.USR_Cash_Temp_Appl;

// PAR.USR Adjustment Amount 1 = PAR.USR Adj Temp Total
PAR.USR_Adjustment_Amount_1 = PAR.USR_Adj_Temp_Total;

//?Cash Adjustment Type
CASE;

// IF WRK.Cash/Adj is Cash Adjustment
IF WRK.Cash_Adj = 'CSH';

// PAR.USR Cust Apply = PAR.USR Cust Temp Apply
PAR.USR_Cust_Apply = PAR.USR_Cust_Temp_Apply;

// WRK.Last Payment Date = PAR.Deposit Date
WRK.Last_Payment_Date = PAR.Deposit_Date;

EXECUTE FUNCTION(CHG Cash Applied       RT) TYPE(RTVOBJ) FILE(PDJ2CPP)          AC1334014;
PARAMETER(PAR.Bank_Code);
PARAMETER(PAR.Deposit_Date);
PARAMETER(PAR.Deposit_Time);
PARAMETER(PAR.USR_Cash_Appl_Amount);
{
 //?USER: Process Data record

 // WRK.Total Cash Applied = PAR.USR Cash Appl Amt Total + DB1.Total Cash Applied
 WRK.Total_Cash_Applied = PAR.USR_Cash_Appl_Amt_Total + DB1.Total_Cash_Applied;

 EXECUTE FUNCTION(CHG Cash Applied Field CH) TYPE(CHGOBJ) FILE(PDJ2CPP)          AC1334031;
 PARAMETER(DB1.Bank_Code);
 PARAMETER(DB1.Deposit_Date);
 PARAMETER(DB1.Deposit_Time);
 PARAMETER(WRK.Total_Cash_Applied);
 PARAMETER('E');
 PARAMETER(DB1.CD_TF_Internal_Batch_Nbr);
 PARAMETER(DB1.CD_TF_Immediate_Fund_Amt);
 PARAMETER(DB1.CD_TF_1_Day_Fund_Amt);
 PARAMETER(DB1.CD_TF_2_Day_Fund_Amt);
 PARAMETER(DB1.CD_SB_Exempt_Immed_Amt);
 PARAMETER(DB1.CD_SB_1_Day_Exempt_Immed);
 PARAMETER(DB1.CD_SB_2_Day_Exempt_Immed);
 PARAMETER(DB1.SBD_Exempt_Total_Amount);
 PARAMETER(DB1.ARBD_Unused_Amt_2);
 PARAMETER(DB1.ARBD_Unused_Amt_3);
 PARAMETER(DB1.ARBD_Unused_Amt_4);
 PARAMETER(DB1.ARBD_Unused_Amt_5);
}


//?Cash Adjustment Type
// IF *OTHERWISE
IF *OTHERWISE;

// WRK.Last Payment Date = CND.not entered
WRK.Last_Payment_Date = *ZERO;

ENDIF;

EXECUTE FUNCTION(CHG Header Cash Applie RT) TYPE(RTVOBJ) FILE(ARBDCPP)          AC1336735;
PARAMETER(PAR.Company_Number);
PARAMETER(PAR.Invoice_Number);
PARAMETER(PAR.Invoice_Suffix);
PARAMETER(PAR.Bank_Code);
PARAMETER(PAR.Deposit_Date);
PARAMETER(WRK.Last_Payment_Date);
PARAMETER(WRK.A_R_Check_Number);
PARAMETER(PAR.USR_Cash_Appl_Amount);
PARAMETER(PAR.USR_Adjustment_Amount_1);
{
 //?USER: Process Data record

 // PAR.Days to Pay = CND.equal to zero
 PAR.Days_to_Pay = *ZERO;

 // PAR.USR Cash Appl Amt Total = DB1.Amount Paid + PAR.USR Cash Appl Amount
 PAR.USR_Cash_Appl_Amt_Total = DB1.Amount_Paid + PAR.USR_Cash_Appl_Amount;

 // PAR.USR Adjustments Total = DB1.Adjustment Amount + PAR.USR Adjustment Amount 1
 PAR.USR_Adjustments_Total = DB1.Adjustment_Amount + PAR.USR_Adjustment_Amount_1;

 // PAR.USR Total Deducted = PAR.USR Cash Appl Amt Total + PAR.USR Adjustments Total
 PAR.USR_Total_Deducted = PAR.USR_Cash_Appl_Amt_Total + PAR.USR_Adjustments_Total;

 // WRK.Remaining Balance Due = DB1.Transaction Amount - PAR.USR Total Deducted
 WRK.Remaining_Balance_Due = DB1.Transaction_Amount - PAR.USR_Total_Deducted;

 //?The calculation for days to pay was changed 6/13/96 per ARS026
 //?        The documentation is on document AR26DSN.DOC
 //?Paid in full Days to Pay is calculated for INV and DM only
 CASE;

 // IF DB1.Invoice Suffix is Invoice or Debit Memo
 IF DB1.Invoice_Suffix = 'DM'/'IN';

 //?Paid in Full Date
 CASE;

 // IF WRK.Remaining Balance Due is equal to zero
 IF WRK.Remaining_Balance_Due = *ZERO;

 //?The ClC Days Paid IF has been changed by ARS026 to use the Deposit Date
 //?    rather than the entry date.  The document # is AR26DSN.DOC
 //?Calculate Days to Paid Function
 //?Decide what constitutes the last payment date
 CASE;

 // IF PAR.Last Payment Date is entered
 IF PAR.Last_Payment_Date <> *ZERO;

 // WRK.Last Payment Date = PAR.Last Payment Date
 WRK.Last_Payment_Date = PAR.Last_Payment_Date;

 //?Decide what constitutes the last payment date
 // IF *OTHERWISE
 IF *OTHERWISE;

 // WRK.Last Payment Date = DB1.Last Payment Date
 WRK.Last_Payment_Date = DB1.Last_Payment_Date;

 ENDIF;

 EXECUTE FUNCTION(CLC Days Paid          IF) TYPE(EXCINTFUN)                     AC1351456;
 PARAMETER(DB1.Company_Number);
 PARAMETER(DB1.Transaction_Date_Code);
 PARAMETER(WRK.Last_Payment_Date);
 PARAMETER(PAR.Days_to_Pay);
 {
  //?Execute internal function

  //?  Transaction Date (Invoice Date) will be used instead of Due Date.
  //?     PER Request ARS038
  //?  The Paid in Full Date has been Changed to the Deposit Date
  //?     Which is the Last Payment Date
  // PAR.Number of Days = PAR.Last Payment Date - PAR.Transaction Date Code *DAYS
  PAR.Number_of_Days = DURATION(PAR.Last_Payment_Date PAR.Transaction_Date_Code 'DY'
  1111111 'NONE' 'N' 1);

  //?Handle Negative Days to Pay
  CASE;

  // IF PAR.Number of Days is Less Than Zero
  IF PAR.Number_of_Days < *ZERO;

  // PAR.Days to Pay = CND.equal to zero
  PAR.Days_to_Pay = *ZERO;

  //?Handle Negative Days to Pay
  // IF *OTHERWISE
  IF *OTHERWISE;

  // PAR.Days to Pay = PAR.Number of Days
  PAR.Days_to_Pay = PAR.Number_of_Days;

  ENDIF;

 }

 //?Days to Pay is Negative
 CASE;

 // IF PAR.Days to Pay is less than zero
 IF PAR.Days_to_Pay < *ZERO;

 // PAR.Days to Pay = CND.equal to zero
 PAR.Days_to_Pay = *ZERO;

 ENDIF;

 //?Paid in Full Date
 // IF *OTHERWISE
 IF *OTHERWISE;

 // PAR.Days to Pay = CND.equal to zero
 PAR.Days_to_Pay = *ZERO;

 ENDIF;

 ENDIF;

 //?Paid in full if Remaining balance is zero
 CASE;

 // IF WRK.Remaining Balance Due is equal to zero
 IF WRK.Remaining_Balance_Due = *ZERO;

 // WRK.Paid in Full Date = JOB.*Job date
 WRK.Paid_in_Full_Date = JOB.*Job_date;

 //?Paid in full if Remaining balance is zero
 // IF *OTHERWISE
 IF *OTHERWISE;

 // WRK.Paid in Full Date = CND.not entered
 WRK.Paid_in_Full_Date = *ZERO;

 // PAR.Days to Pay = CND.equal to zero
 PAR.Days_to_Pay = *ZERO;

 ENDIF;

 //?Keep existing last payment date if it did not enter as cash adjustment
 CASE;

 // IF PAR.Last Payment Date is not entered
 IF PAR.Last_Payment_Date = *ZERO;

 // PAR.Last Payment Date = DB1.Last Payment Date
 PAR.Last_Payment_Date = DB1.Last_Payment_Date;

 ENDIF;

 EXECUTE FUNCTION(Chg Remain Due         CH) TYPE(CHGOBJ) FILE(ARBDCPP)          AC1336767;
 PARAMETER(DB1.Company_Number);
 PARAMETER(DB1.Invoice_Number);
 PARAMETER(DB1.Invoice_Suffix);
 PARAMETER(PAR.USR_Adjustments_Total);
 PARAMETER(PAR.USR_Cash_Appl_Amt_Total);
 PARAMETER(WRK.Remaining_Balance_Due);
 PARAMETER(PAR.Bank_Code);
 PARAMETER(PAR.Last_Payment_Date);
 PARAMETER(DB1.Original_Inv_for_CB);
 PARAMETER(WRK.Paid_in_Full_Date);
 PARAMETER(DB1.AR_Customer_Number);
 PARAMETER(PAR.A_R_Check_Number);
 PARAMETER(PAR.Days_to_Pay);
}


//?*** PK0333 ***
//?add chargeback record to a/r header
//?Chargeback Adjustment Type
CASE;

// IF WRK.Adjustment Type Code is Chargeback
IF WRK.Adjustment_Type_Code = 'CB';

// OR WRK.Adjustment Type Code is Accrual Chargeback
OR WRK.Adjustment_Type_Code = 'ACB';

EXECUTE FUNCTION(RTV Add Chargeback Hd. RT) TYPE(RTVOBJ) FILE(ARBDCPP)          AC1343147;
PARAMETER(PAR.Company_Number);
PARAMETER(KEY.Invoice_Number);
PARAMETER(KEY.Invoice_Suffix);
PARAMETER(WRK.Adjustment_Type_Code);
PARAMETER(WRK.Transaction_Amount);
PARAMETER(PAR.Bank_Code);
PARAMETER(WRK.USR_Invoice_Number);
PARAMETER(PAR.Deposit_Date);
{
 //?USER: Process Data record

 CASE;

 // IF PAR.Deposit Date is not entered
 IF PAR.Deposit_Date = *ZERO;

 // WRK.Deposit Date = JOB.*Job date
 WRK.Deposit_Date = JOB.*Job_date;

 // IF *OTHERWISE
 IF *OTHERWISE;

 // WRK.Deposit Date = PAR.Deposit Date
 WRK.Deposit_Date = PAR.Deposit_Date;

 ENDIF;

 //?*** PK0333 ***  changed to use par.adjustment type code instead of
 //?cnd.chargeback
 // LCL.Original Inv for CB = PAR.Invoice Number
 LCL.Original_Inv_for_CB = PAR.Invoice_Number;

 EXECUTE FUNCTION(CRT A/R Header         CR) TYPE(CRTOBJ) FILE(ARBDCPP)          AC1341687;
 PARAMETER(PAR.Company_Number);
 PARAMETER(PAR.USR_Invoice_Number);
 PARAMETER('CB');
 PARAMETER(PAR.Adjustment_Type_Code);
 PARAMETER(WRK.Transaction_Amount);
 PARAMETER(*ZERO);
 PARAMETER(*ZERO);
 PARAMETER(WRK.Transaction_Amount);
 PARAMETER('E');
 PARAMETER('O');
 PARAMETER(PAR.Bank_Code);
 PARAMETER(*ZERO);
 PARAMETER(DB1.Order_Number_Ref);
 PARAMETER(DB1.Ship_To_Customer);
 PARAMETER(DB1.Salesperson_Code);
 PARAMETER(DB1.Sales_Route_Code);
 PARAMETER(WRK.Deposit_Date);
 PARAMETER(WRK.Deposit_Date);
 PARAMETER(*ZERO);
 PARAMETER(LCL.Original_Inv_for_CB);
 PARAMETER(*ZERO);
 PARAMETER(*ZERO);
 PARAMETER(DB1.AR_Customer_Number);
 PARAMETER(DB1.A_R_Check_Number);
 PARAMETER(*ZERO);
 PARAMETER(DB1.EDI_Status_1);
 PARAMETER(DB1.EDI_Status_2);
 PARAMETER(DB1.EDI_Status_3);
 {
  //?USER: Processing before Data update

  // DB1.Job Time = JOB.*Job time
  DB1.Job_Time = JOB.*Job_time;

  // DB1.User Id = JOB.*USER
  DB1.User_Id = JOB.*USER;

  // DB1.Job Name = JOB.*JOB
  DB1.Job_Name = JOB.*JOB;

  // DB1.Job Date = JOB.*Job date
  DB1.Job_Date = JOB.*Job_date;

  //?USER: Processing after Data update

  //?E6933 DN  08/12/16 - Create A/R Header Ext record.
  // Call program Crt A/R Header Ext    XF.
  CALL PROGRAM(Crt A/R Header Ext    XF) ('PBX3XFR');
  PARAMETER(DB1.Company_Number);
  PARAMETER(DB1.Invoice_Number);
  PARAMETER(DB1.Invoice_Suffix);
  PARAMETER(DB1.Remaining_Balance_Due);
  PARAMETER(DB1.Order_Number_Ref);
  PARAMETER(DB1.Original_Inv_for_CB);

 }

}


ENDIF;

ENDIF;

