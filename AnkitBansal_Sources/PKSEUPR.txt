      *****************  RPG PROGRAM HEADING  ************************
      *
      * SYSTEM:       HPE-Hog Procurement and Evaluation System
      * PROGRAM:      PKSEUPR
      * TITLE:        Outfile:  Performance Review
      * AUTHOR:       LeAnne Fedor
      * CREATED:      08/18/99
      *
      * FUNCTION: This program builds an outfile of data that will be FTP'd to
      *           a server for use by Don Clark in his Performance Review for
      *           a producer.
      *
      *           The user provides the following function selections:
      *             a) company
      *             b) producer (optional)
      *             c) start date
      *             c) number of weeks for data extractions
      *
      *           The program will calculate the beginning/ending dates for
      *           the number of weeks selected and write one record to the
      *           outfile for each week. It will then extract data and
      *           place it in the appropriate 'week' record.
      ****************************************************************
      * MODIFICATIONS:
      ****************************************************************
      * DATE      PROGRAMMER
      * 09/27/99  LeAnne Fedor
      *           Don Clark requested that fields be shown as decimals
      *           instead of percents (ie: don't multiple values by 100).
      *           Also, added an open query in CL to handle user selection
      *           of a single producer or all producers.
      * 02/03/00  ROSE CENTONZE
      *           Output new lean% field euaga1 and new yield % field
      * 04/14/003 ROSE CENTONZE
      *           CHANGE DEFECT CODE SELECT
      * 08/08/003 ROSE CENTONZE
      *           CALC/OUTPUT 2 DEC BACKFAT AND LOIN EYE FROM TH
      *           by using a1mcnf and a1mvnf instead of a1f2nb and a1f3nb
      * 04/05/003 ROSE CENTONZE
      *           CHANGE DEFECT CODE SELECT
      * 11/04/20  ISE
      *           Recompile only. Increased Buy Order Number length from
      *           5 to 7.
      /EJECT
      ****************************************************************
      * FILE SPECIFICATIONS
      ****************************************************************
      *
      *
     Fpka1cplq  if   e           k disk
      *    Tattoo header  (records selected by open query in CL)
      *
      *
     Fpkdzrel1  if   e           k disk
      *    Tattoo defect
      *
      *
     Fpkeucpl0  uf a e           k disk
      *    Weekly performance outfile
      *
      /eject
      ****************************************************************
      * DEFINITION SPECIFICATIONS
      ****************************************************************
      *
     D yes             c                   'Y'
     D no              c                   'N'
      *
      ****************************************************************
      * ARRAYS AND TABLES
      ****************************************************************
      *
      *
      ****************************************************************
      * STANDALONE FIELDS
      ****************************************************************
      *
      *
      * Control fields
      *
     D first           s              1    inz('Y')
      *
      *
      * Parms
      *
     D xxhmnb          s                   like(a1hmnb)
     D xxabcd          s                   like(a1abcd)
     D xxb0dt          s                   like(a1b0dt)
     D xxweeks         s              2  0
      *
      *
      * Workfields for calculations
      *
     D wkfield         s             15  2
     D wkfield2        s             17  7
      *
      *
      *
      * Workfields to accumulate values for the 'total' record
      *
     D t1kdhd          s                   like(eukdhd)
     D t1dohd          s                   like(eudohd)
     D t1ydhd          s                   like(euydhd)
     D t1cdhd          s                   like(eucdhd)
     D t1hrhd          s                   like(euhrhd)
     D t1nrhd          s                   like(eunrhd)
     D t1lvwt          s                   like(eulvwt)
     D t1htwt          s                   like(euhtwt)
     D t1sthd          s                   like(eusthd)
     D t1gava          s                   like(eugava)
     D t1gbva          s                   like(eugbva)
     D t1gcva          s                   like(eugcva)
      *
     D t1abhd          s                   like(euabhd)
     D t1blhd          s                   like(eublhd)
     D t1brhd          s                   like(eubrhd)
     D t1gshd          s                   like(eugshd)
     D t1hvhd          s                   like(euhvhd)
     D t1lthd          s                   like(eulthd)
     D t1lchd          s                   like(eulchd)
     D t1mnhd          s                   like(eumnhd)
     D t1mshd          s                   like(eumshd)
     D t1othd          s                   like(euothd)
     D t1pqhd          s                   like(eupqhd)
     D t1qshd          s                   like(euqshd)
     D t1rbhd          s                   like(eurbhd)
     D t1schd          s                   like(euschd)
      *
      * Workfields for dates
      *
     D wkbegsyndt      s                   like(a1b0dt)
     D wkendsyndt      s                   like(a1b0dt)
     D wkbegdt         s              8  0
     D wkenddt         s              8  0
     D wkalphadt       s              6
      *
      *
      *
      * Workfields in date format for date manipulation
      *
     D wkisoend        s               D   datfmt(*iso)
     D wkisobeg        s               D   datfmt(*iso)
      *
      *
      ****************************************************************
      * DATA STRUCTURES
      ****************************************************************
      *
      *---------------------------------------------------------------
      * Standard program status data structure
      *---------------------------------------------------------------
      *    externally defined as UTPGFR (record format: PGMDSR)
     D pgmds         esds                  extname(utpgfr)
      *
      *---------------------------------------------------------------
      * Standard database file information data structure
      *---------------------------------------------------------------
      *    externally defined as UTDBGR (record format: FDBCKD)
     D dbfeed        e ds                  extname(utdbfr)
      *
      *---------------------------------------------------------------
      * Date formats for flipping dates between  cyymmdd and ccyymmdd
      *---------------------------------------------------------------
      *
     D wksynon         ds                  inz
     D   wksynondt                    7  0
     D   wksynoncen                   1  0 overlay(wksynondt:1)
     D   wksynonyer                   2  0 overlay(wksynondt:2)
     D   wksynonmon                   2  0 overlay(wksynondt:4)
     D   wksynonday                   2  0 overlay(wksynondt:6)
      *
      *
     D wkccyymmdd      ds                  inz
     D   wkcymd                       8  0
     D   wkcen                        2  0 overlay(wkcymd:1)
     D   wkyer                        2  0 overlay(wkcymd:3)
     D   wkmon                        2  0 overlay(wkcymd:5)
     D   wkday                        2  0 overlay(wkcymd:7)
      *
      *
      * The following is a dummy C-spec to keep the D-specs from
      * running over into the C-specs on the compile listing. It
      * serves no other purpose and can be deleted at any time.
      *
     C                   if        sdpgm = *blank
     C                   endif
      /EJECT
      ****************************************************************
      * MAINLINE
      ****************************************************************
      *
      * Step 1:  Calculate 'beginning/ending' dates for the number of
      *          weeks selected by the user and write a record for each
      *          week to the outfile.
      *
     C                   do        xxweeks
     C                   exsr      $weeks
     C                   enddo
      *
      *
      * Step 2:  Read the outfile.   For each record, extract data from
      *          the database for the 'week' and update outfile record.
      *          You will be extracting tattoo header and tattoo defect
      *          info and then calculating percents.
      *
      *
     C     *loval        setll     pkeucpl0
     C                   dou       *in90 = *on
     C                   read      pkeucpl0                               90
     C                   if        *in90 = *off
     C                   exsr      $header
     C                   exsr      $percents
     C                   exsr      $update
     C                   endif
     C                   enddo
      *
      *
      *---------------------------------------------------------------
      * End of file processing
      *---------------------------------------------------------------
      *
      * Write a 'total' record to the outfile
      *
     C                   exsr      $total
      *
     C                   seton                                        lr
      /EJECT
      *-----------------------------------------------------------------------------
      * $header - Extract the data for a 'week' from the Tattoo Header and Tattoo
      *           Defect files.
      *-----------------------------------------------------------------------------
      *
      * Retrieve the records from the Tattoo Header file for the 'week'
      * being processed. For each header record, also retrieve all the 'tattoo
      * defect' records for the tattoo. (Note: Tattoo Header records for company
      * and, optionally, producer are selected with an open query in the CL.)
      *
     C     $header       begsr
      *
      * Position on company/kill date and then process on company
      * until the kill date falls after the ending date for the week.
      *
SZ04 C     key01         setll     pka1cplq
      *
 B1  C                   dou       *in91 = *on or a1b0dt > eudxdt               Do header loop
SZ06 C     euhonb        reade     pka1cplq                               91
 B2  C                   if        *in91 = *off and a1b0dt <= eudxdt            If not EOF
      *
      * Always accumulate received head for later calculations
      *
     C                   add       a1cwnb        euhrhd
      *
      * When this is a 'resale', only perform the processing for defects.
      *
     C                   select
 B2  C                   when      a1llst = 'R'
     C                   exsr      $defects
     C                   other
      *
      * Head counts:
      *  1) head killed
      *  2) dead on arrival head
      *  3) yard dead head
      *  4) condemned head
      *  5) head received from records that are not 'resale'
      *
     C                   add       a1fenb        eukdhd
     C                   add       a1cxnb        eudohd
     C                   add       a1fcnb        euydhd
     C                   add       a1fdnb        eucdhd
     C                   add       a1cwnb        eunrhd
      *
      * Accumulate the following for later calculations of weighted averages.
      *  1) live weight
      *  2) hot weight
     C                   add       a1cynb        eulvwt
     C                   add       a1e0nb        euhtwt
      *
      * Calculate and then accumulate the following 3 values for later
      * calculations of weighted averages.
      *  1) back fat = average back fat * hot weight
      *
     C     a1mcnf        mult      a1e0nb        wkfield
     C                   add       wkfield       eugava
      *
      *  2) loin eye = average loin eye * hot weight
      *
     C     a1mvnf        mult      a1e0nb        wkfield
     C                   add       wkfield       eugbva
      *
      *  3) lean percent = average lean % * hot weight
      *
     C     a1f4nb        mult      a1e0nb        wkfield
     C                   add       wkfield       eugcva
      *
      * Retrieve all the 'tattoo defects' for this tattoo header.
      *
     C                   exsr      $defects
     C                   endsl
      *
 E2  C                   endif                                                  If not EOF
 E1  C                   enddo                                                  Do header loop
      *
     C                   endsr
      /EJECT
      *------------------------------------------------------------------
      * $defects - Retrieve all the Tattoo Defect records for this tattoo
      *------------------------------------------------------------------
      *
      * We have 'hardcoded' 13 defect values into the output file with a final
      * category of 'miscellaneous' for all other defects. As you process records
      * accumulate the total for the 'sort total' in the output file.
      *
     C     $defects      begsr
      *
      *
     C     key03         setll     pkdzrel1
      *
     C                   dou       *in92 = *on                                  Do defect loop
     C     key03         reade     pkdzrel1                               92
     C                   if        *in92 = *off                                 If not EOF
      *
     C                   select
      * KOA
     C*                  when      dzbdcd = 'HD52  '
     C*                  add       dzljnb        euabhd
      * Belly busts
     C*                  when      dzbdcd = 'HD40  '
     C*                  add       dzljnb        eublhd
      * Boars/1 nut
     C                   when      dzbdcd = 'HD60  '
     C                   add       dzljnb        eubrhd
     C*                  when      dzbdcd = 'HD32  '
     C*                  add       dzljnb        eubrhd
      * Good sows
     C*                  when      dzbdcd = 'HD35  '
     C*                  add       dzljnb        eugshd
      * Heavies
     C                   when      dzbdcd = 'HD62  '
     C                   add       dzljnb        euhvhd
      * Lites
     C                   when      dzbdcd = 'HD63  '
     C                   add       dzljnb        eulthd
     C*                  when      dzbdcd = 'HD38  '
     C*                  add       dzljnb        eulthd
      * Light culls
     C                   when      dzbdcd = 'HD61  '
     C                   add       dzljnb        eulchd
      * Mange
     C*                  when      dzbdcd = 'HD49  '
     C*                  add       dzljnb        eumnhd
      * One testical boar
     C*                  when      dzbdcd = 'HD31  '
     C*                  add       dzljnb        euothd
     C*                  when      dzbdcd = 'HD33  '
     C*                  add       dzljnb        euothd
      * Poor quality
     C                   when      dzbdcd = 'HD64  '
     C                   add       dzljnb        eupqhd
      * Poor quality sows
     C*                  when      dzbdcd = 'HD    '
     C*                  add       dzljnb        euqshd
      * Rear busts
     C*                  when      dzbdcd = 'HD34  '
     C*                  add       dzljnb        eurbhd
      * Scarback
     C*                  when      dzbdcd = 'HD43  '
     C*                  add       dzljnb        euschd
      * Miscellaneous
     C                   other
     C                   add       dzljnb        eumshd
     C                   endsl
      *
      * Accumulate head for 'sort total'
      *
     C                   add       dzljnb        eusthd
      *
     C                   endif                                                  If not EOF
     C                   enddo                                                  Do defect loop
      *
     C                   endsr
      /EJECT
      *------------------------------------------------------------------
      * $percents - Calculate percents
      *------------------------------------------------------------------
      *
     C     $percents     begsr
      *
      * Average hot weight
      *      calc: total hot weight / total head killed
      *
     C                   if        eukdhd <> 0                                  If killed hd
     C                   eval      euhdnb = euhtwt / eukdhd
     C                   endif                                                  If killed hd
      *
      * Actual yield percent
      *       total hot weight / total live weight
      *
     C                   if        eulvwt <> 0                                  If live weight
     C     euhtwt        div       eulvwt        wkfield2
     C                   z-add     wkfield2      euawpc
     C                   z-add     wkfield2      euafa1
     C                   endif                                                  If live weight
      *
      * If you have 'received head' from 'non resale' records.
      * (ie: head from 'resales' are omitted from this accumulator)
      *
     C                   if        eunrhd <> 0                                  If non-resale
      *
      * Average live weight
      *      calc: total live weight / head received omitting resale
      *
     C                   eval      euf7nb = eulvwt / eunrhd
      *
      * Dead-on-arrival head percent
      *      calc: doa head / received head omitting resale
      *
     C                   eval      eudopd = eudohd / eunrhd
      *
      * Head condemned percent
      *      calc: condemned head / received head omitting resale
      *
     C                   eval      euhcpc = (eucdhd / eunrhd)
      *
      * Yard dead head percent
      *      calc:  yard dead head / received head omitting resale
      *
     C                   eval      euydpc = euydhd / eunrhd
     C                   endif                                                  If non resale
      *
      * If the 'received head' (including resales) is not zero, calculate:
      * Sort total percent (ie: percent of head with defects)
      *      calc:  sort total head / received head
      *
     C                   if        euhrhd <> 0                                  If received hd
     C                   eval      eustpc = eusthd / euhrhd
     C                   endif                                                  If received hd
      *
      *
      * If you have 'hot weight', perform the following 3 calcs:
      *
     C                   if        euhtwt <> 0                                  If hot weight
      * Average backfat
      *  calc: total(avg backfat * hot weight) / total hot weight
      *
     C                   eval      eumcnf = eugava / euhtwt
      *
      * Average loin eye
      *  calc: total(avg loin eye * hot weight) / total hot weight
      *
     C                   eval      eumvnf = eugbva / euhtwt
      *
      * Average lean percent
      *  calc: total(avg lean % * hot weight) / total hot weight
      *
     C                   eval      euf4nb = eugcva / euhtwt
     C                   eval      euaga1 = euf4nb / 100
      *
     C                   endif                                                  If hot weight
      *
     C                   endsr
      /EJECT
      *------------------------------------------------------------------
      * $update - Update 'week' record in output file
      *------------------------------------------------------------------
      *
     C     $update       begsr
      *
      * Accumulate values for the 'total' record that will be written during
      * end-of-file processing.
      *
     C                   add       eukdhd        t1kdhd
     C                   add       eudohd        t1dohd
     C                   add       euydhd        t1ydhd
     C                   add       eucdhd        t1cdhd
     C                   add       euhrhd        t1hrhd
     C                   add       eunrhd        t1nrhd
     C                   add       eusthd        t1sthd
      *
     C                   add       eulvwt        t1lvwt
     C                   add       euhtwt        t1htwt
     C                   add       eugava        t1gava
     C                   add       eugbva        t1gbva
     C                   add       eugcva        t1gcva
      *
     C                   add       euabhd        t1abhd
     C                   add       eublhd        t1blhd
     C                   add       eubrhd        t1brhd
     C                   add       eugshd        t1gshd
     C                   add       euhvhd        t1hvhd
     C                   add       eulthd        t1lthd
     C                   add       eulchd        t1lchd
     C                   add       eumnhd        t1mnhd
     C                   add       eumshd        t1mshd
     C                   add       euothd        t1othd
     C                   add       eupqhd        t1pqhd
     C                   add       euqshd        t1qshd
     C                   add       eurbhd        t1rbhd
     C                   add       euschd        t1schd
      *
      * Update the 'weekly' record
      *
     C                   update    @eucpdq
      *
     C                   endsr
      /EJECT
      *------------------------------------------------------------------
      * $weeks - Calculate the beginning/ending dates for the selected
      *          number of weeks and write a record to the workfile for
      *          each week.
      *------------------------------------------------------------------
      *
      * The following output file fields are populated through this subroutine:
      *   1) beginning/ending dates for calculated for each week
      *   2) company/producer fields are populated by the fact that they are moved
      *      to the file fields through the entry parm list
      *   3) the beginning date is formated to mm/dd/yy and placed in the alpha
      *      column heading field.
      *
     C     $weeks        begsr
      *
      * Calculate 'beginning' date for week
      *
     C                   if        first = yes                                  If week 1
     C                   z-add     xxb0dt        wkbegsyndt
     C                   z-add     xxb0dt        wksynondt
     C                   exsr      $toccyymmdd
     C     *iso          move      wkcymd        wkisobeg
     C                   move      no            first
     C                   else
      *
      * For all weeks other than week 1, calculate the beginning date as
      * 1 day after the previous ending date.
      *
     C     wkisoend      adddur    1:*d          wkisobeg
     C                   endif                                                  If week 1
      *
      *
      * Format the 'beginning' date that is in the date format field
      * to a SYNON format of 7,0 using the date data structures.
      *
     C                   move      wkisobeg      wkcymd
     C                   exsr      $tosynondt
     C                   z-add     wksynondt     wkbegsyndt
      *
      *
      * Calculate the 'ending' date for each week as:
      *   beginning date plus 6 days
      *
     C     wkisobeg      adddur    6:*d          wkisoend
      *
      * Format the 'ending' date that is in the date format field
      * to a SYNON format of 7,0 using the date data structures.
      *
     C                   move      wkisoend      wkcymd
     C                   exsr      $tosynondt
     C                   z-add     wksynondt     wkendsyndt
      *
     C                   z-add     wkbegsyndt    eudwdt
     C                   z-add     wkendsyndt    eudxdt
      *
      * Format the 'beginning date' into MM/DD/YY alpha field for column heading.

     C                   move(p)   eudwdt        wkalphadt
     C                   eval      %subst(eupctx: 1: 2) =
     C                                       %subst(wkalphadt: 3: 2)
     C                   eval      %subst(eupctx: 3: 1) = '/'
     C                   eval      %subst(eupctx: 4: 2) =
     C                                       %subst(wkalphadt: 5: 2)
     C                   eval      %subst(eupctx: 6: 1) = '/'
     C                   eval      %subst(eupctx: 7: 2) =
     C                                       %subst(wkalphadt: 1: 2)
      *
     C                   write     @eucpdq
      *
     C                   endsr
      /EJECT
      *---------------------------------------------------------------
      * $toccyymmdd - Flip a synon date to ccyymmdd
      *---------------------------------------------------------------
      *
     C     $toccyymmdd   begsr
      *
     C                   select
     C                   when      wksynoncen = 0
     C                   eval      wkcen = 19
     C                   other
     C                   eval      wkcen = 20
     C                   endsl
      *
     C                   eval      wkyer = wksynonyer
     C                   eval      wkmon = wksynonmon
     C                   eval      wkday = wksynonday
      *
     C                   endsr
      /EJECT
      *---------------------------------------------------------------
      * $tosynondt - Flip a CCYYMMDD value to SYNON's CYYMMDD format
      *---------------------------------------------------------------
      *
     C     $tosynondt    begsr
      *
     C                   select
     C                   when      wkcen = 19
     C                   eval      wksynoncen = 0
     C                   other
     C                   eval      wksynoncen = 1
     C                   endsl
      *
     C                   eval      wksynonyer = wkyer
     C                   eval      wksynonmon = wkmon
     C                   eval      wksynonday = wkday
      *
     C                   endsr
      /EJECT
      *---------------------------------------------------------------
      * $total - Write the 'total' outfile record
      *---------------------------------------------------------------
      *
     C     $total        begsr
      *
     C                   z-add     0             eudwdt
     C                   z-add     0             eudxdt
     C                   movel(p)  'TOTAL'       eupctx
      *
     C                   z-add     t1kdhd        eukdhd
     C                   z-add     t1dohd        eudohd
     C                   z-add     t1ydhd        euydhd
     C                   z-add     t1cdhd        eucdhd
     C                   z-add     t1sthd        eusthd
     C                   z-add     t1hrhd        euhrhd
     C                   z-add     t1nrhd        eunrhd
     C                   z-add     t1sthd        eusthd
      *
     C                   z-add     t1lvwt        eulvwt
     C                   z-add     t1htwt        euhtwt
     C                   z-add     t1gava        eugava
     C                   z-add     t1gbva        eugbva
     C                   z-add     t1gcva        eugcva
      *
     C                   z-add     t1abhd        euabhd
     C                   z-add     t1blhd        eublhd
     C                   z-add     t1brhd        eubrhd
     C                   z-add     t1gshd        eugshd
     C                   z-add     t1hvhd        euhvhd
     C                   z-add     t1lthd        eulthd
     C                   z-add     t1lchd        eulchd
     C                   z-add     t1mnhd        eumnhd
     C                   z-add     t1mshd        eumshd
     C                   z-add     t1othd        euothd
     C                   z-add     t1pqhd        eupqhd
     C                   z-add     t1qshd        euqshd
     C                   z-add     t1rbhd        eurbhd
     C                   z-add     t1schd        euschd
      *
     C                   exsr      $percents
      *
     C                   write     @eucpdq
      *
     C                   endsr
      /EJECT
      *---------------------------------------------------------------
      * *inzsr - initialization subroutine
      *---------------------------------------------------------------
      *
     C     *inzsr        begsr
      *
      * Parm lists
     C     *entry        plist
     C     euhonb        parm                    xxhmnb
     C     euabcd        parm                    xxabcd
     C                   parm                    xxb0dt
     C                   parm                    xxweeks
      *
      * Key lists
      *
     C     key01         klist
     C                   kfld                    euhonb
     C                   kfld                    eudwdt
      *
      *
     C     key03         klist
     C                   kfld                    a1hmnb
     C                   kfld                    a1bnnb
     C                   kfld                    a1bonb
     C                   kfld                    a1cvnb
     C                   kfld                    a1b0dt
      *
     C                   endsr
      /EJECT
