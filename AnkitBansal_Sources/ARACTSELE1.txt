     Z* CRTBNDRPG
     Z* DFTACTGRP(*NO) BNDDIR(YBNDDIR) DBGVIEW(*SOURCE)
     Z* CVTOPT(*DATETIME) ACTGRP(*CALLER) OPTIMIZE(*BASIC)
      *****************  RPG PROGRAM HEADING  ************************
      *
      * ENVIRONMENT:  J.D. Edwards
      * PROGRAM:      ARACTSELE1
      * TITLE:        Select Cost Center/Object/Subsidiary from JDE for Enterprise 1
      * AUTHOR:       Brad Baden   SDN465   TFS# 16169
      * CREATED:       3/13/2020
      *
      * FUNCTION: This is a select function window display of the J.D. Edwards
      *           Account Master file.
      *
      *           A record is selected by positioning the cursor on the line
      *           and pressing enter.
      *
      *           Restrictors:  Company (input capable)
      *
      *           Positioners:  Cost Center (alias: business unit)
      *
      *           Selectors:    object account
      *                         subsidiary
      *                         description
      *
      *
      * NOTE:    This is a pop-up window program.  Please note that in window
      *          programs the record format containing the window definition
      *          must be written first.
      *
      ****************************************************************
      * MODIFICATIONS:
      *  3/11/20  Brad Baden   SDN465   TFS# 16169
      *           This source was copied from source ARACTEDT in
      *           library JFOODCUST and renamed to ARACTEDTE1.
      *           The program will use the JDE Account Master
      *           defined in the Synon E1IDEVMDL instead of file
      *           F0901LE.  Change ARDACTSEL to ARDACTSELE.
      *           Replaced call to JD800 with program name JD800E1
      *           and  made the return code the first parameter.
      *
      /EJECT
      ****************************************************************
      * FILE SPECIFICATIONS
      ****************************************************************
      *
     F*ardactsel cf   e             workstn sfile(actsels1:hdrrn1)
     Fardactselecf   e             workstn sfile(actsels1:hdrrn1)
     F                                     infds(iofeed)
      *
     F*f0901le   if   e           k disk
     Fe10901le  if   e           k disk
      *    Account master
      *
      ****************************************************************
      * DEFINITION SPECIFICATIONS
      ****************************************************************
      *
      ****************************************************************
      * CONSTANTS
      ****************************************************************
      *
     D yes             c                   'Y'
     D no              c                   'N'
     D set1            c                   'SET1  '
     D edit1           c                   'EDIT1 '
     D scrn1           c                   'SCRN1 '
     D exit            c                   'EXIT  '
      *
     D upper           c                   'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
     D lower           c                   'abcdefghijklmnopqrstuvwxyz'
      *
      ****************************************************************
      * ARRAYS AND TABLES
      ****************************************************************
      *
      *
      ****************************************************************
      * STANDALONE FIELDS
      ****************************************************************
      *
      * Standard fields
      *
     D pgm             s             10
     D msgfl           s             10
     D routne          s              6
     D maxrrn          s              4  0
     D norecs          s              1    inz('N')
     D count           s              2  0
     D rtncd           s              2    inz('00')
     D svrrn1          s                   like(hdrrn1)
     D maxmsg          s              2  0  inz(20)
     D wkplin          s              2  0
      *
      *
      *
      * Workfields
      *
     D wkco            s              5
      *
      *
      * Workfields for description selection
      *
     D procfl          s              1
     D wklong          s              2  0
     D wkdesc          s                   like(c1dl01)
     D wk1desc         s                   like(c1dl01)
      *
      *
      * Parm fields
      *
     D xxretrn         s              7
     D xxco            s                   like(c1co)
     D xxmcu           s                   like(d1mcu)
     D xxobj           s                   like(d1obj)
     D xxsub           s                   like(d1sub)
     D xxconm          s             30
     D xxaid           s                   like(gmaid)
     D xxdesc          s                   like(gmdl01)
      *
      *
      * Save fields for positioners and selectors
      *
     D svco            s                   like(c1co)
     D svmcu           s                   like(d1mcu)
     D svobj           s                   like(d1obj)
     D svsub           s                   like(d1sub)
     D svdl01          s                   like(d1dl01)
      *
      ****************************************************************
      * DATA STRUCTURES
      ****************************************************************
      *
      *---------------------------------------------------------------
      * standard error message handling data structures
      *---------------------------------------------------------------
      *
      * For error message handling, a packed index (3) is required.
      * For program readability, define a corresponding error count
      * field called 'error'
      *
     D                 ds                  inz
     D  error                         2p 0
     D   e                            2p 0 overlay(error)
      *
      *---------------------------------------------------------------
      * Standard program status data structure
      *---------------------------------------------------------------
      *    externally defined as UTPGFR (record format: PGMDSR)
     D pgmds         esds                  extname(utpgfr)
      *
      *
      *---------------------------------------------------------------
      * Standard workstation information data structure
      *---------------------------------------------------------------
      *    externally defined as UTWSFR (record format: UTIDFRR)
     D iofeed        e ds                  extname(utwsfr)
      *
      *
      *---------------------------------------------------------------
      * Standard database file information data structure
      *---------------------------------------------------------------
      *    externally defined as UTDBGR (record format: FDBCKD)
     D dbfeed        e ds                  extname(utdbfr)
      *
      *
      * The following is a dummy C-spec to keep the D-specs from
      * running over into the C-specs on the compile listing. It
      * serves no other purpose and can be deleted at any time.
      *
     C                   if        sdpgm = *blank
     C                   endif
      /EJECT
      ****************************************************************
      * MAINLINE
      ****************************************************************
      *
     C                   eval      routne = set1
      *
     C     *inlr         doweq     *off                                         Main do loop
     C     routne        caseq     set1          $set1
     C     routne        caseq     scrn1         $scrn1
     C     routne        caseq     exit          $exit
     C                   endcs
     C                   enddo                                                  Main do loop
      /EJECT
      *---------------------------------------------------------------
      * Set environment for screen 1
      *---------------------------------------------------------------
      *
     C     $set1         begsr
      *
      * Clear/fill the subfile
      *
     C                   exsr      $clr1
     C                   exsr      $frsh1
      *
      * Set routine to display screen
      *
     C                   eval      routne = scrn1
      *
     C                   endsr
      /EJECT
      *---------------------------------------------------------------
      * Perform operator I/O for screen 1
      *---------------------------------------------------------------
      *
     C     $scrn1        begsr
      *
      * Write screen 1 to crt
      *
     C                   write     actselw1
     C                   write     actselk1
     C                   exfmt     actselc1
      *
      *
      * Get user's entry and set next routine
      *
     C                   select
     C                   when      *in03 = *on                                  F3=exit
     C                   eval      routne = exit
      *
      * Reposition the subfile if the user has changed any of the
      * positioners or selectors in the control record.
      *
     C                   when      c1mcu  <> svmcu or                           Positioners
     C                             c1obj  <> svobj or
     C                             c1sub  <> svsub or
     C                             c1dl01 <> svdl01 or
     C                             c1co   <> svco
      *
     C                   if        c1co <> svco
     C                   exsr      $conm
     C                   endif                                                                   nge
      *
     C                   if        error = 0
     C                   exsr      $chksv
     C                   else
     C                   eval      routne = scrn1
     C                   endif
      *
     C                   when      *in25 = *on                                  F25-rollup
     C                   exsr      $load1
     C                   eval      routne = scrn1
     C                   other
      *
      * User has pressed enter
      *
     C                   if        norecs = yes                                 If empty sfl
     C                   eval      routne = set1
     C                   else
     C                   exsr      $proc1
     C                   endif                                                  If empty sfl
     C                   endsl
      *
     C                   endsr
      /EJECT
      *----------------------------------------------------------------
      * Edit Company
      *----------------------------------------------------------------
      *
      * Valdiations:
      *   1) not required
      *
     C     $conm         begsr
      *
     C                   move      *blank        c1conm
      *
      * The 'company' field that is passed in as a parm and the field in the control
      * record are 3A. To retrieve the name from the JDE file, we muat have a company
      * field that is 5A with the first two positions populated with '00'.
      *
     C                   eval      %subst(wkco: 1: 2) = '00'
     C                   eval      %subst(wkco: 3: 3) = c1co
      *
      * Retrieve company name for display
      *
     C*                  call      'JD800'
     C*                  parm                    wkco
     C*    c1conm        parm      *blank        xxconm
     C*                  parm      *blank        xxretrn
      *
     C                   call      'JD800E1'
     C                   parm      *blank        xxretrn
     C                   parm                    wkco
     C     c1conm        parm      *blank        xxconm
      *
     C                   if        xxretrn <> *blank
     C                   eval      wkco = '00000'
     C                   endif
      *
     C                   endsr
      /EJECT
      *----------------------------------------------------------------
      * Process user's selection
      *----------------------------------------------------------------
      *
     C     $proc1        begsr
      *
      * If cursor location returned is the rrn of a record in the
      * subfile, chain to the subfile record and load the data into
      * the parms to return to the calling program.
      *
     C                   if        hdrrn <> 0                                   If selected
     C                   eval      hdrrn1 = hdrrn
     C     hdrrn1        chain     actsels1                           92
     C                   eval      xxaid = hdaid
     C                   eval      xxsub = d1sub
     C                   eval      xxobj = d1obj
     C                   eval      xxmcu = d1mcu
     C                   eval      xxdesc = d1dl01
      *
      * If the user selected a record, set the routine to exit.  If no record
      * was selected, redisplay the screen.
      *
     C                   if        xxaid = *blank
     C                   eval      hdpag1 = idflow
     c                   eval      routne = scrn1
     C                   else
     c                   eval      routne = exit
     C                   endif
     C                   endif                                                  If selected
      *
     C                   endsr
      /EJECT
      *----------------------------------------------------------------
      * Save the control record positioners/selectors
      *----------------------------------------------------------------
      *                                                                        z
     C     $chksv        begsr
      *
     C                   eval      routne = set1
      *
      * Prepare to scan on description
      *  1) trim leading/trailing blanks
      *  2) find first non-blank position from right
      *
     C                   if        c1dl01 <> svdl01
     C                   eval      c1dl01 = %trim(c1dl01)
     C     ' '           checkr    c1dl01        wklong
     C                   endif
      *
     C                   eval      svmcu  = c1mcu
     C                   eval      svobj  = c1obj
     C                   eval      svsub  = c1sub
     C                   eval      svdl01 = c1dl01
     C                   eval      svco   = c1co
      *
     C                   endsr
      /EJECT
      *---------------------------------------------------------------
      * Clear subfile for screen 1
      *---------------------------------------------------------------
      *
     C     $clr1         begsr
      *
     C                   eval      svrrn1 = 0
      *
     C                   clear                   actsels1
     C                   seton                                        83        sflclr
     C                   write     actselc1
     C                   setoff                                       818283
      *                                                    81=sfldsp
      *                                                    82=sflend
      *                                                    83=sflclr
     C                   endsr
      /EJECT
      *---------------------------------------------------------------
      * Refresh/fill the subfile for screen 1
      *---------------------------------------------------------------
      *
     C     $frsh1        begsr
      *
      *
     C*    key01         setll     f0901le
     c     key01         setll     e10901le
      *
      * This program does not have repositioning; just start the subfile over
      *
     C                   eval      maxrrn = wkplin
      *
      * Load the subfile until you have the required number of records.
      * The number will depend on whether uou are repositioning the
      * subfile or not. Stop if you get to the end of the subfile.
      *
     C*                  dou       svrrn1 >= maxrrn or *in82 = *on
     c                   dou       svrrn1 >= maxrrn or %eof(e10901le)
     C                   exsr      $load1
     C                   enddo
      *
     C                   endsr
      /EJECT
      *---------------------------------------------------------------
      * Load subfile for screen 1
      *---------------------------------------------------------------
      *
     C     $load1        begsr
      *
     C                   eval      hdrrn1 = svrrn1
      *
      * Set the count of records on the subfile page to zero.
      *
     C                   eval      count = 0
      *
      * Fill the subfile until the end of the database file or
      * you have filled all the lines on the subfile page.
      *
     C                   setoff                                       82
     C*                  dou       *in82 = *on or count >= wkplin               Do fill
     c                   dou       %eof(e10901le) or count >= wkplin            Do fill
      *
     C                   if        wkco = '00000'
     C*                  read      f0901le                                82
     c                   read      e10901le
     C                   else
     C*    wkco          reade     f0901le                                82
     c     wkco          reade     e10901le
     C                   endif
      *
     C*                  if        *in82 = *off and                             If read
     c                   if        %found(e10901le) and                         if %found(e10901le)
     C                             gmpec <> 'N' and
     C                             gmpec <> 'I'
     C                   eval      procfl = yes
      *
      * Only include records that match the user's selectors
      *
     C                   if        c1dl01  <> *blank                            If desc
     C     lower:upper   xlate     c1dl01        wkdesc
     C     lower:upper   xlate     gmdl01        wk1desc
     C     wkdesc:wklong scan      wk1desc                                92
     C                   if        *in92 = *off
     C                   eval      procfl = no
     C                   endif
     C                   endif                                                  If desc
      *
      *
     C                   if        procfl = yes                                 If process
      *
     C                   if        c1obj <> *blank and                          If object
     C                             c1obj <> gmobj
     C                   else
      *
     C                   if        c1sub <> *blank and                          If subsidiary
     C                             c1sub <> gmsub
     C                   else
      *
     C                   add       1             count
     C                   add       1             hdrrn1
     C                   eval      hdaid = gmaid
     C                   eval      d1mcu = gmmcu
     C                   eval      d1obj = gmobj
     C                   eval      d1sub = gmsub
     C                   eval      d1dl01 = gmdl01
     C                   write     actsels1
     C                   seton                                        81
      *
      * For positioning, place the subfile relative record number into the
      * sflrcdnbr field (HDPAG1)
      *
     C                   eval      hdpag1 = hdrrn1
     C                   endif                                                  If object
     C                   endif                                                  If subsidiary
     C                   endif                                                  If process
     C                   endif                                                  fi %found(e10901le)
     C                   enddo                                                  Do fill
      *
     C                   if        hdrrn1 = 0                                   If no recs
     C                   eval      norecs = yes
     C                   else
     C                   eval      norecs = no
     C                   endif                                                  If no recs
      *
     C                   eval      svrrn1 = hdrrn1
      *
     C                   endsr
      /EJECT
      *---------------------------------------------------------------
      * End job
      *---------------------------------------------------------------
      *
     C     $exit         begsr
     C                   seton                                        LR
     C                   endsr
      /EJECT
      *---------------------------------------------------------------
      * Initialization subroutine
      *---------------------------------------------------------------
      *
     C     *inzsr        begsr
      *
      * Key lists
      *
     C     key01         klist
     C                   kfld                    wkco
     C                   kfld                    c1mcu
      *
      *
      * Parm lists
      *
     C     *entry        plist
     C     c1co          parm                    xxco
     C     d1mcu         parm                    xxmcu
     C     d1obj         parm                    xxobj
     C     d1sub         parm                    xxsub
     C                   parm                    xxaid
     C                   parm                    xxdesc
     C                   parm                    xxretrn
      *
     C                   eval      svmcu = c1mcu
      *
      * Retrieve Company Name
      *
     C                   exsr      $conm
      *
      * To support subfile paging in select windows, the program needs
      * the number of lines on a subfile page.
      *
     C                   eval      wkplin = 8                                   sflpag(0008)
      *
      * Set on the indicator to always position cursor to the 'name'
      * selector field in the control record.
      *
     C                   seton                                        84
      *
      * Execute required window format
      *
     C                   write     assume
      *
     C                   endsr
      /EJECT
