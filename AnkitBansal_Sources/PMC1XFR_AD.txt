// ?------------------------------------------------------------------------------------------------
// ?Synon action diagram for PMC1XFR
// ?Date: 14.08.2025 Time: 03:44:45
// ?------------------------------------------------------------------------------------------------

//?Execute user function

//?Modifications and Comments
DO;

//?** 05/19/16   RMC E4119  remove live with tpm check
//?01/20/16 JJH E4687 - Load Scheduling Positioning with Mercury Gate
//?- If Live with TPM = Yes, use the "MG RTV LD Stop/DropNb RT -
//?  Order Header Ext" function to get the Ld Stop/Drop.
ENDDO;

//?01/20/16 JJH E4687 - Load Scheduling Positioning with Mercury Gate
//?- If Live with TPM = Yes, use the "MG RTV LD Stop/DropNb RT -
//?  Order Header Ext" function to get the Ld Stop/Drop.
EXECUTE FUNCTION(Rtv/Crt LdSchPosition RT) TYPE(RTVOBJ) FILE(PDMJCPP)           AC1913832;
{
 //?USER: Initialize routine

 // WRK.First Time Flag = CND.Yes
 WRK.First_Time_Flag = 'Y';

 // LCL.Scheduled Ship Date = CON.*ZERO
 LCL.Scheduled_Ship_Date = *ZERO;

 //?USER: Process Data record

 //?slm * out due to thinking this was used for testing
 //?slm * SEE what is wrong with * out this function
 CASE;

 // IF DB1.Item Code is Review specific Item
 IF DB1.Item_Code = 2310;

 // Send information message - 'Condition Found for this specific item'
 MESSAGE(USR4187 *INFO);

 // IF DB1.Item Code is Review specific Item2
 IF DB1.Item_Code = 11610;

 // Send information message - 'Condition Found for this specific item'
 MESSAGE(USR4187 *INFO);

 // IF DB1.Item Code is Review specific Item3
 IF DB1.Item_Code = 26010;

 // Send information message - 'Condition Found for this specific item'
 MESSAGE(USR4187 *INFO);

 ENDIF;

 CASE;

 // IF WRK.First Time Flag is Yes
 IF WRK.First_Time_Flag = 'Y';

 // WRK.First Time Flag = CND.NO
 WRK.First_Time_Flag = 'N';

 // LCL.Item Code USR = DB1.Item Code
 LCL.Item_Code_USR = DB1.Item_Code;

 // LCL.LSPK Order Warehouse = DB1.LSPK Order Warehouse
 LCL.LSPK_Order_Warehouse = DB1.LSPK_Order_Warehouse;

 // LCL.LSPK Order Company = DB1.LSPK Order Company
 LCL.LSPK_Order_Company = DB1.LSPK_Order_Company;

 // LCL.LSPK Production Whse = DB1.LSPK Production Whse
 LCL.LSPK_Production_Whse = DB1.LSPK_Production_Whse;

 // LCL.LSPK Accounting Company = DB1.LSPK Accounting Company
 LCL.LSPK_Accounting_Company = DB1.LSPK_Accounting_Company;

 ENDIF;

 //?Break in Item Code or Whs:  Output Final Position Rcd and Reset fields
 CASE;

 // IF DB1.Item Code NE LCL.Item Code USR
 IF DB1.Item_Code <> LCL.Item_Code_USR;

 // OR DB1.LSPK Order Warehouse NE LCL.LSPK Order Warehouse
 OR DB1.LSPK_Order_Warehouse <> LCL.LSPK_Order_Warehouse;

 // OR DB1.LSPK Order Company NE LCL.LSPK Order Company
 OR DB1.LSPK_Order_Company <> LCL.LSPK_Order_Company;

 // OR DB1.LSPK Production Whse NE LCL.LSPK Production Whse
 OR DB1.LSPK_Production_Whse <> LCL.LSPK_Production_Whse;

 // OR DB1.LSPK Accounting Company NE LCL.LSPK Accounting Company
 OR DB1.LSPK_Accounting_Company <> LCL.LSPK_Accounting_Company;

 // LCL.Seq if on a load      USR = CON.*ZERO
 LCL.Seq_if_on_a_load_USR = *ZERO;

 // LCL.Seq if not on Load    USR = CON.99899
 LCL.Seq_if_not_on_Load_USR = 99899;

 // LCL.Item Code USR = DB1.Item Code
 LCL.Item_Code_USR = DB1.Item_Code;

 // LCL.LSPK Order Warehouse = DB1.LSPK Order Warehouse
 LCL.LSPK_Order_Warehouse = DB1.LSPK_Order_Warehouse;

 // LCL.LSPK Order Company = DB1.LSPK Order Company
 LCL.LSPK_Order_Company = DB1.LSPK_Order_Company;

 // LCL.LSPK Production Whse = DB1.LSPK Production Whse
 LCL.LSPK_Production_Whse = DB1.LSPK_Production_Whse;

 // LCL.LSPK Accounting Company = DB1.LSPK Accounting Company
 LCL.LSPK_Accounting_Company = DB1.LSPK_Accounting_Company;

 // LCL.Scheduled Ship Date = CON.*ZERO
 LCL.Scheduled_Ship_Date = *ZERO;

 // LCL.Actual Inventory = CON.*ZERO
 LCL.Actual_Inventory = *ZERO;

 // WRK.Scheduled Production = CON.*ZERO
 WRK.Scheduled_Production = *ZERO;

 // WRK.USR Flag 1 = CND.No
 WRK.USR_Flag_1 = 'N';

 // LCL.Scheduling Position = CON.*ZERO
 LCL.Scheduling_Position = *ZERO;

 ENDIF;

 //?** Save previous rcd's qtys needed to calculate current rcd's qtys
 // LCL.Actual Production = CON.*ZERO
 LCL.Actual_Production = *ZERO;

 // LCL.Scheduled Production = CON.*ZERO
 LCL.Scheduled_Production = *ZERO;

 // LCL.Scheduled Quantity = DB1.Scheduled Quantity
 LCL.Scheduled_Quantity = DB1.Scheduled_Quantity;

 // LCL.Scheduling Position = CON.*ZERO
 LCL.Scheduling_Position = *ZERO;

 // WRK.Scheduling Position = CON.*ZERO
 WRK.Scheduling_Position = *ZERO;

 //?** Scheduled Ship Date Break
 //?****** Scheduled ship date ******
 CASE;

 // IF DB1.Scheduled Ship Date NE LCL.Scheduled Ship Date
 IF DB1.Scheduled_Ship_Date <> LCL.Scheduled_Ship_Date;

 // WRK.USR First Time = CND.No
 WRK.USR_First_Time = 'N';

 // LCL.Scheduled Ship Date = DB1.Scheduled Ship Date
 LCL.Scheduled_Ship_Date = DB1.Scheduled_Ship_Date;

 //?do not perform the production fields population
 ENDIF;

 //?******** Scheduling Position ********
 //?Read the WF Item Position Balance and get the Grade
 DO;

 CASE;

 // IF DB1.Load ID is Blank
 IF DB1.Load_ID = *ZERO;

 //?Dont grade if the load id is blank
 // LCL.Order Grade = WRK.BLANK
 LCL.Order_Grade = WRK.BLANK;

 // IF DB1.Scheduled Quantity is Equal to Zero
 IF DB1.Scheduled_Quantity = *ZERO;

 // AND DB1.Picked to Order is LT Zero
 AND DB1.Picked_to_Order < *ZERO;

 //?Dont grade if the load id is blank
 // LCL.Order Grade = WRK.BLANK
 LCL.Order_Grade = WRK.BLANK;

 // IF *OTHERWISE
 IF *OTHERWISE;

 //?get the grade (send in the SchedQty & Picked to Order) & use
 //?the scheduled qty to reduce the onhand requirement
 // WRK.Schedule Qty Grade Usr = DB1.Scheduled Quantity - DB1.Picked to Order
 WRK.Schedule_Qty_Grade_Usr = DB1.Scheduled_Quantity - DB1.Picked_to_Order;

 EXECUTE FUNCTION(Rtv/Chg ItemPostAlloc RT) TYPE(RTVOBJ) FILE(PME0CPP)           AC1914065;
 PARAMETER(DB1.Item_Code);
 PARAMETER(DB1.LSPK_Accounting_Company);
 PARAMETER(DB1.LSPK_Production_Whse);
 PARAMETER(DB1.LSPK_Order_Company);
 PARAMETER(DB1.LSPK_Order_Warehouse);
 PARAMETER(DB1.LSPK_Production_Date);
 PARAMETER(DB1.Scheduled_Quantity);
 PARAMETER(DB1.Picked_to_Order);
 PARAMETER(WRK.Schedule_Qty_Grade_Usr);
 {
  //?USER: Initialize routine

  // WRK.Production Date USR = PAR.Production Date
  WRK.Production_Date_USR = PAR.Production_Date;

  // LCL.Schedule Qty Grade Usr = PAR.Schedule Qty Grade Usr
  LCL.Schedule_Qty_Grade_Usr = PAR.Schedule_Qty_Grade_Usr;

  // LCL.Picked to Order Usr = PAR.Picked to Order
  LCL.Picked_to_Order_Usr = PAR.Picked_to_Order;

  // LCL.First Time Flag = CND.Yes
  LCL.First_Time_Flag = 'Y';

  //?USER: Process Data record

  // LCL.Read Another Record Usr = CND.no
  LCL.Read_Another_Record_Usr = 'N';

  CASE;

  // IF DB1.IPB New Current Position is LE Zero
  IF DB1.IPB_New_Current_Position <= *ZERO;

  // IF LCL.Schedule Qty Grade Usr is Greater than Zero
  IF LCL.Schedule_Qty_Grade_Usr > *ZERO;

  //?Calculate fields
  DO;

  //?Current record from Load Pst Key must now be applied
  // LCL.IPB New Current Position = DB1.IPB New Current Position
  LCL.IPB_New_Current_Position = DB1.IPB_New_Current_Position;

  CASE;

  // IF LCL.Schedule Qty Grade Usr GT LCL.IPB New Current Position
  IF LCL.Schedule_Qty_Grade_Usr > LCL.IPB_New_Current_Position;

  //?new current balance and what was used same thing
  //?there is a balance left over so read another record
  // LCL.Used for Order = LCL.IPB New Current Position
  LCL.Used_for_Order = LCL.IPB_New_Current_Position;

  // LCL.Read Another Record Usr = CND.yes
  LCL.Read_Another_Record_Usr = 'Y';

  // IF LCL.Schedule Qty Grade Usr LE DB1.IPB New Current Position
  IF LCL.Schedule_Qty_Grade_Usr <= DB1.IPB_New_Current_Position;

  // AND LCL.First Time Flag is Yes
  AND LCL.First_Time_Flag = 'Y';

  //?what is being processed = what came in
  //?total is schedule
  //?there is no left over
  // LCL.Used for Order = LCL.Schedule Qty Grade Usr
  LCL.Used_for_Order = LCL.Schedule_Qty_Grade_Usr;

  // IF *OTHERWISE
  IF *OTHERWISE;

  //?SUSAN4 LOOK AT  THIS
  // LCL.Used for Order = LCL.Schedule Qty Grade Usr
  LCL.Used_for_Order = LCL.Schedule_Qty_Grade_Usr;

  ENDIF;

  ENDDO;

  //?Update the WF Item Position Balance
  DO;

  // WRK.Schedule Qty Grade Usr = LCL.Schedule Qty Grade Usr
  WRK.Schedule_Qty_Grade_Usr = LCL.Schedule_Qty_Grade_Usr;

  CASE;

  // IF LCL.First Time Flag is Yes
  IF LCL.First_Time_Flag = 'Y';

  //?apply the Sched Qty Picked to Order and the Used for Order
  //?for the first record only
  EXECUTE FUNCTION(Chg WF ItemAppSchPkUsdCH) TYPE(CHGOBJ) FILE(PME0CPP)           AC1914081;
  PARAMETER(DB1.Item_Code);
  PARAMETER(DB1.IPB_Accounting_Company);
  PARAMETER(DB1.IPB_Production_Warehouse);
  PARAMETER(DB1.IPB_Order_Company);
  PARAMETER(DB1.IPB_Order_Warehouse);
  PARAMETER(DB1.Production_Date);
  PARAMETER(PAR.Scheduled_Quantity);
  PARAMETER(PAR.Picked_to_Order);
  PARAMETER(LCL.Used_for_Order);
  {
   //?USER: Processing after Data read

   //?Accumulate to individual fields
   // DB1.IPB Chg Sched Qty = DB1.IPB Chg Sched Qty + PAR.Chg Sched Qty usr
   DB1.IPB_Allocated_Sched_Qty = DB1.IPB_Allocated_Sched_Qty + PAR.Chg_Sched_Qty_usr;

   // DB1.IPB Chg Picked to Order = DB1.IPB Chg Picked to Order + PAR.Chg Picked to Order usr
   DB1.IPB_Allocated_Picked = DB1.IPB_Allocated_Picked + PAR.Chg_Picked_to_Order_usr;

   // DB1.IPB Chg Used On Orders = DB1.IPB Chg Used On Orders + PAR.Chg Used On Orders Usr
   DB1.IPB_Total_Used = DB1.IPB_Total_Used + PAR.Chg_Used_On_Orders_Usr;

   //?calculate the extended amount
   // DB1.IPB New Current Position = DB1.IPB Current Position - DB1.IPB Chg Used On Orders
   DB1.IPB_New_Current_Position = DB1.IPB_Start_Position - DB1.IPB_Total_Used;

  }

  CASE;

  // IF LCL.Used for Order is Greater than Zero
  IF LCL.Used_for_Order > *ZERO;

  // WRK.Schedule Qty Grade Usr = WRK.Schedule Qty Grade Usr - LCL.Used for Order
  WRK.Schedule_Qty_Grade_Usr = WRK.Schedule_Qty_Grade_Usr - LCL.Used_for_Order;

  // IF *OTHERWISE
  IF *OTHERWISE;

  // WRK.Schedule Qty Grade Usr = WRK.Schedule Qty Grade Usr - PAR.Scheduled Quantity
  WRK.Schedule_Qty_Grade_Usr = WRK.Schedule_Qty_Grade_Usr - PAR.Scheduled_Quantity;

  // WRK.Schedule Qty Grade Usr = WRK.Schedule Qty Grade Usr - PAR.Picked to Order
  WRK.Schedule_Qty_Grade_Usr = WRK.Schedule_Qty_Grade_Usr - PAR.Picked_to_Order;

  ENDIF;

  // LCL.First Time Flag = CND.NO
  LCL.First_Time_Flag = 'N';

  // IF *OTHERWISE
  IF *OTHERWISE;

  //?apply the Used for Order for the remainding of the balance on
  //?then order
  EXECUTE FUNCTION(Chg WF ItemApp     UsdCH) TYPE(CHGOBJ) FILE(PME0CPP)           AC1914604;
  PARAMETER(DB1.Item_Code);
  PARAMETER(DB1.IPB_Accounting_Company);
  PARAMETER(DB1.IPB_Production_Warehouse);
  PARAMETER(DB1.IPB_Order_Company);
  PARAMETER(DB1.IPB_Order_Warehouse);
  PARAMETER(DB1.Production_Date);
  PARAMETER(LCL.Used_for_Order);
  {
   //?USER: Processing after Data read

   //?Accumulate to individual fields
   // DB1.IPB Chg Used On Orders = DB1.IPB Chg Used On Orders + PAR.Chg Used On Orders Usr
   DB1.IPB_Total_Used = DB1.IPB_Total_Used + PAR.Chg_Used_On_Orders_Usr;

   //?calculate the extended amount
   // DB1.IPB New Current Position = DB1.IPB Current Position - DB1.IPB Chg Used On Orders
   DB1.IPB_New_Current_Position = DB1.IPB_Start_Position - DB1.IPB_Total_Used;

  }

  // WRK.Schedule Qty Grade Usr = WRK.Schedule Qty Grade Usr - LCL.Used for Order
  WRK.Schedule_Qty_Grade_Usr = WRK.Schedule_Qty_Grade_Usr - LCL.Used_for_Order;

  ENDIF;

  // LCL.Schedule Qty Grade Usr = WRK.Schedule Qty Grade Usr
  LCL.Schedule_Qty_Grade_Usr = WRK.Schedule_Qty_Grade_Usr;

  // PAR.Schedule Qty Grade Usr = WRK.Schedule Qty Grade Usr
  PAR.Schedule_Qty_Grade_Usr = WRK.Schedule_Qty_Grade_Usr;

  ENDDO;

  CASE;

  // IF LCL.Schedule Qty Grade Usr is Greater than Zero
  IF LCL.Schedule_Qty_Grade_Usr > *ZERO;

  // IF *OTHERWISE
  IF *OTHERWISE;

  QUIT;

  ENDIF;

  ENDIF;

 }

 //?****** Grade the order ****** must be done in this sequence
 //?as of this time we will not be using the grade of  A
 //?** C = order needs actual inventory to be filled
 //?** X = order cannot be filled
 //?SCHEDULE QTY >0  NEED MORE INVENTORY
 //?SCHEDULE QTY 0 HAS INVENTORY OR THERE IS INVENTORY TO COVER
 CASE;

 // IF WRK.Schedule Qty Grade Usr GT WRK.ZERO
 IF WRK.Schedule_Qty_Grade_Usr > WRK.ZERO;

 // LCL.Order Grade = CND.Cant be filled
 LCL.Order_Grade = 'X';

 // IF *OTHERWISE
 IF *OTHERWISE;

 // LCL.Order Grade = CND.Actual Inventory only
 LCL.Order_Grade = 'C';

 ENDIF;

 ENDIF;

 ENDDO;

 //?**
 //?** Create the position record with seq, quantities and order grade
 CASE;

 // IF DB1.Schedule Sequence Number is 99999
 IF DB1.Schedule_Sequence_Number = 99999;

 // LCL.Schedule Sequence Number = CND.Zero
 LCL.Schedule_Sequence_Number = *ZERO;

 // IF *OTHERWISE
 IF *OTHERWISE;

 // LCL.Schedule Sequence Number = DB1.Schedule Sequence Number
 LCL.Schedule_Sequence_Number = DB1.Schedule_Sequence_Number;

 ENDIF;

 // LCL.Scheduling Position = WRK.Schedule Qty Grade Usr * CON.-1 *
 LCL.Scheduling_Position = WRK.Schedule_Qty_Grade_Usr * -1;

 //?01/20/16 JJH E4687 - Load Scheduling Positioning with Mercury Gate
 EXECUTE FUNCTION(Crt Load Schdlng Pstn CR) TYPE(CRTOBJ) FILE(PDMHCPP)           AC1514133;
 PARAMETER(DB1.Item_Code);
 PARAMETER(DB1.LSPK_Accounting_Company);
 PARAMETER(DB1.LSPK_Production_Whse);
 PARAMETER(DB1.LSPK_Order_Company);
 PARAMETER(DB1.LSPK_Order_Warehouse);
 PARAMETER(DB1.Sequence);
 PARAMETER(DB1.Record_Type);
 PARAMETER(LCL.Thru_Scheduled_Ship_Date);
 PARAMETER(DB1.Order_Number);
 PARAMETER(DB1.Load_ID);
 PARAMETER(DB1.Scheduled_Ship_Date);
 PARAMETER(DB1.Event_Code);
 PARAMETER(LCL.Actual_Inventory);
 PARAMETER(DB1.Picked_to_Order);
 PARAMETER(LCL.Available_Inventory);
 PARAMETER(LCL.Actual_Production);
 PARAMETER(LCL.Scheduled_Production);
 PARAMETER(LCL.Available_Production);
 PARAMETER(DB1.Scheduled_Quantity);
 PARAMETER(LCL.Scheduling_Position);
 PARAMETER(DB1.Deadline_Departure_Date);
 PARAMETER(DB1.Deadline_Departure_Time);
 PARAMETER(LCL.Order_Grade);
 PARAMETER(WRK.BLANK);
 PARAMETER(WRK.BLANK);
 PARAMETER(WRK.BLANK);
 PARAMETER(WRK.BLANK);
 PARAMETER(LCL.Schedule_Sequence_Number);
 PARAMETER(DB1.LSPK_Order_Aged_Code);
 PARAMETER(DB1.LSPK_Production_Date);
 PARAMETER(DB1.Process_Sequence);
 PARAMETER(DB1.Item_Age_Days);
 PARAMETER(DB1.Production_Ovr_AgeDte_Fr);
 PARAMETER(DB1.Production_Ovr_AgeDte_To);
 PARAMETER(DB1.Production_AgeDte_Fr);
 PARAMETER(DB1.Production_AgeDte_To);
 PARAMETER(DB1.EDI_Status_1);
 PARAMETER(DB1.EDI_Status_2);
 PARAMETER(DB1.EDI_Status_3);
 PARAMETER(DB1.Record_Status);
 PARAMETER(DB1.Job_Time);
 PARAMETER(DB1.User_Id);
 PARAMETER(DB1.Job_Name);
 PARAMETER(DB1.Job_Date);
 {
  //?USER: Processing before Data update

  EXECUTE FUNCTION(SET Record Stamp CRTOB IF) TYPE(EXCINTFUN)                     AC1282865;
  PARAMETER(DB1.Record_Status);
  PARAMETER(DB1.Job_Time);
  PARAMETER(DB1.User_Id);
  PARAMETER(DB1.Job_Name);
  PARAMETER(DB1.Job_Date);
  {
   //?Execute internal function

   // PAR.Record Status = CND.Active
   PAR.Record_Status = 'A';

   // PAR.Job Time = JOB.*Job time
   PAR.Job_Time = JOB.*Job_time;

   // PAR.User Id = JOB.*USER
   PAR.User_Id = JOB.*USER;

   // PAR.Job Name = JOB.*PROGRAM
   PAR.Job_Name = JOB.*PROGRAM;

   // PAR.Job Date = JOB.*Job date
   PAR.Job_Date = JOB.*Job_date;

  }

  //?01/20/16 JJH E4687 - Load Scheduling Positioning with Mercury Gate
  //?** 05/19/16   RMC E4119  remove live with tpm check
  EXECUTE FUNCTION(RTV Get Stop Number) TYPE(RTVOBJ) FILE(OMFLCPP)                AC1836443;
  PARAMETER(PAR.Load_ID);
  PARAMETER(DB1.Stop_Drop);
  PARAMETER(PAR.Order_Number);
  {
   //?USER: Processing if Data record not found

   MOVE *ALL (To: PAR From: CON);

   // PGM.*Return code = CND.*Record does not exist
   PGM.*Return_code = 'Y2U0005';

   //?USER: Process Data record

   MOVE *ALL (To: PAR From: DB1);

   // PGM.*Return code = CND.*Record already exists
   PGM.*Return_code = 'Y2U0003';

   QUIT;

  }

 }

}


