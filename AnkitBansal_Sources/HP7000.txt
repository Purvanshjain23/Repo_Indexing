      *
      * SYSTEM:      Hog Production
      * PROGRAM:     HP7000
      * TITLE:       View BGF Weekly Production (includes summarized Daily production)
      * PROGRAMMER:  LeAnne Fedor
      * CREATED:     12/20/01
      *
      * FUNCTION: This View display the summarized daily data along with the Weekly data.
      *
      *
      ****************************************************************
      * MODIFICATIONS:
      ****************************************************************
      * DATE      PROGRAMMER
      *
      * 09/17/02  LeAnne Fedor
      *           Added new fields:
      *              average lactation pounds
      *              arrived sows
      *              transferred out open gilts
      *              transferred out open sows
      *           Removed:
      *                   beginning piglet inventory
      *           Changed text:
      *             transferred in gilts    became    transferred in bred gilts
      *             transferred in sows     became    transferred in bred sows
      *             transferred out gilts   became    transferred out bred gilts
      *             transferred out sows    became    transferred out bred sows
      *
      * 11/17/02  LeAnne Fedor
      *           Replaced 'de-pop flag' with 'population code'.
      *
      * 06/28/04  LeAnne Fedor
      *           Added 1 new field: Number of Gilts Bred with Passed Dates
      *           Removed 10 fields: number of good piglets farrowed
      *                              number of dome heads
      *                              number of splays
      *                              number of weak and lethargic
      *                              number of scours
      *                              number of good piglets weaning next
      *                              number of lame
      *
      * 02/07/05  LeAnne Fedor
      *           Added new field 'Transferred In Open Gilts' to screen 2. Moved
      *           '% Female Mortatlity' to Screen 3 to make room.
      *
      * 01/30/06  LeAnne Fedor
      *           The calculation of "Piglets Weaned per Litter" has been changed:
      *           FROM: total pigs weaned /
      *                              (15-16 day weaned sows + 17 Day weaned sows)
      *           TO:   total pigs weaned /
      *                     (early weaned sows + 15-16 day weaned sows + 17 Day weaned sows)
      *
      * 06/15/06  LeAnne Ramsey
      *           Added a new field "Avg Gilt Weight @ 28 Weeks".
      *
      * 10/19/07  LeAnne Ramsey
      *           Recompile only. The users are switching "manhours" from being
      *           "total" manhours for the week to being the "average" manhours
      *           for the week. So, added the word "average" to the text on the
      *           screen.
      *
      * 08/04/08  LeAnne Ramsey
      *           Deleted fields: BPPSGLSV - Nbr Gilts Bred w/Passed Date
      *                           BPP2LT   - Total P2 Litters Farrowed
      *                           BPADGB   - Avg Gilt Age @ Breeding-Days
      *                           BPGLAVLB - Avg Gilt Weight @ 28 Weeks
      *                           BPWSLB   - Weekly Ending Lbs Supplement Used
      *                           BP17WNLT - 17+ Day Weaned Sows
      *                           BPIOGLHD - Transferred in Open Gilts
      *                           BPOOGLHD - Gilts Transferred Out Open
      *
      * 09/19/08  LeAnne Ramsey
      *           Recompile only.
      *           The users are switching "average manhours" back to "total manhours".
      *           So, removed the word "average" from the screen text.
      *
      * 10/16/13  LeAnne Ramsey (E2831)
      *           Recompile only. Added field 'MTech Reference'.
      /eject
      ****************************************************************
      * FILE SPECIFICATIONS
      ****************************************************************
      *
     Fhpd7000   cf   e             workstn
     F                                     infds(iofeed)
      *
      *
      *
     Fhsp018    if   e           k disk
      *    Farm site
      *
      *
      *
     Fhsl092a   if   e           k disk    rename(bprec:bpreca) prefix(p1)
      *    BGF weekly production
      *
      *
     Fhsl092b   if   e           k disk    rename(bprec:bprecb)
      *    BGF weekly production
      *
      *
     Fhsp093    if   e           k disk
      *    BGF farrowing and pregnancy check events
      *
      *
     Fhsp104    if   e           k disk
      *    Population code
      /eject
      ****************************************************************
      * DEFINITION SPECIFICATIONS
      ****************************************************************
      *
      ****************************************************************
      * CONSTANTS
      ****************************************************************
      *
     D view            c                   'VIEW  '
     D yes             c                   'Y'
     D no              c                   'N'
     D set             c                   'SET   '
     D scrn1           c                   'SCRN1 '
     D scrn2           c                   'SCRN2 '
     D scrn3           c                   'SCRN3 '
     D exit            c                   'EXIT  '
      *
      *
      ****************************************************************
      * ARRAYS AND TABLES
      ****************************************************************
      *
      ****************************************************************
      * STANDALONE FIELDS
      ****************************************************************
      *
      * Standard fields
      *
     D mode            s              6
     D pgm             s             10
     D msgfl           s             10
     D routne          s              6
     D rtncd           s              2
     D action          s                   like(mode)
     D maxmsg          s              2  0  inz(20)
     D notflg          s              1    inz('N')
      *
      *
      * Work fields
      *
     D wkfld15         s             15  0
     D wkfld152        s             15  2
     D wkfld155        s             15  5
     D wkwnlt          s                   like(bpwnlt)
      *
      *
      * Work fields for date manipulation
      *
     D wkwedt          s              8  0
     D wkwk            s                   like(bpcdwk)
     D wkyr            s                   like(bpcdyr)
     D wkmdydate       s               D   datfmt(*mdy)
      *
      *
      * Parm fields
      *
     D xxfscd          s                   like(bpfscd)
     D xxwedt          s                   like(bpwedt)
      *
      ****************************************************************
      * DATA STRUCTURES
      ****************************************************************
      *
      *---------------------------------------------------------------
      * standard error message handling data structures
      *---------------------------------------------------------------
      *
      * For error message handling, a packed index (3) is required.
      * For program readability, define a corresponding error count
      * field called 'error'
      *
     D                 ds                  inz
     D  error                         2p 0
     D   e                            2p 0 overlay(error)
      *
      * This data structure supplies the name of the message file to
      * the message handling CL program.  The field name MSGFIL must be
      * constant. The value in quotes is the name of the specific
      * message file containing the user defined messages.
      *
     D                 ds                  inz
     D  msgfil                       10    inz('HSMSGF    ')
      *
      *---------------------------------------------------------------
      *  Standard message data structures
      *---------------------------------------------------------------
      *
      * The following 3 data structures are used to speed message
      * handling since it is faster to clear data structures than
      * arrays.  Each is associated with a standard message array.
      *
     D mgi             ds                  inz
     D  mgid                          7    dim(20)
      *
     D mgd             ds                  inz
     D  mgdt                         50    dim(20)
      *
     D mgwk            ds                  inz
     D  mgw                           1    dim(50)
      *
      *
      *---------------------------------------------------------------
      * Standard program status data structure
      *---------------------------------------------------------------
      *    externally defined as UTPGFR (record format: PGMDSR)
     D pgmds         esds                  extname(utpgfr)
      *
      *
      *---------------------------------------------------------------
      * Standard workstation information data structure
      *---------------------------------------------------------------
      *    externally defined as UTWSFR (record format: UTIDFRR)
     D iofeed        e ds                  extname(utwsfr)
      *
      *
      *---------------------------------------------------------------
      * Standard database file information data structure
      *---------------------------------------------------------------
      *    externally defined as UTDBGR (record format: FDBCKD)
     D dbfeed        e ds                  extname(utdbfr)
      *
      *
      *
      * The following is a dummy C-spec to keep the D-specs from
      * running over into the C-specs on the compile listing. It
      * serves no other purpose and can be deleted at any time.
      *
     C                   if        sdpgm = *blank
     C                   endif
      /eject
      ****************************************************************
      * MAINLINE
      ****************************************************************
      *
     C                   eval      routne = set
      *
     C     *inlr         doweq     *off                                         Main do loop
     C     routne        caseq     set           $set
     C     routne        caseq     scrn1         $scrn1
     C     routne        caseq     scrn2         $scrn2
     C     routne        caseq     scrn3         $scrn3
      *
     C     routne        caseq     exit          $exit
     C                   endcs
     C                   enddo                                                  Main do loop
      /eject
      *----------------------------------------------------------------
      * Set environment for all three screens
      *----------------------------------------------------------------
      *
     C     $set          begsr
      *
     C     key01         chain     hsl092b                            92
     C                   if        *in92 = *on                                  If not found
     C                   move      yes           notflg
     C                   if        error < maxmsg
     C                   add       1             error
     C                   movel     'HS09008'     mgid(e)
     C                   endif
     C                   else
      *
      * Set up fields for all three screens
      *
     C                   exsr      $set1
     C                   exsr      $set2
     C                   exsr      $set3
      *
      * Calculate values for the output only fields on all screens
      *
     C                   exsr      $calc1
     C                   exsr      $calc2
     C                   exsr      $calc3
      *
     C                   endif                                                  If not found
      *
      * Display screen 1
      *
     C                   eval      routne = scrn1
      *
     C                   endsr
      /eject
      *---------------------------------------------------------------
      * Set up fields for screen 1
      *---------------------------------------------------------------
      *
     C     $set1         begsr
      *
     C     *iso          move      wkwedt        wkmdydate
     C                   move      wkmdydate     d1wemdy
      *
     C                   z-add     bpcdyr        d1cdyr
     C                   z-add     bpcdwk        d1cdwk
     C                   z-add     bppicdt       d1picdt
     C                   move      bppocd        d1pocd
      *
     C                   z-add     bpwnsv        d1wnsv
     C                   z-add     bplwnsv       d1lwnsv
     C                   z-add     bprtsv        d1rtsv
     C                   z-add     bpglsv        d1glsv
     C                   z-add     bpbredpr      d1bredpr
      *
     C                   z-add     bpopglhd      d1opglhd
     C                   z-add     bpopsohd      d1opsohd
      *
     C                   z-add     bpabhd        d1abhd
     C                   z-add     bpglabhd      d1glabhd
     C                   z-add     bpnipqt       d1nipqt
      *
      * Retrieve farm site name
      *
     C     d1fscd        chain     hsp018                             92
     C                   if        *in92 = *off
     C                   eval      d1fsnm = fsfsnm
     C                   else
     C                   eval      d1fsnm = 'UNKNOWN'
     C                   endif
      *
      * Retrieve Population Code description
      *
     C     d1pocd        chain     hsp104                             92
     C                   if        *in92 = *off
     C                   eval      d1pods = popods
     C                   else
     C                   eval      d1pods = 'UNKNOWN'
     C                   endif
      *
      * Call generic program to retrieve pregnancy and farrowing data and calc
      * conception rate and farrowing rate.
      *
     C                   call      'HPCONFAR'
     C                   parm                    d1fscd
     C                   parm                    d1cdyr
     C                   parm                    d1cdwk
     C                   parm      0             d1pryr
     C                   parm      0             d1prwk
     C                   parm      0             d1glprhd
     C                   parm      0             d1prhd
     C                   parm      0             d1crpr
     C                   parm      0             d1fayr
     C                   parm      0             d1fawk
     C                   parm      0             d1glfahd
     C                   parm      0             d1fahd
     C                   parm      0             d1frpr
      *
     C                   endsr
      /eject
      *---------------------------------------------------------------
      * Perform operator I/O for screen 1
      *---------------------------------------------------------------
      *
     C     $scrn1        begsr
      *
      * Set the indicators to control screen fields
      *
     C                   exsr      $ind
      *
      * Write the error messages from the error arrays to the
      * error message subfile
      *
     C                   exsr      $wrmsg
      *
      * Write screen 1 to CRT
      *
     C                   write     hp7000k1
     C                   write     hp7000ec
     C                   exfmt     hp7000r1
      *
      * Clear all messages
      *
     C                   exsr      $clmsg
      *
      *
      * Process user's entry and set routine
      *
     C                   select
     C                   when      *in03 = *on                                  F3-exit
     C                   move      *blank        rtncd
     C                   eval      routne = exit
      *
     C                   when      notflg = yes                                 Record gone
     C                   if        error < maxmsg
     C                   add       1             error
     C                   movel     'HS09008'     mgid(e)
     C                   endif
     C                   movel     scrn1         routne
     C                   other
      *
     C                   eval      routne = scrn2
     C                   endsl                                                  Select response
      *
     C                   endsr
      /eject
      *--------------------------------------------------------------------
      * Calculate values for the output fields on screen one
      *---------------------------------------------------------------------
      *
     C     $calc1        begsr
      *
      * Calculate total services
      *
     C                   eval      d1tosv = d1wnsv + d1lwnsv + d1rtsv + d1glsv
      *
      *
      * Calculate conception rate percent after retrieving the 'services' values for
      * the user-specified year/week. (Place key values in generic workfields
      * so that a common key list can be used.)
      *
     C                   z-add     d1pryr        wkyr
     C                   z-add     d1prwk        wkwk
      *
     C                   z-add     0             d1crpr
     C     key02         chain     hsl092a                            92
     C                   if        *in92 = *off                                 If hit
     C                   eval      wkfld15 =
     C                             (p1bpwnsv + p1bplwnsv + p1bprtsv + p1bpglsv)
     C                   if        wkfld15 <> 0
     C     d1prhd        div       wkfld15       wkfld155
     C     wkfld155      mult(h)   100           d1crpr
     C                   endif
     C                   endif                                                  If hit
      *
      *
      * Calculate farrowing rate after retrieving the 'services' values for
      * the user-specified year/week. (Place key values in generic workfields
      * so that a common key list can be used.)
      *
     C                   z-add     d1fayr        wkyr
     C                   z-add     d1fawk        wkwk
      *
     C                   z-add     0             d1frpr
     C     key02         chain     hsl092a                            92
     C                   if        *in92 = *off                                 If found
     C                   eval      wkfld15 =
     C                             p1bpwnsv + p1bplwnsv + p1bprtsv + p1bpglsv
     C                   if        wkfld15 <> 0
     C     d1fahd        div       wkfld15       wkfld155
     C     wkfld155      mult(h)   100           d1frpr
     C                   endif
     C                   endif                                                  If found
      *
     C                   endsr
      /eject
      *---------------------------------------------------------------
      * Set up fields for screen 2
      *---------------------------------------------------------------
      *
     C     $set2         begsr
      *
     C                   z-add     bpgllt        d2gllt
     C                   z-add     bpglbahd      d2glbahd
     C                   z-add     bpglsbhd      d2glsbhd
     C                   z-add     bpglmmhd      d2glmmhd
     C                   z-add     bptolt        d2tolt
     C                   z-add     bpbahd        d2bahd
     C                   z-add     bpsbhd        d2sbhd
     C                   z-add     bpmmhd        d2mmhd
      *
     C                   z-add     bptolshd      d2tolshd
      *
     C                   z-add     bpewnlt       d2ewnlt
     C                   z-add     bpwnlt        d2wnlt
     C     bpewnlt       add       bpwnlt        d2totwnlt
     C                   z-add     bptownhd      d2townhd
     C                   z-add     bpadwn        d2adwn
      *
     C                   z-add     bparglhd      d2arglhd
     C                   z-add     bpibglhd      d2ibglhd
     C                   z-add     bpslglhd      d2slglhd
     C                   z-add     bpddglhd      d2ddglhd
     C                   z-add     bpeuglhd      d2euglhd
     C                   z-add     bpobglhd      d2obglhd
      *
     C                   z-add     bparsohd      d2arsohd
     C                   z-add     bpibsohd      d2ibsohd
     C                   z-add     bpslsohd      d2slsohd
     C                   z-add     bpddsohd      d2ddsohd
     C                   z-add     bpeusohd      d2eusohd
     C                   z-add     bpobsohd      d2obsohd
     C                   z-add     bpoosohd      d2oosohd
      *
     C                   endsr
      /eject
      *---------------------------------------------------------------
      * Set up fields for screen 3
      *---------------------------------------------------------------
      *
     C     $set3         begsr
      *
     C                   z-add     bpglsohd      d3glsohd
     C                   z-add     bpenplhd      d3enplhd
      *
     C                   z-add     bparbohd      d3arbohd
     C                   z-add     bpddbohd      d3ddbohd
     C                   z-add     bpslbohd      d3slbohd
     C                   z-add     bpbohd        d3bohd
      *
     C                   z-add     bpmanhr       d3manhr
      *
     C                   endsr
      /eject
      *---------------------------------------------------------------
      * Subroutine to perform operator I/O for screen 2
      *---------------------------------------------------------------
      *
     C     $scrn2        begsr
      *
      * Set the indicators to control screen fields
      *
     C                   exsr      $ind
      *
      * Write the error messages from the error arrays to the
      * error message subfile
      *
     C                   exsr      $wrmsg
      *
      * Write screen 2 to CRT
      *
     C                   write     hp7000k2
     C                   write     hp7000ec
     C                   exfmt     hp7000r2
      *
      * Clear all messages
      *
     C                   exsr      $clmsg
      *
      * Process user's entry and set routine
      *
     C                   select
     C                   when      *in03 = *on                                  F3-exit
     C                   move      *blank        rtncd
     C                   eval      routne = exit
      *
     C                   when      *in12 = *on                                  F12-previous
     C                   eval      routne = scrn1
     C                   other
      *
      * User has pressed ENTER on screen 2
      *
      *
     C                   select
     C                   when      error = 0
     C                   eval      routne = scrn3
     C                   other
     C                   eval      routne = scrn2
     C                   endsl
      *
     C                   endsl
      *
     C                   endsr
      /eject
      *--------------------------------------------------------------------
      * Calculate values for the output fields on screen two
      *---------------------------------------------------------------------
      *
     C     $calc2        begsr
      *
      * If 'total litters farrowed' is not zero, calculate the following:
      *   1) 'Born alive per litter' as:
      *                             total born alive / total litters farrowed
      *   2) 'Stillborns per litter' as:
      *                             total stillborns / total litters farrowed
      *
      *
     C                   if        d2tolt <> 0                                  If litters
     C     d2bahd        div(h)    d2tolt        wkfld152
     C                   z-add     wkfld152      d2ltbahd
     C     d2sbhd        div(h)    d2tolt        wkfld152
     C                   z-add     wkfld152      d2ltsbhd
     C                   else
     C                   z-add     0             d2ltbahd
     C                   z-add     0             d2ltsbhd
     C                   endif                                                  If litters
      *
      *
      * Calculate 'piglets weaned per litter' as:
      *    total pigs weaned /
      *         (0-15 day weaned sows + 16+ day weaned sows)
      *
     C                   eval      wkwnlt = d2ewnlt + d2wnlt
     C                   if        wkwnlt <> 0
     C     d2townhd      div(h)    wkwnlt        wkfld152
     C                   z-add     wkfld152      d2ltwnhd
     C                   else
     C                   z-add     0             d2ltwnhd
     C                   endif
      *
     C                   endsr
      /eject
      *--------------------------------------------------------------------
      * Calculate values for the output fields on screen three
      *---------------------------------------------------------------------
      *
     C     $calc3        begsr
      *
      * Calculate % female mortality as:
      *   (naturally dead and euthanized gilts and sows * 52 weeks) / gilt and sow inventory
      *
     C                   if        d3glsohd <> 0
     C                   eval      wkfld155 = 100 *
     C                             (((d2ddglhd + d2euglhd + d2ddsohd + d2eusohd)
     C                                                     * 52) / d3glsohd)
     C                   z-add(h)  wkfld155      d3fmddpr
     C                   else
     C                   z-add     0             d3fmddpr
     C                   endif
      *
     C                   endsr
      /eject
      *---------------------------------------------------------------
      * Subroutine to perform operator I/O for screen 3
      *---------------------------------------------------------------
      *
     C     $scrn3        begsr
      *
      * Set the indicators to control screen fields
      *
     C                   exsr      $ind
      *
      * Write the error messages from the error arrays to the
      * error message subfile
      *
     C                   exsr      $wrmsg
      *
      * Write screen 3 to CRT
      *
     C                   write     hp7000k3
     C                   write     hp7000ec
     C                   exfmt     hp7000r3
      *
      * Clear all messages
      *
     C                   exsr      $clmsg
      *
      *
      * Process user's entry and set routine
      *
     C                   select
     C                   when      *in03 = *on                                  F3-exit
     C                   move      *blank        rtncd
     C                   eval      routne = exit
      *
     C                   when      *in12 = *on                                  F12-previous
     C                   eval      routne = scrn2
     C                   other
      *
      * User has pressed ENTER on screen 3
      *
     C                   eval      routne = scrn3
     C                   endsl
      *
     C                   endsr
      /eject
      *----------------------------------------------------------------
      * Reset indicators for all screens
      *----------------------------------------------------------------
      *
     C     $ind          begsr
      *
      * The record has been deleted out from under the user.
      *
     C                   if        notflg = yes
     C                   seton                                        90
     C                   endif
      *
     C                   endsr
      /eject
      *---------------------------------------------------------------
      * Write error messages
      *---------------------------------------------------------------
      *
     C     $wrmsg        begsr
      *
     C                   call      'UT80045J'                           43
     C                   parm                    mgid
     C                   parm                    mgdt
     C                   parm                    error
     C                   parm      sdpgm         pgm
     C                   parm      msgfil        msgfl
      *
      * If call to UT80045J failed, a message hardcoded in the DSPF
      * command key record will be set on. So, redispaly the screen to the user.
      *
     C                   if        *in43 = *on
     C                   movel     set           routne
     C                   endif
      *
      *
     C                   endsr
      /eject
      *----------------------------------------------------------------
      * $clmsg - clear messages
      *----------------------------------------------------------------
      *
     C     $clmsg        begsr
      *
     C                   call      'UT80045J'                           43
     C                   parm      *blank        mgi
     C                   parm      *blank        mgd
     C                   parm      *zero         error
     C                   parm      sdpgm         pgm
     C                   parm      msgfil        msgfl
      *
      *
      * If call to UT80045J failed, a message hardcoded in the DSPF
      * command key record will be set on. So, redispaly the screen to the user.
      *
     C                   if        *in43 = *on
     C                   movel     set           routne
     C                   endif
      *
     C                   endsr
      /eject
      *----------------------------------------------------------------
      * $exit - set on last record indicator and end job
      *----------------------------------------------------------------
      *
     C     $exit         begsr
     C                   seton                                        LR
     C                   endsr
      /eject
      *---------------------------------------------------------------
      * *inzsr - initialization subroutine
      *---------------------------------------------------------------
      *
     C     *inzsr        begsr
      *
      * Parm lists
      *
     C     *entry        plist
     C     d1fscd        parm                    xxfscd
     C     wkwedt        parm                    xxwedt
      *
      *
      * Key lists
      *
      *
     C     key01         klist
     C                   kfld                    d1fscd
     C                   kfld                    wkwedt
      *
      *
     C     key02         klist
     C                   kfld                    d1fscd
     C                   kfld                    wkyr
     C                   kfld                    wkwk
      *
      *
      * The following standard code must be included to make the
      * standard error message handling program function properly.
      * This code sets and clears the program message queue.
      *
     C                   movel     '*'           msgpgm
     C                   exsr      $clmsg
      *
     C                   endsr
      /eject
