      *
      * SYSTEM:      Resource Optimization
      * PROGRAM:     RO101
      * TITLE:       Revise RO Header
      * PROGRAMMER:  LeAnne Ramsey
      * CREATED:     12/27/06
      *
      *
      * FUNCTION: Uses an edit record format to create/revise records.
      *
      ****************************************************************
      * MODIFICATIONS:
      ****************************************************************
      * DATE      PROGRAMMER
      *
      * 02/26/09  LeAnne Ramsey
      *            Removed from file: Labor Fringe %, Average Lean %, Average Carcass Weight
      *            Added to file:     Smoker Yield % from BoneIn Picnic
      *
      * 02/17/10  LeAnne Ramsey
      *           Added 2 fields to file:
      *                Cap&Blade Allocation % for Special Trim
      *                Cap&Blade Allocation % for Regular Trim
      *
      * 02/25/10  LeAnne Ramsey
      *           Added 8 Cap&Blade Yield Percent fields to file for Damon G. to maintain.
      *           Damon uses 2 specific items for the percents.
      *           Item 89999              Item 89998
      *           ----------              ----------
      *           Cap meat %              Cap Meat %
      *           Blade meat %            Blade Meat %
      *           Reg trim %              Reg Trim %
      *           Cut Loss %              Cut Loss %
      *
      * 08/15/11  LeAnne Ramsey (E1699)
      *           Recompile only.
      *           Damin Ginther has added a new Cap Item: 89997. It will have the same
      *           percentages as existing Item 89999. So, we did not need new entry fields.
      *           I just added the new Item into the column heading.
      *
      * 03/08/12  LeAnne Ramsey (E1984)
      *           Added 6 new Skirt Meat Allocation Flag fields to ROP100. These will let Damon
      *           designate which "categories" program RO232 will allocate Skirt Meat to. These
      *           are Yes/No flags:
      *                             Skirt Meat Allocation   SBF   TF
      *                             ---------------------   ---   --
      *                                   Small commodity    Y    N
      *                                  Medium commodity    N    N
      *                                 Converted Brisket    Y    Y
      *
      * 05/01/12  LeAnne Ramsey (E2078)
      *           Recompile only.
      *           Changed Cap/Blade Yield % heading.
      *           What was '89997/89999' is now '89990/89997/89999'.
      *           Item 89990 is new and per Damon G. is to be handled
      *           just like 89997/89999.
      *
      * 01/20/14  LeAnne Ramsey (E2985)
      *           Recompile only.
      *           Damin Ginther has added 8 new Cap&Blade Items. There are now too many
      *           items to plop them over the Cap&Blade Yield% columns. So, I added a section
      *           on the lower right of the screen to list them.
      /EJECT
      ****************************************************************
      * FILE SPECIFICATION
      ****************************************************************
      *
     frod101    cf   e             workstn infds(iofeed)
      *
      *
     fcaabrel1  if   e           k disk
      * Company name and address
      *
      *
     frop012    uf a e           k disk
      * Item control data
      *
      *
     frop100    if   e           k disk    prefix(p1)
      * Resource optimazation header
      *
      *
     frol100a   uf a e           k disk    rename(ohrec:ohreca)
      * Resource optimazation header
      *
      /eject
      ****************************************************************
      * DEFINITION SPECIFICATIONS
      ****************************************************************
      *
      ****************************************************************
      * CONSTANTS
      ****************************************************************
      *
     d create          c                   'CREATE'
     d revise          c                   'REVISE'
     d delete          c                   'DELETE'
     d yes             c                   'Y'
     d no              c                   'N'
     d set1            c                   'SET1  '
     d edit1           c                   'EDIT1 '
     d scrn1           c                   'SCRN1 '
     d exit            c                   'EXIT  '
     d update          c                   'UPDATE'
      *
      ****************************************************************
      * ARRAYS AND TABLES
      ****************************************************************
      *
      *
      ****************************************************************
      * STANDALONE FIELDS
      ****************************************************************
      *
      * Standard fields
      *
     d mode            s              6
     d pgm             s             10
     d msgfl           s             10
     d routne          s              6
     d rtncd           s              2
     d action          s                   like(mode)
     d maxmsg          s              2  0 inz(20)
      *
      *
      * Control/save fields
      *
     d svwedt          s                   like(icwedt)
      *
      *
      * Workfields for date manipulation
      *
     D wkisodate       s               d   datfmt(*iso)
     D wkwedt          s              8  0
      *
      *
      * Parms
      *
     d xxwedt          s                   like(ohwedt)
     D xxsatdt         s              8  0
     D xxyr            s              4  0
     D xxpe            s              2  0
     D xxwk            s              2  0
      *
      *
      ****************************************************************
      * DATA STRUCTURES
      ****************************************************************
      *
      *---------------------------------------------------------------
      * standard error message handling data structures
      *---------------------------------------------------------------
      *
      * For error message handling, a packed index (3) is required.
      * For program readability, define a corresponding error count
      * field called 'error'
      *
     D                 ds                  inz
     D  error                         2p 0
     D   e                            2p 0 overlay(error)
      *
      * This data structure supplies the name of the message file to
      * the message handling CL program.  The field name MSGFIL must be
      * constant. The value in quotes is the name of the specific
      * message file containing the user defined messages.
      *
     D                 ds                  inz
     D  msgfil                       10    inz('ROMSGF    ')
      *
      *---------------------------------------------------------------
      *  Standard message data structures
      *---------------------------------------------------------------
      *
      * The following 3 data structures are used to speed message
      * handling since it is faster to clear data structures than
      * arrays.  Each is associated with a standard message array.
      *
     D mgi             ds                  inz
     D  mgid                          7    dim(20)
      *
     D mgd             ds                  inz
     D  mgdt                         50    dim(20)
      *
     D mgwk            ds                  inz
     D  mgw                           1    dim(50)
      *
      *
      *---------------------------------------------------------------
      * Standard program status data structure
      *---------------------------------------------------------------
      *    externally defined as UTPGFR (record format: PGMDSR)
     D pgmds         esds                  extname(utpgfr)
      *
      *
      *---------------------------------------------------------------
      * Standard workstation information data structure
      *---------------------------------------------------------------
      *    externally defined as UTWSFR (record format: UTIDFRR)
     D iofeed        e ds                  extname(utwsfr)
      *
      *
      *---------------------------------------------------------------
      * Standard database file information data structure
      *---------------------------------------------------------------
      *    externally defined as UTDBGR (record format: FDBCKD)
     D dbfeed        e ds                  extname(utdbfr)
      *
      *
      * The following is a dummy C-spec to keep the D-specs from
      * running over into the C-specs on the compile listing. It
      * serves no other purpose and can be deleted at any time.
      *
     C                   if        sdpgm = *blank
     C                   endif
      /EJECT
      ****************************************************************
      * MAINLINE
      ****************************************************************
      *
     c                   eval      routne = set1
      *
     c     *inlr         doweq     *off
     c     routne        caseq     set1          $set1
     c     routne        caseq     scrn1         $scrn1
     c     routne        caseq     edit1         $edit1
     c     routne        caseq     exit          $exit
     c                   endcs
     c                   enddo
      /eject
      *----------------------------------------------------------------
      * Set environment for screen 1
      *----------------------------------------------------------------
      *
     c     $set1         begsr
      *
      * If incoming mode is REVISE or DELETE, then retrieve the database
      * record.  Do not lock the record.  Typically, in DELETE mode, these
      * values will not be displayed. However, if there is an error on the
      * delete action, the panel will be displayed with messages.
      *
     C                   select
     C                   when      mode = create                                WH create
     C                   move      'O'           d1rcstcd
     C                   z-add     0             d1wemdy
     C                   z-add     0             d1bicrvl
     C                   z-add     0             d1smokypc
     C                   z-add     0             d1bitrpc
     C                   z-add     0             d1altrpc
     C                   z-add     0             d1bicapc
     C                   z-add     0             d1blcapc
     C                   z-add     0             d1bibypc
     C                   z-add     0             d1blbypc
      *
     C                   z-add     0             d1cbrtpc
     C                   z-add     0             d1cbstpc
      *
     C                   z-add     0             d1cbcm1pc
     C                   z-add     0             d1cbbm1pc
     C                   z-add     0             d1cbrt1pc
     C                   z-add     0             d1cbcl1pc
      *
     C                   z-add     0             d1cbcm2pc
     C                   z-add     0             d1cbbm2pc
     C                   z-add     0             d1cbrt2pc
     C                   z-add     0             d1cbcl2pc
      *
     C                   move      *blank        d1sscfl
     C                   move      *blank        d1smcfl
     C                   move      *blank        d1scbfl
     C                   move      *blank        d1tscfl
     C                   move      *blank        d1tmcfl
     C                   move      *blank        d1tcbfl
      *
     C                   exsr      $prior
      *
     C                   when      mode = revise or mode = delete               WH revise/delete
     C     key01         chain(n)  rol100a                            92
     C                   if        *in92 = *on                                  If no hit
     C                   seton                                        62
     C                   if        error < maxmsg
     c                   add       1             error
     c                   eval      mgid(e) = 'RO09008'
     c                   endif
     C                   else
      *
     C                   move      ohrcstcd      d1rcstcd
     C                   z-add     ohbicrvl      d1bicrvl
     C                   z-add     ohsmokypc     d1smokypc
     C                   z-add     ohbitrpc      d1bitrpc
     C                   z-add     ohaltrpc      d1altrpc
     C                   z-add     ohbicapc      d1bicapc
     C                   z-add     ohblcapc      d1blcapc
     C                   z-add     ohbibypc      d1bibypc
     C                   z-add     ohblbypc      d1blbypc
      *
     C                   z-add     ohcbrtpc      d1cbrtpc
     C                   z-add     ohcbstpc      d1cbstpc
      *
     C                   z-add     ohcbcm1pc     d1cbcm1pc
     C                   z-add     ohcbbm1pc     d1cbbm1pc
     C                   z-add     ohcbrt1pc     d1cbrt1pc
     C                   z-add     ohcbcl1pc     d1cbcl1pc
      *
     C                   z-add     ohcbcm2pc     d1cbcm2pc
     C                   z-add     ohcbbm2pc     d1cbbm2pc
     C                   z-add     ohcbrt2pc     d1cbrt2pc
     C                   z-add     ohcbcl2pc     d1cbcl2pc
      *
     C                   move      ohsscfl       d1sscfl
     C                   move      ohsmcfl       d1smcfl
     C                   move      ohscbfl       d1scbfl
     C                   move      ohtscfl       d1tscfl
     C                   move      ohtmcfl       d1tmcfl
     C                   move      ohtcbfl       d1tcbfl
     C                   endif                                                  If no hit
     C                   endsl
      *
     C                   if        d1rcstcd = 'O'
     C                   setoff                                       63
     C                   else
     C                   seton                                        63
     C                   endif
      *
      * If the user is deleting and there were no errors when retrieving the
      * record, go on to the update routine without displaying the screen.
      * Otherwise, display the screen.
      *
     c                   if        error = 0 and action = delete                If no error
     C                   exsr      $accept
     c                   else
     c                   eval      routne = scrn1
     c                   endif                                                  If no error
      *
     c                   endsr
      /eject
      *----------------------------------------------------------------
      * Perform operator I/O for screen 1
      *----------------------------------------------------------------
      *
     c     $scrn1        begsr
      *
      * Set indicators to control input/output fields and available
      * function keys.
     c                   exsr      $ind
      *
      * Write the error messages from the error arrays to the
      * error message subfile
      *
     c                   exsr      $wrmsg
      *
      *
      * Write screen 1 to CRT
     c                   write     ro101k1
     c                   write     ro101ec
     c                   exfmt     ro101r1
      *
      * Clear messages
     c                   exsr      $clmsg
      *
      * Reset action to be equal to the incoming mode.  This is required
      * in case the user took F11-Delete and got an error on the
      * deletion and now needs to be able to change the record and take
      * an action other than delete
      *
     c                   eval      action = mode
      *
      * Get user's input and set routine
      *
     c                   select
     c                   when      *in03 = *on                                  F3-exit
     c                   eval      rtncd = '03'
     c                   eval      routne = exit
      *
     c                   when      *in05 = *on                                  F5-refresh
     c                   eval      routne = set1
      *
     C                   when      *in09 = *on                                  F9-accept
     C                   exsr      $edit1
     C                   if        error = 0
     C                   exsr      $accept
     C                   endif
      *
     c                   when      *in11 = *on or mode = delete                 F11-delete
     c                   eval      action = delete
     C                   exsr      $accept
     c                   other
      *
     c                   eval      routne = edit1
     c                   endsl
      *
     c                   endsr
      /eject
      *----------------------------------------------------------------
      * Retrieve "Prior" week values
      *----------------------------------------------------------------
      *
      * You are in this subroutine when the user is in CREATE mode.
      * Go retrieve the first record prior to this one and populate the
      * entry fields with those values---just to get the user started.
      * And, add 7 days to the week-ending date to get the date for this
      * new record.
      *
     C     $prior        begsr
      *
     C     d1cono        setgt     rop100
     C     d1cono        readpe    rop100                                 92
     C                   if        *in92 = *off
     C                   seton                                        64
     C                   z-add     p1ohsmokypc   d1smokypc
     C                   z-add     p1ohbitrpc    d1bitrpc
     C                   z-add     p1ohbibypc    d1bibypc
     C                   z-add     p1ohblbypc    d1blbypc
      *
     C                   z-add     p1ohcbrtpc    d1cbrtpc
     C                   z-add     p1ohcbstpc    d1cbstpc
      *
     C                   z-add     p1ohcbcm1pc   d1cbcm1pc
     C                   z-add     p1ohcbbm1pc   d1cbbm1pc
     C                   z-add     p1ohcbrt1pc   d1cbrt1pc
     C                   z-add     p1ohcbcl1pc   d1cbcl1pc
      *
     C                   z-add     p1ohcbcm2pc   d1cbcm2pc
     C                   z-add     p1ohcbbm2pc   d1cbbm2pc
     C                   z-add     p1ohcbrt2pc   d1cbrt2pc
     C                   z-add     p1ohcbcl2pc   d1cbcl2pc
      *
     C                   move      p1ohsscfl     d1sscfl
     C                   move      p1ohsmcfl     d1smcfl
     C                   move      p1ohscbfl     d1scbfl
     C                   move      p1ohtscfl     d1tscfl
     C                   move      p1ohtmcfl     d1tmcfl
     C                   move      p1ohtcbfl     d1tcbfl
      *
     C                   movel     p1ohwedt      wkisodate
     C                   adddur    7:*days       wkisodate
     C                   move      wkisodate     wkwedt
     C     *mdy          move      wkisodate     d1wemdy
     C                   endif
      *
     C                   endsr
      /eject
      *----------------------------------------------------------------
      * Set indicators to control/protect screen fields
      *----------------------------------------------------------------
      *
     C     $ind          begsr
      *
     C                   select
     C                   when      mode = revise
     C                   seton                                        60
      *
     C                   when      mode = create
     C                   seton                                        61
      *
     C                   when      mode = delete
     C                   seton                                        62
     c                   endsl
      *
      * If no errors, default to first entry field on screen.
      *
     C                   if        error = 0 and
     C                             (*in60 = *on or *in62 = *on or
     C                              *in64 = *on)
     C                   seton                                        65
     C                   else
     C                   setoff                                       65
     C                   endif
      *
     C                   endsr
      /eject
      *----------------------------------------------------------------
      * Edit input fields for screen 1
      *----------------------------------------------------------------
      *
     C     $edit1        begsr
      *
      * *IN62 will be on if the record the user is trying to access has
      * been deleted by another user.  So, only perform the edits for the
      * fields on the screen if the indicator is off
      *
     C                   if        *in62 = *off                                 If here
      *
      * We will derive a Week-ending Date for every new record. BUT, for
      * the very first record created in the file, we will need to have
      * the date entered.
      *
     C                   if        action = create and *in64 = *off             If create
     C                   exsr      $wemdy
     C                   endif                                                  If create
      *
      * Always validate:
      *  1) Smoker percent
      *  2) Trim 100% BI Loin
      *  3) Bone-in byproduct yield %
      *  4) Boneless byproduct yield %
      *
     C                   exsr      $smokypc
     C                   exsr      $bitrpc
     C                   exsr      $bibypc
     C                   exsr      $blbypc
      *
      *  5) Cap&Blade Regular Trim Allocation %
      *  6) Cap&Blade Special Trim Allocation %
      *
     C                   exsr      $cbrtpc
     C                   exsr      $cbstpc
      *
      * Skirt Meat Allocation Flags
      *
     C                   exsr      $skirt
      *
      *  7) Cap&Blade Cap Meat Yield %s
      *  8) Cap&Blade Blade Meat Yield %s
      *  9) Cap&Blade Reg Trim Yield %s
      * 10) Cap&Blade Cut Loss Yield %s
      * 11) Cap&Blade Yields must total 100%
      *
     C                   exsr      $cbcmyld
     C                   exsr      $cbbmyld
     C                   exsr      $cbrtyld
     C                   exsr      $cbclyld
     C                   exsr      $totyld
      *
     C                   endif                                                  If here
      *
     C                   eval      routne = scrn1
      *
     C                   endsr
      /eject
      *----------------------------------------------------------------------------------
      * Validate Week-ending date and then retrieve/overlay it with its Saturday date
      *----------------------------------------------------------------------------------
      *
     C     $wemdy        begsr
      *
     C     *mdy          test(d)                 d1wemdy                92
     C                   if        *in92 = *on                                  If bad date
     C                   seton                                        30
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'RO09004'
     C                   endif
     C                   else
      *
      * Flip the date from MMDDYY to CCYYMMDD and go find the 'week-ending date'
      * assocated with this date.
      *
     C     *mdy          move      d1wemdy       wkisodate
     C                   move      wkisodate     xxwedt
      *
     C                   call      'RO811'
     C                   parm                    xxwedt
     C                   parm      0             xxsatdt
     C                   parm      0             xxyr
     C                   parm      0             xxpe
     C                   parm      0             xxwk
      *
     C     *iso          test(d)                 xxsatdt                92
     C                   if        *in92 = *off
     C                   z-add     xxsatdt       wkwedt
     C     *iso          move      xxsatdt       wkisodate
     C     *mdy          move      wkisodate     d1wemdy
     C                   endif
      *
     C                   endif                                                  If bad date
      *
     C                   endsr
      /eject
      *----------------------------------------------------------------
      * Validate Smoker Yield % from Bone-In Picnic
      *----------------------------------------------------------------
      *
     C     $smokypc      begsr
      *
     C                   select
     C                   when      d1smokypc = 0
     C                   seton                                        34
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'RO09001'
     C                   endif
      *
     C                   when      d1smokypc < 0
     C                   seton                                        34
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'RO09000'
     C                   endif
     C                   endsl
      *
     C                   endsr
      /eject
      *----------------------------------------------------------------
      * Validate Sirloin Trim 100% BI Loin
      *----------------------------------------------------------------
      *
     C     $bitrpc       begsr
      *
     C                   if        d1bitrpc < 0
     C                   seton                                        31
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'RO09000'
     C                   endif
     C                   endif
      *
     C                   endsr
      /eject
      *----------------------------------------------------------------
      * Validate Bone-in Byproduct Yield %
      *----------------------------------------------------------------
      *
     C     $bibypc       begsr
      *
     C                   if        d1bibypc < 0
     C                   seton                                        32
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'RO09000'
     C                   endif
     C                   endif
      *
     C                   endsr
      /eject
      *----------------------------------------------------------------
      * Validate Boneless Byproduct Yield %
      *----------------------------------------------------------------
      *
     C     $blbypc       begsr
      *
     C                   if        d1blbypc < 0
     C                   seton                                        33
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'RO09000'
     C                   endif
     C                   endif
      *
     C                   endsr
      /eject
      *----------------------------------------------------------------
      * Validate Cap&Blade Regular Trim Allocation %
      *----------------------------------------------------------------
      *
      * This is the percent that I use in the Cap&Blade T72A/TRGA calcs.
      *
     C     $cbrtpc       begsr
      *
     C                   select
     C                   when      d1cbrtpc < 0
     C                   seton                                        35
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'RO09000'
     C                   endif
      *
     C                   when      d1cbrtpc = 0
     C                   seton                                        35
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'RO09001'
     C                   endif
      *
     C                   endsl
      *
     C                   endsr
      /eject
      *----------------------------------------------------------------
      * Validate Cap&Blade Special Trim Allocation %
      *----------------------------------------------------------------
      *
      * At the time we added this, we are not using it anywhere in the system.
      * But, Damon Ginther wanted to enter it so that we could check that
      * the sum of his Regular Trim and Special Trim comes to 100%.
      *
     C     $cbstpc       begsr
      *
     C                   select
     C                   when      d1cbstpc = 0
     C                   seton                                        36
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'RO09001'
     C                   endif
      *
     C                   when      d1cbstpc < 0
     C                   seton                                        36
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'RO09000'
     C                   endif
     C                   endsl
      *
     C                   if        *in35 = *off and *in36 = *off and
     C                             (d1cbrtpc + d1cbstpc) <> 100
     C                   seton                                        3536
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'RO09010'
     C                   endif
     C                   endif
      *
     C                   endsr
      /eject
      *----------------------------------------------------------------
      * Validate Cap&Blade Cap Meat Yield Percents
      *----------------------------------------------------------------
      *
     C     $cbcmyld      begsr
      *
      * Cap Meat 1 Yield % (for Item 89999)
      *
     C                   select
     C                   when      d1cbcm1pc = 0
     C                   seton                                        37
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'RO09001'
     C                   endif
      *
     C                   when      d1cbcm1pc < 0
     C                   seton                                        37
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'RO09000'
     C                   endif
     C                   endsl
      *
      * Cap Meat 2 Yield % (for Item 89998)
      *
     C                   select
     C                   when      d1cbcm2pc = 0
     C                   seton                                        26
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'RO09001'
     C                   endif
      *
     C                   when      d1cbcm2pc < 0
     C                   seton                                        26
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'RO09000'
     C                   endif
     C                   endsl
      *
     C                   endsr
      /eject
      *----------------------------------------------------------------
      * Validate Cap&Blade Blade Meat Yield Percents
      *----------------------------------------------------------------
      *
     C     $cbbmyld      begsr
      *
      * Blade Meat 1 Yield % (for Item 89999)
      *
     C                   select
     C                   when      d1cbbm1pc = 0
     C                   seton                                        38
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'RO09001'
     C                   endif
      *
     C                   when      d1cbbm1pc < 0
     C                   seton                                        38
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'RO09000'
     C                   endif
     C                   endsl
      *
      * Blade Meat 2 Yield % (for Item 89998)
      *
     C                   select
     C                   when      d1cbbm2pc = 0
     C                   seton                                        27
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'RO09001'
     C                   endif
      *
     C                   when      d1cbbm2pc < 0
     C                   seton                                        27
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'RO09000'
     C                   endif
     C                   endsl
      *
      * We are requiring the #1 and #2 yield percents to be the same....
      * If Damon G. wants to change this rule, then we need to revisit the logic
      * in RO235.
      *
     C                   if        d1cbbm1pc <> d1cbbm2pc
     C                             and *in27 = *off and *in38 = *off
     C                   seton                                        3827
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'RO00142'
     C                   endif
     C                   endif
      *
     C                   endsr
      /eject
      *----------------------------------------------------------------
      * Validate Cap&Blade Regular Trim Yield Percents
      *----------------------------------------------------------------
      *
     C     $cbrtyld      begsr
      *
      * Regular Trim 1 Yield % (for Item 89999)
      *
     C                   select
     C                   when      d1cbrt1pc = 0
     C                   seton                                        39
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'RO09001'
     C                   endif
      *
     C                   when      d1cbrt1pc < 0
     C                   seton                                        39
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'RO09000'
     C                   endif
     C                   endsl
      *
      * Regular Trim 2 Yield % (for Item 89998)
      *
     C                   select
     C                   when      d1cbrt2pc = 0
     C                   seton                                        28
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'RO09001'
     C                   endif
      *
     C                   when      d1cbrt2pc < 0
     C                   seton                                        28
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'RO09000'
     C                   endif
     C                   endsl
      *
     C                   endsr
      /eject
      *----------------------------------------------------------------
      * Validate Cap&Blade Cut Loss Yield Percents
      *----------------------------------------------------------------
      *
     C     $cbclyld      begsr
      *
      * Cut Loss 1 Yield % (for Item 89999)
      *
     C                   select
     C                   when      d1cbcl1pc = 0
     C                   seton                                        40
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'RO09001'
     C                   endif
      *
     C                   when      d1cbcl1pc < 0
     C                   seton                                        40
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'RO09000'
     C                   endif
     C                   endsl
      *
      * Cut Loss 2 Yield % (for Item 89998)
      *
     C                   select
     C                   when      d1cbcl2pc = 0
     C                   seton                                        29
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'RO09001'
     C                   endif
      *
     C                   when      d1cbcl2pc < 0
     C                   seton                                        29
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'RO09000'
     C                   endif
     C                   endsl
      *
      * We are requiring the #1 and #2 yield percents to be the same....
      * If Damon G. wants to change this rule, then we need to revisit the logic
      * in RO235.
      *
     C                   if        d1cbcl1pc <> d1cbcl2pc
     C                             and *in29 = *off and *in40 = *off
     C                   seton                                        4029
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'RO00143'
     C                   endif
     C                   endif
      *
     C                   endsr
      /eject
      *----------------------------------------------------------------
      * Total CapBlade Yields must total 100%
      *----------------------------------------------------------------
      *
     C     $totyld       begsr
      *
      * Yields for 89999
      *
     C                   if        (d1cbcm1pc + d1cbbm1pc + d1cbrt1pc +
     C                              d1cbcl1pc) <> 100
     C                              and *in37 = *off and *in38 = *off
     C                              and *in39 = *off and *in40 = *off
     C                   seton                                        46
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'RO00144'
     C                   endif
     C                   endif
      *
      * Yields for 89998
      *
     C                   if        (d1cbcm2pc + d1cbbm2pc + d1cbrt2pc +
     C                              d1cbcl2pc) <> 100
     C                              and *in26 = *off and *in27 = *off
     C                              and *in28 = *off and *in29 = *off
     C                   seton                                        47
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'RO00145'
     C                   endif
     C                   endif
      *
     C                   endsr
      /eject
      *----------------------------------------------------------------
      * Validate the 6 Skirt Meat Allocation Flag fields
      *----------------------------------------------------------------
      *
     C     $skirt        begsr
      *
      * Small Commodity
     C                   if        d1sscfl <> yes and d1sscfl <> No
     C                   seton                                        41
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'RO09106'
     C                   endif
     C                   endif
      *
     C                   if        d1tscfl <> yes and d1tscfl <> No
     C                   seton                                        45
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'RO09106'
     C                   endif
     C                   endif
      *
      * Medium Commodity
     C                   if        d1smcfl <> yes and d1smcfl <> No
     C                   seton                                        42
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'RO09106'
     C                   endif
     C                   endif
      *
     C                   if        d1tmcfl <> yes and d1tmcfl <> No
     C                   seton                                        48
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'RO09106'
     C                   endif
     C                   endif
      *
      * Converted Brisket
     C                   if        d1scbfl <> yes and d1scbfl <> No
     C                   seton                                        44
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'RO09106'
     C                   endif
     C                   endif
      *
     C                   if        d1tcbfl <> yes and d1tcbfl <> No
     C                   seton                                        49
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'RO09106'
     C                   endif
     C                   endif
      *
     C                   endsr
      /eject
      *----------------------------------------------------------------
      * Write/update/delete record in database file
      *----------------------------------------------------------------
      *
     C     $accept       begsr
      *
      * If deleting, perform deletion integrity checks.
      *
     C                   if        action = delete
     C                   exsr      $dltck
     C                   endif
      *
      * If user action is revising or deleting, determine that the
      * record he is accessing still exists prior to attempting to
      * update.  Lock the record for update.
      *
     C                   if        error = 0 and                                If OK
     C                             (action = delete or action = revise)
     C     key01         chain     rol100a                            92
     C                   if        *in92 = *on                                  If not found
     C                   seton                                        62
     C                   if        error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'RO09008'
     C                   endif
     C                   endif                                                  If not found
     C                   endif                                                  If OK
      *
      * If there are no errors, delete, revise or create the record.
      *
     C                   if        error = 0                                    If no error
      *
     c                   select
     C                   when      action = delete
     C                   delete    ohreca
     C                   exsr      $dlt012
     C                   other
      *
      * MOVE DSPF fields to database file fields
      *
     C                   z-add     wkwedt        ohwedt
     C                   z-add     d1cono        ohcono
     C                   move      d1rcstcd      ohrcstcd
     C                   z-add     d1smokypc     ohsmokypc
     C                   z-add     d1bicrvl      ohbicrvl
     C                   z-add     d1bitrpc      ohbitrpc
     C                   z-add     d1altrpc      ohaltrpc
     C                   z-add     d1bicapc      ohbicapc
     C                   z-add     d1blcapc      ohblcapc
     C                   z-add     d1bibypc      ohbibypc
     C                   z-add     d1blbypc      ohblbypc
      *
     C                   z-add     d1cbrtpc      ohcbrtpc
     C                   z-add     d1cbstpc      ohcbstpc
      *
     C                   z-add     d1cbcm1pc     ohcbcm1pc
     C                   z-add     d1cbbm1pc     ohcbbm1pc
     C                   z-add     d1cbrt1pc     ohcbrt1pc
     C                   z-add     d1cbcl1pc     ohcbcl1pc
      *
     C                   z-add     d1cbcm2pc     ohcbcm2pc
     C                   z-add     d1cbbm2pc     ohcbbm2pc
     C                   z-add     d1cbrt2pc     ohcbrt2pc
     C                   z-add     d1cbcl2pc     ohcbcl2pc
      *
     C                   move      d1sscfl       ohsscfl
     C                   move      d1smcfl       ohsmcfl
     C                   move      d1scbfl       ohscbfl
     C                   move      d1tscfl       ohtscfl
     C                   move      d1tmcfl       ohtmcfl
     C                   move      d1tcbfl       ohtcbfl
      *
     C                   if        action = create
     C                   write     ohreca
     C                   exsr      $cpy012
     C                   else
     C                   update    ohreca
     C                   endif
     C                   endsl
      *
     C                   endif                                                  If no error
      *
      * Always redisplay when:
      *     1) there are errors
      *
     C                   select
     C                   when      error > 0
     C                   movel     scrn1         routne
     C                   other
      *
     C                   eval      rtncd = '00'
     C                   movel     exit          routne
     C                   endsl
      *
     C                   endsr
      /eject
      *----------------------------------------------------------------
      * Copy Item Control Data
      *----------------------------------------------------------------
      *
     C     $cpy012       begsr
      *
      * Find the most recent record in the Item Control File for this
      * company.
      *
     C     key02         setll     rop012
     C     d1cono        readpe(n) rop012                                 92
     C                   if        *in92 = *off                                 If prior recs
     C                   z-add     icwedt        svwedt
      *
      * Using the week-ending date just retrieved, read all the
      * records for this company/date. Write a new record with the
      * new Week-ending Date for each record read.
      *
     C     key03         setll     rop012
     C                   dou       *in91 = *on                                  Do copy
     C     key03         reade(n)  rop012                                 91
     C                   if        *in91 = *off                                 If not EOF
     C                   z-add     wkwedt        icwedt
     C                   write     icrec
     C                   endif                                                  If not EOF
     C                   enddo                                                  Do copy
      *
     C                   endif                                                  If prior recs
      *
     C                   endsr
      /eject
      *----------------------------------------------------------------
      * Delete Item Control Data
      *----------------------------------------------------------------
      * When a Resource Optimization Header is deleted, you must also
      * delete any/all Item Control data for that Company/Week.
      *
     C     $dlt012       begsr
      *
     C     key02         setll     rop012
      *
     C                   dou       *in91 = *on                                  Do copy
     C     key02         reade     rop012                                 91
     C                   if        *in91 = *off                                 If not EOF
     C                   delete    icrec
     C                   endif                                                  If not EOF
     C                   enddo                                                  Do copy
      *
     C                   endsr
      /eject
      *----------------------------------------------------------------
      * Deletion integrity checks
      *----------------------------------------------------------------
      *
     C     $dltck        begsr
      *
     C                   if        d1rcstcd <> 'O'and                           If not open
     C                             error < maxmsg
     C                   add       1             error
     C                   eval      mgid(e) = 'RO00105'
     C                   endif                                                  If not open
      *
     C                   endsr
      /eject
      *---------------------------------------------------------------
      * Write error messages
      *---------------------------------------------------------------
      *
     C     $wrmsg        begsr
      *
     C                   call      'UT80045J'                           43
     C                   parm                    mgid
     C                   parm                    mgdt
     C                   parm                    error
     C                   parm      sdpgm         pgm
     C                   parm      msgfil        msgfl
      *
      * If call to UT80045J failed, a message hardcoded in the DSPF
      * command line format will be set on. So, redisplay screen.
      *
     C                   if        *in43 = *on
     C                   eval      routne = set1
     C                   endif
      *
     C                   endsr
      /eject
      *----------------------------------------------------------------
      * Clear messages
      *----------------------------------------------------------------
      *
     C     $clmsg        begsr
      *
     C                   call      'UT80045J'                           43
     C                   parm      *blank        mgi
     C                   parm      *blank        mgd
     C                   parm      *zero         error
     C                   parm      sdpgm         pgm
     C                   parm      msgfil        msgfl
      *
      * If call to UT80045J failed, a message hardcoded in the DSPF
      * command line format will be set on; so, redisplay screen.
      *
     C                   if        *in43 = *on
     C                   eval      routne = set1
     C                   endif
      *
     C                   endsr
      /eject
      *----------------------------------------------------------------
      * Set on last record indicator and end job
      *----------------------------------------------------------------
      *
     C     $exit         begsr
     C                   seton                                        lr
     C                   endsr
      /eject
      *---------------------------------------------------------------
      * Initialization subroutine
      *---------------------------------------------------------------
      *
     C     *inzsr        begsr
      *
      * Parm Lists
      *
     C     *entry        plist
     C     d1mode        parm                    mode
     C                   parm                    d1cono
     C                   parm                    d1wemdy
     C     wkwedt        parm                    xxwedt
     C                   parm                    rtncd
      *
      * Key lists
      *
     C     key01         klist
     C                   kfld                    wkwedt
     C                   kfld                    d1cono
      *
     C     key02         klist
     C                   kfld                    d1cono
     C                   kfld                    wkwedt
      *
     C     key03         klist
     C                   kfld                    d1cono
     C                   kfld                    svwedt
      *
     C                   movel     mode          action
      *
      * Hardcode Company for now.
      *
     C                   z-add     360           d1cono
     C     d1cono        chain     caabrel1                           92
     C                   if        *in92 = *off
     C                   move      abadtx        d1conm
     C                   endif
      *
      * The following standard code must be included to make the
      * standard error message handling program function properly.
      * This code sets and clears the program message queue.
      *
     C                   movel     '*'           msgpgm
     C                   exsr      $clmsg
      *
     C                   endsr
      /eject
