     H/TITLE X0006  - Validate Cost Center Number
     H* ----------------------------------------------------------------
     H*
     H*    Copyright (c) 1992
     H*    J. D. Edwards & Company
     H*
     H*        This unpublished material is proprietary to
     H*        J. D. Edwards & Company.  All rights reserved.
     H*        The methods and techniques described herein are
     H*        considered trade secrets and/or confidential.
     H*        Reproduction or distribution, in whole or in part,
     H*        is forbidden except by express written permission
     H*        of J. D. Edwards & Company.
     H*
     H* ----------------------------------------------------------------
     H*                                                                -
     F*
     F*    PROGRAM REVISION LOG
     F*    --------------------
     F*
     F*          Date     Programmer     Nature of Revision
     F*        --------   ----------  ------------------------------------
     F*        08/24/92   DOTSON      SAR # 00522212
     F*        11/24/92   DOTSON      SAR # 00550168
     F*        04/01/93   DOTSON      SAR # 00559146
     F*        08/31/93   SW930339    SAR # 00651735
     F*        04/11/94   LB266041    SAR # 00728317
     F*        04/15/94   SPILLANE    SAR # 00774284
     F*        07/11/94   KIRKWOOD    SAR # 00791771
     F*        09/22/94   BUSS        SAR # 00820640
     F*        12/21/94   BUSS        SAR # 00864263
     F*        01/09/95   KIRKWOOD    SAR # 00866293
     F*
     F*****************************************************************
     F*
     F*    General Description
     F*    -------------------
     F*
     F*    This program performs the cost center scrub/unscrub
     F*    and optionally validates the cost center master record
     F*    in file F0006.  Cost center validation will occur if
     F*    the data structure I0006 is passed to receive the F0006
     F*    data structure. I0006 is contained in data structure
     F*    I000671 which must be added to the calling program with
     F*    a /COPY entry in the I specs.  If I0006 is passed alternate
     F*    language overrides will occur unless the optional language
     F*    parm is passed with a value of '**'.
     F*
     F*    The input account mode can be any of the following
     F*    values:
     F*     ' '= cost center in display mode
     F*      1 = cost center in database mode
     F*
     F*    The output account mode can be any of the following
     F*    values:
     F*     ' '= return cost center in display mode
     F*      1 = return cost center in database mode
     F*      I = return in same mode as input mode
     F*
     F*    The error return parameter will pass back a four digit
     F*    error number if error occurred.  Otherwise, this value will
     F*    be blank.
     F*
     F*****************************************************************
     F*
     F*    Cost Center master
     F*
     FF0006     IF   E           K DISK    USROPN
     F                                     RENAME(I0006:I00061)
     F*----------------------------------------------------------------
     F*
     F*    General constants
     F*
     FF0009     IF   E           K DISK    USROPN
     F*----------------------------------------------------------------
     F*
     F*    Flex Account Structure
     F*
     FF0907     IF   E           K DISK    USROPN
     F*
     F*
     F*    Cost Center Master - Alternate Description
     F*
     FF0006D    IF   E           K DISK    USROPN
     F                                     INFDS(DS006D)
     F**************************************************************
     D*****************************************************************
     D*    PROGRAM TABLES AND ARRAYS
     D*    -------------------------
     D*
     D*    Cost Center number array
     D*
     D*
     D*    Cost Center value array
     D*
     D*
     D*    Cost Center part arrays
     D*
     D @PL             S              5  0 DIM(12)                              part lengths
     D*
     D**************************************************************
     D*
     D*    Copy Composite Member for Common Subroutine - C0012
     D*
     D*/COPY JDECPY,E0012
     D**************************************************************
     D*  This is part of a composite common subroutine. In
     D*  order for the subroutine to work correctly, the
     D*  RPG program must /COPY in the following members:
     D*   E0012, C0012
     D*********************************************************************00004
     D*    PROGRAM TABLES AND ARRAYS
     D*    -------------------------
     D*
     D @NM             S              1    DIM(22)                              C0012 Scrub arr
     D @N2             S              1    DIM(22)                              C0012 Scrub arr
     D**************************************************************
     D*****************************************************************
     D*    PROGRAM INPUT SPECIFICATIONS AND DATA STRUCTURES
     D*    ------------------------------------------------
     D*
     D*    Constants
     D*
     D                 DS
     D $@AN            C                   CONST(12)
     D $@A             C                   CONST(12)
     D $@PV            C                   CONST(12)
     D*----------------------------------------------------------------
     D*
     D*    Cost Center number
     D*
     D DSMCU           DS
     D  @AN                    1     12
     D                                     DIM(12)                              Account number
     D  $MCUA                  1     12
     D*
     D DSCC            DS
     D  @A                     1     12
     D                                     DIM(12)                              Part values
     D  $MCU                   1     12
     D*----------------------------------------------------------------
     D*
     D*    Cost Center parts definition
     D*
     D DSPART          DS                  OCCURS(20)
     D  $XLEN                  1      2  0
     D  $XNUM                  3      3
     D  $XLR                   4      4
     D  $XBEG                  5      6  0
     D  $XEND                  7      8  0
     D*----------------------------------------------------------------
     D*
     D*    Cost Center part values
     D*
     D DS@PV           DS
     D  @PV                    1    144
     D                                     DIM(12)                              part values
     D  @PV001                 1     12
     D  @PV002                13     24
     D  @PV003                25     36
     D  @PV004                37     48
     D  @PV005                49     60
     D  @PV006                61     72
     D  @PV007                73     84
     D  @PV008                85     96
     D  @PV009                97    108
     D  @PV010               109    120
     D  @PV011               121    132
     D  @PV012               133    144
     D*----------------------------------------------------------------
     D*
     D*    Cost center maximum size
     D*
     D                 DS
     D $MXMCU          C                   CONST(12)
     D DS006D          DS
     D  $RCNT                156    159B 0
     D*----------------------------------------------------------------
     D*
     D*    Data Structure to Define Indexes in Common Subroutines
     D*
     D*/COPY JDECPY,I00DSINX
     D*                                                                    00001
     D*    This data strucure provides the field definitions of all
     D*    possible array index field names useable by all common
     D*    subroutines.
     D*
     D DSINX           DS                  INZ                                   00001
     D*
     D*    Indexes of 1 digit 0 decimals
     D*
     D  #A                     1      1  0
     D  #B                     2      2  0
     D  #C                     3      3  0
     D  #D                     4      4  0
     D  #E                     5      5  0
     D  #F                     6      6  0
     D*
     D*    Indexes of 2 digits 0 decimals
     D*
     D  #G                     7      8  0
     D  #H                     9     10  0
     D  #I                    11     12  0
     D  #J                    13     14  0
     D  #K                    15     16  0
     D  #L                    17     18  0
     D*
     D*    Indexes of 3 digits 0 decimals
     D*
     D  #M                    19     21  0
     D  #N                    22     24  0
     D  #O                    25     27  0
     D  #P                    28     30  0
     D  #Q                    31     33  0
     D  #R                    34     36  0
     D*
     D*    Indexes of 4 digits 0 decimals
     D*
     D  #S                    37     40  0
     D  #T                    41     44  0
     D  #U                    45     48  0
     D  #V                    49     52  0
     D  #W                    53     56  0
     D  #X                    57     60  0
     D  #Y                    61     64  0
     D  #Z                    65     68  0
     D*
     D*/COPY JDECPY,I00DSPROG
     D*****************************************************************    00003
     D*
     D*    PROGRAM STATUS DATA STRUCTURE
     D*    -----------------------------
     D*
     D*    Portions of this data structure are loaded at the time the
     D*    program is loaded.  Other portions of this data structure
     D*    are loaded as you perform I/O.
     D*
     D*    PURPOSE
     D*    -------
     D*    This common subroutine is set up to be used with C0000
     D*    (Cost Center Security) common subroutine and C0001(Edit
     D*    Action Code) common subroutine.  Those two subroutines
     D*    will retrieve ##USER for the user name.
     D*
     D*    No program calcs are done in this subroutine.
     D*
     D ##PSDS         SDS
     D*
     D*          Program Name
     D  ##PROG                 1     10
     D*          Status Code(09999=I/O Error)
     D  ##STAT                11     15  0
     D*          Previous Status code
     D  ##PSTA                16     20  0
     D*          RPG Source Statement Sequence Number
     D  ##SEQN                21     28
     D*          RPG Routine in Which Exception/Error Occured
     D  ##ROUT                29     36
     D*          Number of Parameters Passed to This Program
     D  ##PARM                37     39  0
     D*          Exception Type(MCH=Machine, CPF=CPF)
     D  ##ETYP                40     42
     D*          Exception Message Number
     D  ##ENBR                43     46
     D*          Machine Instruction/Object Definition Template Number
     D  ##MINO                47     50
     D*          Work Area for Messages
     D  ##MWRK                51     80
     D*          Name of Library in Which Program is Located
     D  ##PLIB                81     90
     D*          Retrieved Exdeption Data.  CPF Messages.
     D  ##MSG                 91    170
     D*          Identification of Exception That Caused RPG9001
     D  ##9001               171    174
     D*          Unused
     D  ##FLR1               175    200
     D*          Name of File for Last I/O(Only Updated if Error)
     D  ##LFIL               201    208
     D*          Status Info on Last File Used(Only on Error)
     D  ##LFST               209    243
     D*          Status Code on Last File Used(Only on Error)
     D  ##LFS5               209    213
     D*          Job Name
     D  ##JOBN               244    253
     D*          User Name From User Profile
     D  ##USER               254    263
     D*          Job Number
     D  ##JOB#               264    269  0
     D*          Date Job Entered the System(MMDDYY)
     D  ##JDT                270    275  0
     D*          Date of Program Execution(MMDDYY)
     D  ##EDT                276    281  0
     D*          Time of Program Execttion(HHMMSS)
     D  ##ETM                282    287  0
     D*          Date Program Was Compiled
     D  ##CDT                288    293  0
     D*          Time Program Was Compiled
     D  ##CTM                294    299  0
     D*          Level of the Compiler
     D  ##LVL                300    303
     D*          Source File Name
     D  ##SRCN               304    313
     D*          Source Library Name
     D  ##SRCL               314    323
     D*          Source File Member Name
     D  ##SRCM               324    333
     D*          Unused
     D  ##FLR2               334    429
     D*
     D*    Cost Center Master Record
     D*
     D*/COPY JDECPY,I000671
     D**************************************************************
     D*  This copy module contains the record image for the F0006
     D*  file at the A6.1 release level.
     D*****************************************************************
     D*
     D*    XF file server format, @@FMT = A71
     D*
     D I0006           DS          1000    INZ
     D*                                                                        )
     D*    cost center
     D  MCMCU                  1     12
     D*    type cost center
     D  MCSTYL                13     14
     D*    description - compressed
     D  MCDC                  15     54
     D*    level of detail
     D  MCLDM                 55     55
     D*    company
     D  MCCO                  56     60
     D*    address number
     D  MCAN8                 61     68  0
     D*    owner/receivable address
     D  MCAN8O                69     76  0
     D*    county
     D  MCCNTY                77     79
     D*    state
     D  MCADDS                80     82
     D*    flag model and consolidated Cost Centers
     D  MCFMOD                83     83
     D*    description
     D  MCDL01                84    113
     D*    description 02
     D  MCDL02               114    143
     D*    description 03
     D  MCDL03               144    173
     D*    description 04
     D  MCDL04               174    203
     D*    division x
     D  MCRP01               204    206
     D*    region
     D  MCRP02               207    209
     D*    group
     D  MCRP03               210    212
     D*    category code 04
     D  MCRP04               213    215
     D*    category code 05
     D  MCRP05               216    218
     D*    category code 06
     D  MCRP06               219    221
     D*    category code 07
     D  MCRP07               222    224
     D*    category code 08
     D  MCRP08               225    227
     D*    category code 09
     D  MCRP09               228    230
     D*    category code 10
     D  MCRP10               231    233
     D*    category code 11
     D  MCRP11               234    236
     D*    category code 12
     D  MCRP12               237    239
     D*    category code 13
     D  MCRP13               240    242
     D*    category code 14
     D  MCRP14               243    245
     D*    category code 15
     D  MCRP15               246    248
     D*    category code 16
     D  MCRP16               249    251
     D*    category code 17
     D  MCRP17               252    254
     D*    category code 18
     D  MCRP18               255    257
     D*    category code 19
     D  MCRP19               258    260
     D*    category code 20
     D  MCRP20               261    263
     D*    category code 21
     D  MCRP21               264    273
     D*    category code 22
     D  MCRP22               274    283
     D*    category code 23
     D  MCRP23               284    293
     D*    category code 24
     D  MCRP24               294    303
     D*    category code 25
     D  MCRP25               304    313
     D*    category code 26
     D  MCRP26               314    323
     D*    category code 27
     D  MCRP27               324    333
     D*    category code 28
     D  MCRP28               334    343
     D*    category code 29
     D  MCRP29               344    353
     D*    category code 30
     D  MCRP30               354    363
     D*    tax area
     D  MCTA                 364    373
     D*    tax entity
     D  MCTXJS               374    381  0
     D*    tax rate/area
     D  MCTXA1               382    391
     D*    tax expl code
     D  MCEXR1               392    393
     D*    tax/deduction codes 01
     D  MCTC01               394    397
     D*    tax/deduction codes 02
     D  MCTC02               398    401
     D*    tax/deduction codes 03
     D  MCTC03               402    405
     D*    tax/deduction codes 04
     D  MCTC04               406    409
     D*    tax/deduction codes 05
     D  MCTC05               410    413
     D*    tax/deduction codes 06
     D  MCTC06               414    417
     D*    tax/deduction codes 07
     D  MCTC07               418    421
     D*    tax/deduction codes 08
     D  MCTC08               422    425
     D*    tax/deduction codes 09
     D  MCTC09               426    429
     D*    tax/deduction codes 10
     D  MCTC10               430    433
     D*    tax distributable/non-distr 01
     D  MCND01               434    434
     D*    tax distributable/non-distr 02
     D  MCND02               435    435
     D*    tax distributable/non-distr 03
     D  MCND03               436    436
     D*    tax distributable/non-distr 04
     D  MCND04               437    437
     D*    tax distributable/non-distr 05
     D  MCND05               438    438
     D*    tax distributable/non-distr 06
     D  MCND06               439    439
     D*    tax distributable/non-distr 07
     D  MCND07               440    440
     D*    tax distributable/non-distr 08
     D  MCND08               441    441
     D*    tax distributable/non-distr 09
     D  MCND09               442    442
     D*    tax distributable/non-distr 10
     D  MCND10               443    443
     D*    compute status code 01
     D  MCCC01               444    444
     D*    compute status code 02
     D  MCCC02               445    445
     D*    compute status code 03
     D  MCCC03               446    446
     D*    compute status code 04
     D  MCCC04               447    447
     D*    compute status code 05
     D  MCCC05               448    448
     D*    compute status code 06
     D  MCCC06               449    449
     D*    compute status code 07
     D  MCCC07               450    450
     D*    compute status code 08
     D  MCCC08               451    451
     D*    compute status code 09
     D  MCCC09               452    452
     D*    compute status code 10
     D  MCCC10               453    453
     D*    posting edit (blank or n)
     D  MCPECC               454    454
     D*    summarization method
     D  MCALS                455    455
     D*    inv/stmt summarization method
     D  MCISS                456    456
     D*    g/l bank account
     D  MCGLBA               457    464
     D*    allocation level
     D  MCALCL               465    466
     D*    labor distri  meth
     D  MCLMTH               467    467
     D*    labor distri  mult
     D  MCLF                 468    470P 0
     D*    labor account
     D  MCOBJ1               471    476
     D*    premium account
     D  MCOBJ2               477    482
     D*    burden account
     D  MCOBJ3               483    488
     D*    subsidiary
     D  MCSUB1               489    496
     D*    total units
     D  MCTOU                497    504P 0
     D*    subledger inactive code
     D  MCSBLI               505    505
     D*    supervisor
     D  MCANPA               506    513  0
     D*    contract type
     D  MCCT                 514    517
     D*    certified job (y/n)
     D  MCCERT               518    518
     D*    project number
     D  MCMCUS               519    530
     D*    billing type
     D  MCBTYP               531    531
     D*    percent complete
     D  MCPC                 532    534P 2
     D*    percent complete - aggregate d
     D  MCPCA                535    537P 0
     D*    cost to complete (obsolete)
     D  MCPCC                538    545P 0
     D*    int comp code
     D  MCINTA               546    549
     D*    interest comp  code - late rev
     D  MCINTL               550    553
     D*    planned start date - Julian
     D  MCD1J                554    559  0
     D*    actual start date - Julian
     D  MCD2J                560    565  0
     D*    planned complete date - Julain
     D  MCD3J                566    571  0
     D*    actual complete date - Julain
     D  MCD4J                572    577  0
     D*    date other - 5 Julain
     D  MCD5J                578    583  0
     D*    date other - 6 Julain
     D  MCD6J                584    589  0
     D*    final payment
     D  MCFPDJ               590    595  0
     D*    cost at completion
     D  MCCAC                596    603P 0
     D*    profit at completion
     D  MCPAC                604    611P 0
     D*    eeo code (y/n)
     D  MCEEO                612    612
     D*    equipment rate code
     D  MCERC                613    614
     D*    user id
     D  MCUSER               615    624
     D*    program id
     D  MCPID                625    634
     D*    date updated
     D  MCUPMJ               635    640  0
     D*    work station id
     D  MCJOBN               641    650
     D*    time last updated
     D  MCUPMT               651    656  0
     D*
     D*
     D*    Data structure for call to X00921, to get language preferenc
     D*
     D*/COPY JDECPY,I00921
     D*
     D*    User Display Preference Data Structure
     D*
     D D00921          DS            22
     D*
     D*    Date Format
     D  #9FRMT                 1      3
     D*    Date Separator
     D  #9DSEP                 4      4
     D*    Language Preference
     D  #9LNGP                 5      6
     D*    Company
     D  #9CO                   7     11
     D*    Decimal Format
     D  #9DECF                12     12
     D*    Version Prefix
     D  #9VRSP                13     18
     D*    Currency Symbol (Future Use)
     D  #9CUR                 19     19
     D*    Country
     D  #9CTR                 20     22
     D*****************************************************************
     D*
     D*    System Values Data Structure
     D*
     D*/COPY JDECPY,I00QJDF
     D*****************************************************************
     D*
     D*    JDE System Values Data Structure
     D*    ================================
     D*
     D QJDF            DS          2000
     D*
     D*    Time-out period, in seconds, for menu display file
     D*    (This value obsoleted in release A3)
     D  #$TIME                31     36
     D*
     D*    Single/Double column menu indicator (*IN03)
     D*    (This value obsoleted in release A4)
     D  #$IN03                50     50
     D*
     D*    Source file library name
     D  #$LIBS                81     90
     D*
     D*    Color Palette flag (1=SAA  2=JDE).
     D  #$COLR               100    100
     D*
     D*    Menu display file library name
     D  #$LIBO               131    140
     D*
     D*    Menu display file soft coding data record key (F0020)
     D  #$VOK                141    148
     D*
     D*    User profile file (F0092) library name
     D  #$LIBD               181    190
     D*
     D*    Country code for menu masking
     D  #$CC                 191    193
     D*
     D*    Name of program to be executed by all terminals
     D  #$PROG               231    240
     D*
     D*    System Identification name
     D  #$SYID               281    288
     D*
     D*    Hidden Menu Key
     D  #$HIDM               331    340
     D*
     D*    Positions 381-399 are reserved for BPs or Clients to
     D*    override the Product ID and PTF level displayed on a
     D*    menu in the lower right corner when hidden selection
     D*    25 is taken.  Changes to the data area are done through
     D*    the CHGDTAARA command.  (11/08/95)
     D*
     D*    Product ID (ex. 'Genesis')
     D* reserved                            381 387 #$VERS
     D*    Product Release (ex. '1.1')
     D* reserved                            388 393 #$PRD
     D*    PC Identification (ex.'00009')
     D* reserved                            394 398 #$PC
     D*    Product ID Override Flag (Set to '1' to override)
     D* reserved                            399 399 #$PFLG
     D*
     D*    Member Master Editing Program
     D*    (This value obsoleted in release A5) ????
     D  #$EPGM               431    440
     D*
     D*    Time format (' '=am/pm, '1'=24hr)
     D  #$TF                 450    450
     D*
     D*    Date format (AD,AM DD, YYYY)
     D  #$DF                 451    466
     D*
     D*    Software Protection Notification Days
     D  #$SPD                481    483
     D*
     D*    Software Protection Expiration Date
     D  #$SPED               496    501
     D*
     D*    Software security code
     D  #$SPC                502    507
     D*
     D*    System/38 CPU serial number
     D*    (This value obsoleted in release F5 & A1)
     D*    Re-assigned this field to be the licensed user count for
     D*    User Based Pricing in A7.
     D  #$SRNO               508    512
     D  #$UBP$               508    512
     D  #$UBP#               508    512  0
     D*
     D*    User Based Pricing Audit Flag
     D  #$AUD                520    520
     D*
     D*    User Based Pricing Code
     D  #$UBP                535    544
     D*
     D*    Japanese date flag (' ' = Western  '1' = Japanese)
     D  #$JAPD               600    600
     D*
     D*    MARCAM flag (' ' = No  '1' = Yes)
     D  #$MARC               610    610
     D*
     D*    Software Installation Type (' ' = Normal Install,
     D*                                '1' = One Step Install)
     D  #$INST               611    611
     D*
     D*    Double byte system 1 = yes, 0 = no
     D  #$#RSP               620    620
     D*
     D*    Language preference
     D  #$LNGP               630    631
     D*
     D*    Version prefix
     D  #$VRSP               640    645
     D*
     D*    Number of Users
     D  #$USR                650    659
     D*
     D*    Pricing Method
     D  #$PRMT               670    670
     D*
     D*    Application Override System
     D  #$#SYR               680    683
     D*
     D*    Imaging
     D  #$IMG                690    690
     D*
     D*    Control File Library
     D  #$LIBC               701    710
     D*
     D*    Demo/Training Flag
     D  #$DEMO               720    721
     I*----------------------------------------------------------------
     C****************************************************************
     C*    MAINLINE PROGRAM
     C*    ----------------
     C*
     C*    *INZSR subroutine executed first time.
     C*
     C*    If no parameters, bypass routine.
     C*
     C     ##PARM        CABEQ     0             EOJ
     C*                    -----          ---
     C*
     C*    Initialize routine
     C*
     C                   EXSR      S999
     C*                    ---- ----
     C     PSERR         CABNE     *BLANKS       EOJ
     C*                    -----          ---
     C*------------------------------------------------------------------
     C*
     C*    Move parameters to input work fields
     C*
     C                   MOVEL     PSOMOD        $IOMOD                         output mode
     C                   MOVEL     PSIMOD        $IIMOD                         input mode
     C                   MOVEL     PSIMOD        $IMODE                         input mode
     C                   MOVEL     PSMCU         $IMCU                          cost center
     C                   MOVEL     $OEDIT        $IEDIT                         edit flag
     C*------------------------------------------------------------------
     C*
     C*    Determine input mode, symbol and cost center number
     C*      Input parms:
     C*          $IMODE  = input mode work field
     C*          P$MCU   = input cost center
     C*      Output parms:
     C*          $IMODE  = input mode work field
     C*          DSCC    = cost center data structure
     C*
     C                   EXSR      S003
     C*
     C*    Exit if errors occurred
     C*
     C     PSERR         CABNE     *BLANKS       EOJ
     C*                    -----          ---
     C*------------------------------------------------------------------
     C*
     C*    Determine output mode
     C*      Input parms:
     C*          PSOMOD  = output mode parameter
     C*          $IMODE  = input mode work field
     C*      Output parms:
     C*          $OMODE  = output mode work field
     C*
     C                   EXSR      S004
     C*                    ---- ----
     C*
     C*    Exit if errors occurred
     C*
     C     PSERR         CABNE     *BLANKS       EOJ
     C*                    -----          ---
     C*------------------------------------------------------------------
     C*
     C*    Create output cost center from input account
     C*      Input parms:
     C*          $OMODE  = output mode work field
     C*          $IMODE  = input mode work field
     C*          DSCC    = cost center data structure
     C*      Output parms:
     C*          P$MCU   = input cost center
     C*          I0006   = cost center master record
     C*
     C                   EXSR      S005
     C*                    ---- ----
     C*
     C*    Exit if errors occurred
     C*
     C     PSERR         CABNE     *BLANKS       END
     C*                    -----          ---
     C*------------------------------------------------------------------
     C*
     C*    Return.
     C*
     C     END           TAG
     C*          ---       ---
     C*------------------------------------------------------------------
     C*
     C*    Load output parameters
     C*
     C*    Cost center
     C*
DBN  C                   MOVE      DSMCU         PSMCU
     C*
     C*    Output mode
     C*
     C                   MOVEL     $OMODE        PSOMOD
     C*
     C*    Input mode
     C*
     C                   MOVEL     $IMODE        PSIMOD
     C*
     C*    Record return
     C*
B1   C     $OEDIT        IFEQ      '1'
DBN  C                   MOVEL     I0006         PS0006
E1   C                   ENDIF
     C*------------------------------------------------------------------
     C*
     C*    End of program
     C*
     C     EOJ           TAG
     C*          ---       ---
     C*
     C*    Process language overrides
     C*
     C                   EXSR      S011
     C*                    ---- ----
     C*
     C*    Exit program
     C*
     C                   RETURN
     C*
     C*    END MAINLINE PROGRAM
     C*    --------------------
     C*****************************************************************
     C**************************************************************************
     C*
     C*     SUBROUTINE S003  - Load input cost center number
     C*     --------------------------------------------
     C*
     C*      Input parms:
     C*          $IMODE  = input mode work field
     C*          P$MCU   = input cost center
     C*
     C*      Output parms:
     C*          $IMODE  = input mode work field
     C*          DSCC    = cost center data structure
     C*
     CSR   S003          BEGSR
     C*          ----      -----
     C*
     C*    Clear subroutine output parameters
     C*
     CSR                 MOVE      *BLANKS       DSCC                           cc numb     er
     C*------------------------------------------------------------------
     C*
     C*  If input cost center is blank, skip processing unless mode '9'
     C*
B1   CSR   P$MCU         IFEQ      *BLANKS                                      cc numb     er
     CSR                 GOTO      E003
     C*                    ---- ----
E1   CSR                 ENDIF
     C*------------------------------------------------------------------
     C*
     C*    Initialize input cost center array for parsing
     C*
     CSR                 MOVE      *BLANKS       DSMCU                          cc work
DBN  CSR                 MOVEL     P$MCU         DSMCU                          cc work
     C*------------------------------------------------------------------
     C*
     C*    Determine first position of cost center
     C*      Input parms:
     C*          $IMODE  = input mode work field
     C*          DSMCU   = cost center work structure
     C*      Output parms:
     C*          $IMODE  = input mode work field
     C*          DSMCU   = cost center work structure
     C*          $FPOS   = first position of cost center number
     C*
     CSR                 EXSR      S003A
     C*                    ---- -----
     C*
     C*    Exit routine if cost center has no first character
     C*
     CSR   $FPOS         CABLE     *ZERO         E003
     C*                    -----          ----
     C*------------------------------------------------------------------
     C*
     C*    Parse input cost center
     C*      Input parms:
     C*          DSMCU   = cost center work structure
     C*          $FPOS   = first position of cost center number
     C*          $IMODE  = input mode work field
     C*      Output parms:
     C*          $P      = number of cost center parts
     C*          @PV     = cost center part values
     C*          @PL     = cost center part lengths
     C*
     CSR                 EXSR      S003B
     C*                    ---- -----
     C*------------------------------------------------------------------
     C*
     C*    Process parsed input values
     C*
B1   CSR   $IMODE        CASEQ     '1'           S0031
     C*                    -----          -----
     CSR   $IMODE        CASEQ     *BLANK        S0032
     C*                    -----          -----
E1   CSR                 ENDCS
     C*
     C*    Exit subroutine if error occurred
     C*
     CSR   PSERR         CABNE     *BLANKS       E003
     C*                    -----          ----
     C*------------------------------------------------------------------
     C*
     CSR   E003          ENDSR
     C*****************************************************************
     C**************************************************************************
     C*
     C*     SUBROUTINE S003A - Locate first position
     C*     ----------------------------------------
     C*
     C*      Input parms:
     C*          $IMODE  = input mode work field
     C*          DSMCU   = cost center work structure
     C*      Output parms:
     C*          $IMODE  = input mode work field
     C*          DSMCU   = cost center account work structure
     C*          $FPOS   = first position of cost center number
     C*
     CSR   S003A         BEGSR
     C*          -----     -----
     C*
     C*    Initialize subroutine output parms
     C*
     CSR                 Z-ADD     *ZERO         $FPOS             5 0          first character
     C*------------------------------------------------------------------
     C*
     C*    Loop until first nonsymbol character is found
     C*
     CSR                 Z-ADD     1             #I
     C*
B1   CSR   $FPOS         DOWEQ     *ZERO
     CSR   #I            ANDLE     $@AN
     CSR                 MOVEL     @AN(#I)       $WRK1             1
     C*
     C*    Process nonblank character
     C*
B2   CSR   $WRK1         IFNE      *BLANKS
     C*
     C*    First nonsymbol character
     C*
     CSR                 Z-ADD     #I            $FPOS
     C*
E2   CSR                 ENDIF
     C*
     C*    Next position
     C*
     CSR                 ADD       1             #I
E1   CSR                 ENDDO
     C*------------------------------------------------------------------
     C*
     C*    Default entry mode
     C*
B1   CSR   $IMODE        IFEQ      *BLANKS
B2   CSR   $FLEX         IFEQ      '1'
     CSR                 MOVEL     *BLANK        $IMODE
X2   CSR                 ELSE
     CSR                 MOVEL     '1'           $IMODE
E2   CSR                 ENDIF
E1   CSR                 ENDIF
     C*------------------------------------------------------------------
     CSR   E003A         ENDSR
     C**************************************************************************
     C**************************************************************************
     C*
     C*     SUBROUTINE S003B - Parse input cost center
     C*     -------------------------------------- ------------
     C*
     C*      Input parms:
     C*          DSMCU   = cost center work structure
     C*          $FPOS   = first position of cost center number
     C*          $IMODE  = input mode work field
     C*      Output parms:
     C*          $P      = number of cost center parts
     C*          @PV     = cost center part values
     C*          @PL     = cost center part lengths
     C*
     CSR   S003B         BEGSR
     C*          -----     -----
     C*
     C*    Initialize subroutine output parameters
     C*
     CSR                 CLEAR                   @PV                            part values
     CSR                 CLEAR                   @PL                            part lengths
     CSR                 Z-ADD     *ZERO         $P                5 0          # of parts
     C*------------------------------------------------------------------
     C*
     C*    Initialize parsing values
     C*
     CSR                 Z-ADD     $FPOS         #I                             array position
     CSR                 Z-ADD     $FPOS         $BEG              5 0          part begin
     CSR                 Z-ADD     *ZERO         $LEN              5 0          part length
     CSR                 Z-ADD     *ZERO         $LST              5 0          part end
     CSR                 Z-ADD     1             $SEG              2 0          seg length
     CSR                 Z-ADD     1             #X
B1   CSR   #X            IFLE      $XPART
     CSR   #X            OCCUR     DSPART
E1   CSR                 ENDIF
     C*
     C*    Set delimiter flag
     C*
     CSR                 MOVEL     '1'           $DELIM            1
     C*------------------------------------------------------------------
     C*
     C*    Parse cost center string
     C*
B1   CSR   #I            DOWLE     $@AN
     CSR                 MOVEL     '0'           $SEP              1
     CSR                 MOVEL     @AN(#I)       $WRK1             1
     C*------------------------------------------------------------------
     C*
     C*    If last character, set implicit delimiter
     C*
B2   CSR   #I            IFEQ      $@AN
B3   CSR   $WRK1         IFNE      *BLANKS                                      default delimit
     CSR                 Z-ADD     #I            $LST
E3   CSR                 ENDIF
     CSR                 ADD       1             #I
E2   CSR                 ENDIF
     C*------------------------------------------------------------------
     C*
     C*    Determine if character is a delimiter.
     C*
     C*    Default delimiters
     C*
B2   CSR   $WRK1         IFEQ      '.'                                          default delimit
     CSR   $DELIM        ANDEQ     '1'
     CSR   $WRK1         OREQ      ','                                          default delimit
     CSR   $DELIM        ANDEQ     '1'
     C*
     C*    System defined delimiter
     C*
     CSR   $WRK1         OREQ      GCSEP                                        system delimit
     CSR   *BLANKS       ANDNE     GCSEP
     CSR   $DELIM        ANDEQ     '1'
     CSR                 MOVEL     '1'           $SEP
E2   CSR                 ENDIF
     C*
B2   CSR   $SEP          IFEQ      '1'
     C*
     C*    Implicit delimiter - end of structure reached
     C*
     CSR   #I            ORGT      $@AN                                         end of string
     C*
     C*    Implicit delimiter - no seperator entered
     C*
     CSR   $SEG          ORGT      $XLEN                                        new segment g
     CSR   $IMODE        ANDEQ     *BLANK                                                   g
     CSR   $P            ANDLT     $XPART                                                   g
     C*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . --
     C*
     C*    Load value array if position and length nonzero
     C*
     CSR                 ADD       1             $P                             part number
     CSR   $LST          SUB       $BEG          $LEN                           part length
     CSR                 ADD       1             $LEN                           part length
     C*
     C*    Load @PV with value if position and length are valid
     C*
B3   CSR   $LEN          IFGT      *ZERO
     CSR   $BEG          ANDGT     *ZERO
     CSR   $LEN          SUBST     DSMCU:$BEG    @PV($P)                81      part value
     CSR                 Z-ADD     $LEN          @PL($P)                        part length
E3   CSR                 ENDIF
     C*
     C*    Reset position and length values
     C*
     C*    If no seperator entered, current position is beginning
     C*    of next segment
     C*
B3   CSR   $SEP          IFEQ      '0'
     CSR                 Z-ADD     #I            $BEG                           part begin
     CSR                 Z-ADD     1             $SEG                           seg length
     C*
     C*    If seperator entered, next position is beginning
     C*    of next segment
     C*
X3   CSR                 ELSE
     CSR   #I            ADD       1             $BEG                           part begin
     CSR                 Z-ADD     *ZERO         $SEG                           seg length
E3   CSR                 ENDIF
     C*
     CSR                 Z-ADD     *ZERO         $LEN                           part length
     CSR                 Z-ADD     *ZERO         $LST                           part end
     CSR                 ADD       1             #X
B3   CSR   #X            IFLE      $XPART
     CSR   #X            OCCUR     DSPART
E3   CSR                 ENDIF
     C*
X2   CSR                 ELSE
     C*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . --
     C*
     C*    Determine last nonblank character in cost center
     C*
B3   CSR   $WRK1         IFNE      *BLANKS
     CSR   $LST          OREQ      *ZERO
     CSR                 Z-ADD     #I            $LST
E3   CSR                 ENDIF
E2   CSR                 ENDIF
     C*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . --
     C*
     C*    Increment index
     C*
     CSR                 ADD       1             #I
     CSR                 ADD       1             $SEG
     C*
E1   CSR                 ENDDO
     C*------------------------------------------------------------------
     C*
     C*    If last part is blank, disregard
     C*
B1   CSR   $P            IFGT      *ZERO
B2   CSR   @PV($P)       IFEQ      *BLANKS
     CSR                 Z-ADD     *ZERO         @PL($P)
     CSR                 SUB       1             $P
E2   CSR                 ENDIF
E1   CSR                 ENDIF
     C*----------------------------------------------------------------
     CSR   E003B         ENDSR
     C**************************************************************************
     C**************************************************************************
     C*
     C*     SUBROUTINE S0031 - Process long cost center parts
     C*     -------------------------------------------------
     C*
     C*  Input
     C*       @PV      = Cost Center part values
     C*       @PL      = Cost Center part lengths
     C*       $P       = Number of cost center parts
     C*
     C*  Output
     C*       DSCC     = Cost Center string without delimiters
     C*
     CSR   S0031         BEGSR
     C*          -----     -----
     C*------------------------------------------------------------------
     C*
     C*    Check for too many cost center parts
     C*
B1   CSR   $P            IFGT      1
     CSR                 MOVEL     '3090'        PSERR
     CSR                 GOTO      E0031
     C*                    ---- -----
E1   CSR                 ENDIF
     C*------------------------------------------------------------------
     C*
     C*    Check if cost center part is too large
     C*
B1   CSR   @PL(1)        IFGT      $MXMCU
     CSR                 MOVEL     '3090'        PSERR
     CSR                 GOTO      E0031
     C*                    ---- -----
E1   CSR                 ENDIF
     C*------------------------------------------------------------------
     C*
     C*    Build DSCC   from @PV
     C*
     C*    Move cost center, right justified
     C*
B1   CSR   @PV001        IFNE      *BLANKS
DBN  CSR                 MOVEL     @PV001        DSMCU
     CSR                 Z-ADD     1             #X
     CSR   13            SUB       @PL(1)        #I
B2   CSR   #I            DOWLE     $MXMCU
     CSR                 MOVEL     @AN(#X)       @A(#I)
     CSR                 ADD       1             #X
     CSR                 ADD       1             #I
E2   CSR                 ENDDO
E1   CSR                 ENDIF
     C*----------------------------------------------------------------
     C*
     CSR   E0031         ENDSR
     C**************************************************************************
     C*
     C*     SUBROUTINE S0032  - Process flex with delimiter
     C*     -----------------------------------------------
     C*
     C*  Input
     C*       @PV      = Cost Center part values
     C*       @PL      = Cost Center part lengths
     C*       $P       = Number of cost center parts
     C*
     C*  Output
     C*       DSCC     = Cost Center string without delimiters
     C*
     CSR   S0032         BEGSR
     C*          -----     -----
     C*
     C*------------------------------------------------------------------
     C*
     C*    Check for too many cost center parts
     C*
B1   CSR   $P            IFGT      $XPART
     CSR                 MOVEL     '3090'        PSERR
     CSR                 GOTO      E0032
     C*                    ---- -----
E1   CSR                 ENDIF
     C*------------------------------------------------------------------
     C*
     C*    Build DSCC   from @PV
     C*
     C*    Loop on each cost center part
     C*
     CSR                 Z-ADD     1             #I                             @PV index
B1   CSR   1             DO        $XPART        #X
     CSR   #X            OCCUR     DSPART
     C*
     C*    Check if cost center part too long
     C*
B2   CSR   @PL(#I)       IFGT      $XLEN
     CSR                 MOVEL     '2474'        PSERR
     CSR                 GOTO      E0032
     C*                    ---- -----
E2   CSR                 ENDIF
     C*
     CSR                 MOVE      *BLANKS       DSMCU
     C*
     C*    Scrub numeric value
     C*
B2   CSR   $XNUM         IFEQ      'N'
     CSR                 MOVEL     @PV(#I)       $PV
     CSR                 MOVEA     $PV           @NM
     CSR                 EXSR      C0012
     C*                    ---- -----
     CSR                 Z-ADD     #NUMR         $NBR29           29 0
     CSR                 MOVE      $NBR29        DSMCU
X2   CSR                 ELSE
     C*
     C*    Load character value
     C*
DBN  CSR                 MOVEL     @PV(#I)       DSMCU
E2   CSR                 ENDIF
     C*
     C*    Calculate position to begin moving from and to
     C*
B2   CSR   $XNUM         IFEQ      'N'
     CSR   $@AN          SUB       $XLEN         $F                5 0
     CSR                 ADD       1             $F
     CSR                 Z-ADD     $XBEG         $BEG
X2   CSR                 ELSE
B3   CSR   $XLR          IFEQ      'R'
     CSR                 Z-ADD     1             $F
     CSR   $XLEN         SUB       @PL(#I)       $BEG
     CSR                 ADD       $XBEG         $BEG
X3   CSR                 ELSE
     CSR                 Z-ADD     1             $F
     CSR                 Z-ADD     $XBEG         $BEG
E3   CSR                 ENDIF
E2   CSR                 ENDIF
     C*
     C*    Move cost center part to DSCC
     C*
B2   CSR   $BEG          DO        $XEND         #Z
     CSR                 MOVE      @AN($F)       @A(#Z)
     CSR                 ADD       1             $F
E2   CSR                 ENDDO
     C*
     CSR                 ADD       1             #I
E1   CSR                 ENDDO
     C*----------------------------------------------------------------
     C*
     CSR   E0032         ENDSR
     C**************************************************************************
     C**************************************************************************
     C*
     C*     SUBROUTINE S004  - Scrub output mode
     C*     ------------------------------------
     C*
     C*      Input parms:
     C*          PSOMOD  = output mode parameter
     C*          $IMODE  = input mode work field
     C*      Output parms:
     C*          $OMODE  = output mode work field
     C*
     CSR   S004          BEGSR
     C*          ----      -----
     C*
     C*----------------------------------------------------------------
     C*
     C*    Determine output mode
     C*
     CSR                 MOVEL     PSOMOD        $OMODE            1
     C*
     C*    Output mode is default mode
     C*
B1   CSR   $OMODE        IFEQ      *BLANK
B2   CSR   $FLEX         IFEQ      '1'
     CSR                 MOVEL     *BLANK        $OMODE
X2   CSR                 ELSE
     CSR                 MOVEL     '1'           $OMODE
E2   CSR                 ENDIF
E1   CSR                 ENDIF
     C*----------------------------------------------------------------
     C*
     C*    Output mode is same as input mode
     C*
B1   CSR   $OMODE        IFEQ      'I'
     CSR   $OMODE        OREQ      'U'
     CSR                 MOVEL     $IMODE        $OMODE
E1   CSR                 ENDIF
     C*----------------------------------------------------------------
     C*
     CSR   E004          ENDSR
     C*****************************************************************
     C*****************************************************************
     C*
     C*     SUBROUTINE S005  - Create output cost center
     C*     --------------------------------------------
     C*
     C*      Input parms:
     C*          DSCC    = cost center data structure
     C*          DSMCU   = cost center string
     C*          $OMODE  = output mode work field
     C*          $IMODE  = input mode work field
     C*      Output parms:
     C*          P$MCU   = input cost center
     C*          I0006   = cost center master record
     C*
     CSR   S005          BEGSR
     C*          ----      -----
     C*
     CSR                 CLEAR                   DSMCU
     CSR                 CLEAR                   P$MCU
     C*----------------------------------------------------------------
     C*
     C*    Create output cost center from input cost center
     C*
     C*      Input parms:
     C*          DSCC    = cost center data structure
     C*          $OMODE  = output mode work field
     C*          $IMODE  = input mode work field
     C*      Output parms:
     C*          DSMCU   = cost center string
     C*          I0006   = cost center master record
     C*          P$MCU   = input cost center
     C*
B1   CSR                 SELECT
W1   CSR   $OMODE        WHENEQ    '1'
     CSR   GCSEP         OREQ      *BLANK
     CSR                 EXSR      S0051
     C*                    ---- -----
W1   CSR   $OMODE        WHENEQ    *BLANK
     CSR                 EXSR      S0052
     C*                    ---- -----
W1   CSR                 OTHER
     CSR                 EXSR      S005A
     C*                    ---- -----
E1   CSR                 ENDSL
     C*----------------------------------------------------------------
     C*
     CSR   E005          ENDSR
     C*****************************************************************
     C**************************************************************************
     C*
     C*     SUBROUTINE S0051 - Create long cost center
     C*     ---------------------------------------------------------
     C*
     C*  Input
     C*       DSCC     = Cost Center string without delimiters
     C*       DSMCU    = Cost Center string
     C*
     C*  Output
     C*       P$MCU    = Cost center
     C*
     CSR   S0051         BEGSR
     C*          -----     -----
     C*
     C*----------------------------------------------------------------
     C*
     C*    Create output from input
     C*
B1   CSR   $OEDIT        IFEQ      '1'
     CSR                 EXSR      S010
     C*                    ---- ----
     CSR                 MOVEL     MCMCU         P$MCU
X1   CSR                 ELSE
     CSR                 MOVEL     $MCU          P$MCU
E1   CSR                 ENDIF
     C*
DBN  CSR                 MOVE      P$MCU         DSMCU
     C*----------------------------------------------------------------
     CSR   E0051         ENDSR
     C**************************************************************************
     C**************************************************************************
     C*
     C*     SUBROUTINE S0052  - Create flex cost center with delimiters
     C*     -----------------------------------------------------------
     C*
     C*  Input
     C*       DSCC     = Cost Center string without delimiters
     C*       DSMCU    = Cost Center string
     C*
     C*  Output
     C*       $MCU   = Cost Center string with delimiters
     C*
     C*
     CSR   S0052         BEGSR
     C*          -----     -----
     C*
     C*----------------------------------------------------------------
     C*
     C*    Create output from input
     C*
B1   CSR   $OEDIT        IFEQ      '1'
     CSR                 EXSR      S010
     C*                    ---- ----
     CSR                 MOVE      MCMCU         $MCU
E1   CSR                 ENDIF
     C*
     C*----------------------------------------------------------------
     C*
     C*    Determine delimiter
     C*
     CSR                 MOVEL     '.'           $DEL              1
B1   CSR   GCSEP         IFNE      *BLANK
     CSR                 MOVEL     GCSEP         $DEL
E1   CSR                 ENDIF
     C*
     C*    Load output
     C*
     CSR                 Z-ADD     1             #I                             output array
     C*
     C*    Process each cost center part
     C*
B1   CSR   1             DO        $XPART        #X
     CSR   #X            OCCUR     DSPART
     C*
     C*    Load cost center part
     C*
B2   CSR   $XBEG         DO        $XEND         #O
     CSR                 MOVE      @A(#O)        @AN(#I)
     CSR                 ADD       1             #I
E2   CSR                 ENDDO
     C*
     C*    Insert delimiter if there is more to come
     C*
B2   CSR   #X            IFLT      $XPART
     CSR   $XEND         ADD       1             #O
     CSR   $@A           SUB       $XEND         #M
B3   CSR   #O            IFLE      $@A
     CSR   #M            ANDGT     *ZERO
     CSR   #M            SUBST     DSCC:#O       $WRK30           30
B4   CSR   $WRK30        IFNE      *BLANKS
     CSR                 MOVEL     $DEL          @AN(#I)
     CSR                 ADD       1             #I
E4   CSR                 ENDIF
E3   CSR                 ENDIF
E2   CSR                 ENDIF
     C*
E1   CSR                 ENDDO
     C*----------------------------------------------------------------
     C*    Right justify DSMCU for output
     C*
B1   CSR   #I            IFLE      $MXMCU
     CSR                 SUB       1             #I
     CSR                 Z-ADD     $MXMCU        #X
B2   CSR   #I            DOWGT     *ZERO
     CSR                 MOVE      @AN(#I)       @AN(#X)
     CSR                 MOVE      *BLANK        @AN(#I)
     CSR                 SUB       1             #I
     CSR                 SUB       1             #X
E2   CSR                 ENDDO
E1   CSR                 ENDIF
     C*
     CSR   E0052         ENDSR
     C**************************************************************************
     C**************************************************************************
     C*
     C*     SUBROUTINE S005A - Invalid Output Mode
     C*     --------------------------------------
     C*
     C*  Input
     C*       DSCC     = Cost Center string without delimiters
     C*       DSMCU    = Cost Center string
     C*
     C*  Output
     C*       $MCUA    = Cost Center string with delimiters
     C*
     C*
     CSR   S005A         BEGSR
     C*          -----     -----
     C*
     C*    Load error message
     C*
     CSR                 MOVEL     '3091'        PSERR
     C*
     C*    Clear cost center structure
     C*
     CSR                 CLEAR                   I0006
     C*
     C*    Clear cost center number
     C*
     CSR                 CLEAR                   $MCUA
     C*----------------------------------------------------------------
     CSR   E005A         ENDSR
     C**************************************************************************
     C**************************************************************************
     C*
     C*     SUBROUTINE S010  - Validate/Translate Cost Center
     C*     -------------------------------------------------
     C*
     C*  Input
     C*       DSCC     = Cost Center string without delimiters
     C*       $IMODE   = Input mode
     C*
     C*  Output
     C*       I0006    = Cost Center master record
     C*       PSERR    = Error code
     C*
     CSR   S010          BEGSR
     C*          ----      -----
     C*
     CSR                 CLEAR                   I0006
     C*----------------------------------------------------------------
     C*
     C*    Bypass subroutine if cost center master does not exist
     C*
     CSR   $0006         CABEQ     '1'           E010
     C*                    -----          ----
     C*----------------------------------------------------------------
     C*
     C*    Chain to cost center master by cost center number
     C*
B1   CSR   $IMODE        IFEQ      *BLANK
     CSR   $IMODE        OREQ      '1'
     CSR                 MOVE      $MCU          MCMCU
     CSR   MCMCU         CHAIN     I00061                             81
X1   CSR                 ELSE
     C*
     C*    Invalid input mode - unable to chain
     C*
     CSR                 SETON                                        81
E1   CSR                 ENDIF
     C*----------------------------------------------------------------
     C*
     C*    Check for invalid record
     C*
B1   CSR   *IN81         IFEQ      '1'
     CSR   $OEDIT        ANDEQ     '1'
     CSR                 MOVEL     '3091'        PSERR
E1   CSR                 ENDIF
     C*
     C*----------------------------------------------------------------
     CSR   E010          ENDSR
     C**************************************************************************
     C****************************************************************
     C*
     C*    SUBROUTINE S011   - Language Overrides
     C*    --------------------------------------
     C*
     C*    Processing:
     C*                 1.  Determine Alternate Language.
     C*                 2.  Retrieve alternate descriptions and
     C*                     override base descriptions if appropriate.
     C*
     CSR   S011          BEGSR
     C*          ----      -----
     C*
     C*    Fetch user language preference from F00921
     C*
B1   CSR   ##PARM        IFEQ      6                                                        f
B2   CSR                 SELECT
W2   CSR   PSLNG         WHENEQ    *BLANKS                                                  r
     CSR                 MOVE      #9LNGP        $LNGP             2
W2   CSR   PSLNG         WHENEQ    '**'
     CSR                 MOVE      *BLANKS       $LNGP
W2   CSR                 OTHER
     CSR                 MOVE      PSLNG         $LNGP
E2   CSR                 ENDSL
X1   CSR                 ELSE
     CSR                 MOVE      #9LNGP        $LNGP             2
E1   CSR                 ENDIF
     C*
     CSR   $LNGP         IFEQ      *BLANKS
     CSR                 MOVE      #$LNGP        $LNGP             2
     CSR                 ENDIF
     C*
     C*    If language preference is not blank, try to get an
     C*    alternate description from the F0006D file.
     C*
     CSR                 MOVEL     *BLANKS       LJDL01
     CSR                 MOVEL     *BLANKS       LJDL02
     CSR                 MOVEL     *BLANKS       LJDL03
     CSR                 MOVEL     *BLANKS       LJDL04
     C*
     CSR                 MOVEL     MCDL01        $SDL01
     CSR                 MOVEL     MCDL02        $SDL02
     CSR                 MOVEL     MCDL03        $SDL03
     CSR                 MOVEL     MCDL04        $SDL04
     C*
B1   CSR   $LNGP         IFNE      *BLANKS
     CSR   KY006D        CHAIN     F0006D                             9899
B2   CSR   LJDL01        IFEQ      *BLANKS
     CSR   LJDL02        ANDEQ     *BLANKS
     CSR   LJDL03        ANDEQ     *BLANKS
     CSR   LJDL04        ANDEQ     *BLANKS
     CSR                 MOVEL     $SDL01        MCDL01
     CSR                 MOVEL     $SDL02        MCDL02
     CSR                 MOVEL     $SDL03        MCDL03
     CSR                 MOVEL     $SDL04        MCDL04
X2   CSR                 ELSE
     CSR                 MOVEL     LJDL01        MCDL01
     CSR                 MOVEL     LJDL02        MCDL02
     CSR                 MOVEL     LJDL03        MCDL03
     CSR                 MOVEL     LJDL04        MCDL04
E2   CSR                 ENDIF
E1   CSR                 ENDIF
     C*
B1   CSR   $OEDIT        IFEQ      '1'
DBN  CSR                 MOVEL     I0006         PS0006
E1   CSR                 ENDIF
     C*
     CSR                 CLEAR                   $OEDIT
     C*
     CSR   E011          ENDSR
     C*****************************************************************
     C*****************************************************************
     C*
     C*    Copy Common Subroutine - Scrub numeric value
     C*
     C*/COPY JDECPY,C0012
     C**************************************************************
     C*  This is part of a composite common subroutine. In
     C*  order for the subroutine to work correctly, the
     C*  RPG program must /COPY in the following members:
     C*   E0012, C0012
     C**************************************************************************
    C*    REVISION LOG
    C*    ------------
    C*
    C*          Date     Programmer     Nature of Revision
    C*        --------   ----------  ------------------------------------
    C*        12/11/97   BECK        SAR# 1810110
    C*
     C**************************************************************************
     C*    MAINLINE PROGRAM
     C*    ----------------
     C*
     C*
     C*     SUBROUTINE C0012 - Right Justify Numeric Fields
     C*     -----------------------------------------------
     C*
     C*  PURPOSE
     C*  -------
     C*       To provide a subroutine common to all programs which
     C*       right justifies numeric fields and places the sign over
     C*       the low order byte of the fields, designated by either a
     C*       leading or trailing minus sign.  This routine also ignores
     C*       all non-numeric characters in the input field, and
     C*       determines the placement of the decimal point.
     C*
     C*  REMARKS
     C*  -------
     C*
     C*       Prior to executing this subroutine data from an
     C*       alphanumeric input field should be placed in the array
     C*       named '@NM' with a 'MOVEA' command.  The right justified
     C*       number is available from the subroutine field named
     C*       '#NUMR', which is a 15 digit 6 decimal field.
     C*       CAUTION: The largest number that can be handled
     C*       by this subroutine is 999,999,999.999999.
     C*       However, the input field may contain only 15
     C*       numbers.
     C*
     CSR   C0012         BEGSR
     C*          -----     -----
     C*
     CSR                 Z-ADD     0             #NUMR            29 9
     CSR                 Z-ADD     0             #NUMR2           15 2          Compile only
     CSR                 Z-ADD     0             #NUMR9           15 9          Compile only
     C*
     CSR                 MOVEA     @NM           #ALNUM           22
     CSR   #ALNUM        CABEQ     *BLANKS       EN0012
     CSR                 SETOFF                                       818384
     CSR                 MOVEA     *ALL'0'       @N2
     CSR                 Z-ADD     0             #K1               3 0
     CSR                 Z-ADD     0             #K2               3 0
     CSR                 Z-ADD     0             Q#                3 0
     CSR                 Z-ADD     0             J#                3 0
     CSR                 Z-ADD     0             M#                3 0
     C*
     C*    Retrieve date separation and decimal format characters.
     C*
     CSR   ###1          IFEQ      ' '                                          Do once
     CSR                 MOVE      '1'           ###1              1
     CSR                 CALL      'X00SFMT '                           81
     C*                    ---- ----------
     CSR                 PARM      '/'           ###DS             1
     CSR                 PARM      ' '           ###DF             1
     CSR                 MOVE      '.'           ###DC             1
     CSR   ###DF         IFEQ      'J'
     CSR   ###DF         OREQ      'I'
     CSR                 MOVE      ','           ###DC
     CSR                 END
     CSR                 MOVE      ' '           ###EQ             1
     CSR   ###DS         IFEQ      ###DC
     CSR                 MOVE      '1'           ###EQ
     CSR                 END
     CSR                 END
     C*
     C*    If date separator character equals decimal format character,
     C*    Test for multiple decimal point characters and replace with
     C*    US standard date separator character(/).
     C*
     CSR   ###EQ         IFEQ      '1'
     C*
     CSR                 Z-ADD     0             Q#
     CSR                 DO        22            M#
     CSR   @NM(M#)       IFEQ      ###DC
     CSR                 ADD       001           Q#
     CSR                 END
     CSR                 END
     C*
     CSR   Q#            IFGT      1
     CSR                 DO        22            M#
     CSR   @NM(M#)       IFEQ      ###DC
     CSR                 MOVE      '/'           @NM(M#)
     CSR                 END
     CSR                 END
     CSR                 END
     C*
     CSR                 MOVEA     @NM           #ALNUM
     CSR                 END
     C*
     C*    Initialize beginning and ending scan positions.
     C*
     CSR                 Z-ADD     +1            #LOW              3 0
     CSR                 Z-ADD     +22           #HIGH             3 0
     C*
     C*    Find first non-blank character.
     C*
     CSR   ' '           CHECK     #ALNUM        #LOW
     C*
     C*    Find last non-blank character.
     C*
     CSR   ' '           CHECKR    #ALNUM        #HIGH
     C*
     C*    Test minus sign.
     C*    String may be surrounded by quotes... ( dftval from DD )
     C*
     C* &&&      '-'       SCAN #ALNUM                   83
     CSR                 Z-ADD     #LOW          M#
     CSR   @NM(M#)       IFEQ      ''''
     CSR                 ADD       +1            M#
     CSR                 ENDIF
     C*
     CSR   @NM(M#)       COMP      '-'                                    83
     C*
     CSR   *IN83         IFEQ      '0'
     CSR                 Z-ADD     #HIGH         M#
     CSR   @NM(M#)       IFEQ      ''''
     CSR   M#            ANDGT     +1
     CSR                 SUB       1             M#
     CSR                 ENDIF
     C*
     CSR   @NM(M#)       COMP      '-'                                    83
     CSR                 ENDIF
     C*
     C*    Scrub numeric value.
     C*
     CSR                 Z-ADD     #HIGH         M#
     CSR                 Z-ADD     22            Q#
     CSR                 SUB       1             #LOW
     CSR   M#            DOWGT     #LOW
     CSR                 MOVE      @NM(M#)       @NMM#             1
     CSR   @NMM#         IFNE      *BLANKS
     CSR   @NMM#         IFGE      '0'
     CSR   @NMM#         ANDLE     '9'
     CSR   *IN84         IFEQ      '0'
     CSR                 ADD       001           #K1
     CSR                 END
     CSR                 MOVE      @NMM#         @N2(Q#)
     CSR                 SUB       01            Q#
     CSR                 END
     C*
     C*    If decimal point not already found, test for decimal.
     C*
     CSR   *IN84         IFEQ      '0'
     CSR   @NMM#         COMP      ###DC                                  84
     CSR                 END
     C*
     CSR                 END
     CSR                 SUB       001           M#
     CSR                 END
     C*
     C*    Move whole scrubbed number to work field.
     C*
     CSR                 MOVEA     @N2           #ALNUM
     CSR                 MOVE      #ALNUM        #WK29            29 0
     CSR                 Z-ADD     1             #MULTX           11 9
     CSR                 Z-ADD     1             #MULTY           11 9
     C*
     C*    Set up divisor for decimal positions.
     C*
     CSR   *IN84         IFEQ      '1'                                          DECIMAL FND
     CSR   #K1           IFGT      9
     CSR   #K1           SUB       9             #K2
     CSR                 DO        #K2
     CSR                 MULT      .1            #MULTY
     CSR                 END
     CSR                 Z-ADD     9             #K1
     CSR                 END
     CSR                 DO        #K1
     CSR                 MULT      .1            #MULTX
     CSR                 END
     CSR                 ELSE
     CSR                 Z-ADD     0             #K1
     CSR                 Z-ADD     0             #K2
     CSR                 END
     C*
     C*    If negative number, reverse sign on result.
     C*
     CSR   *IN83         IFEQ      '1'
     CSR                 MULT      -1            #WK29
     CSR                 END
     C*
     C*    Position decimal point in result.
     C*
     CSR   #WK29         MULT      #MULTX        #NUMR            29 9
     CSR   #K2           IFGT      0
     CSR                 MULT      #MULTY        #NUMR
     CSR                 END
     C*
     C*    Test for truncation of high value digits.
     C*
     CSR   6             SUB       #K1           M#
     CSR                 ADD       7             M#
     CSR                 Z-ADD     1             Q#
     CSR                 MOVE      ' '           #HV#              1
     CSR   Q#            DOWLE     M#
     CSR   @N2(Q#)       IFGT      '0'
     CSR                 MOVE      '1'           #HV#
     CSR                 Z-ADD     M#            Q#
     CSR                 END
     CSR                 ADD       01            Q#
     CSR                 END
     CSR   #HV#          IFEQ      '1'
     CSR   #WK29         MULT(H)   #MULTX        #NUMR2
     CSR   #K2           IFGT      0
     CSR                 MULT(H)   #MULTY        #NUMR2
     CSR                 END
     CSR                 END
     C*
     C*    Test for truncation of low value digits.
     C*
     CSR                 Z-ADD     0             $NBR3             3 0
     CSR   #K1           IFGT      6
     CSR                 Z-ADD     0             $NBR3
     CSR                 MOVE      #WK29         $NBR1             1 0
     CSR                 MOVE      $NBR1         $NBR3
     CSR                 END
     CSR   #K1           IFGT      7
     CSR                 Z-ADD     0             $NBR3
     CSR                 MOVE      #WK29         $NBR2             2 0
     CSR                 Z-ADD     $NBR2         $NBR3
     CSR                 END
     CSR   #K1           IFGT      8
     CSR                 MOVE      #WK29         $NBR3             3 0
     CSR                 END
     CSR   $NBR3         IFNE      0
     CSR   #WK29         MULT      #MULTX        #NUMR9
     CSR   #K2           IFGT      0
     CSR                 MULT      #MULTY        #NUMR9
     CSR                 END
     CSR                 END
     C*
     CSR                 MOVEA     *BLANK        @NM
     C*
     CSR   EN0012        ENDSR
     C*****************************************************************
     C****************************************************************
     C*
     C*    SUBROUTINE S999   - Initial subroutine
     C*    --------------------------------------
     C*
     C*    Processing:
     C*                 1.  Initialize output parameters.
     C*                 2.  Validate input parameters.
     C*                 3.  Retrieve processing options.
     C*                 4.  Initialize variables.
     C*                      -system date and time
     C*                      -clear warning message array
     C*                      -initialize tax structure
     C*
     CSR   S999          BEGSR
     C*          ----      -----
     C*-----------------------------------------------------------------
     C*
     C*    Entry parameters...
     C*
     CSR   *ENTRY        PLIST
     C*
     C*    1.  Output mode of entry
     C*
     CSR                 PARM                    PSOMOD            1            output mode
     C*
     C*    2.  Input mode of entry
     C*
     CSR                 PARM                    PSIMOD            1            input mode
     C*
     C*    3.  Cost center
     C*
     CSR                 PARM                    PSMCU            12            cost center
     C*
     C*    4.  Error flag
     C*
     CSR                 PARM                    PSERR             4            error flag
     C*
     C*    5.  F0901 data structure
     C*
     CSR                 PARM                    PS0006                         F0006 record
     C*
     C*    6.  Language override
     C*
     CSR                 PARM                    PSLNG             2
     C*
     C*-----------------------------------------------------------------
     C*
     C*    Initialize output parameters
     C*
     CSR                 MOVE      *BLANKS       P$MCU
     C*
     CSR                 MOVE      *BLANKS       PSERR                          error flag
     CSR                 MOVE      PSMCU         P$MCU
     C*
     C*-----------------------------------------------------------------
     C*
     C*    Validate parameters
     C*
     C*    Return F0006 record value
     C*
B1   CSR   ##PARM        IFGE      5
     CSR                 MOVE      '1'           $OEDIT            1
X1   CSR                 ELSE
     CSR                 MOVE      '0'           $OEDIT
E1   CSR                 ENDIF
     C*
     C*    Output mode
     C*
B1   CSR   PSOMOD        IFNE      ' '
     CSR   PSOMOD        ANDNE     '1'
     CSR   PSOMOD        ANDNE     'I'
     CSR   PSOMOD        ANDNE     'U'
     CSR                 MOVEL     '3088'        PSERR
E1   CSR                 ENDIF
     C*
     C*    Input mode
     C*
B1   CSR   PSIMOD        IFNE      ' '
     CSR   PSIMOD        ANDNE     '1'
     CSR                 MOVEL     '3089'        PSERR
E1   CSR                 ENDIF
     C*-----------------------------------------------------------------
     C*
     CSR   E999          ENDSR
     C*****************************************************************
     C*****************************************************************
     C*
     C*    SUBROUTINE S999KL - Key list definitions
     C*    ----------------------------------------
     C*
     CSR   S999KL        BEGSR
     C*
     C*    Flex key list
     C*
     CSR   GYKY01        KLIST
     CSR                 KFLD                    GYRETY
     CSR                 KFLD                    GYSBTY
     C*
     C*    KLIST for F0006D.
     C*
     CSR   KY006D        KLIST
     CSR                 KFLD                    MCMCU
     CSR                 KFLD                    $LNGP
     C*
     CSR   E999KL        ENDSR
     C*****************************************************************
     C*****************************************************************
     C*
     C*    SUBROUTINE S999LK - *LIKE definitions
     C*    -------------------------------------
     C*
     CSR   S999LK        BEGSR
     C*
     C*    Work fields
     C*
     CSR   *LIKE         DEFINE    PSMCU         P$MCU
     CSR   *LIKE         DEFINE    I0006         PS0006
     CSR   *LIKE         DEFINE    @PV           $PV
     CSR   *LIKE         DEFINE    MCDL01        $SDL01
     CSR   *LIKE         DEFINE    MCDL02        $SDL02
     CSR   *LIKE         DEFINE    MCDL03        $SDL03
     CSR   *LIKE         DEFINE    MCDL04        $SDL04
     C*
     C*    Save fields for subroutines
     C*
     C*
     C*    Save fields for input parameters
     C*
     CSR   *LIKE         DEFINE    PSIMOD        $IMODE
     CSR   *LIKE         DEFINE    PSIMOD        $IIMOD
     CSR   *LIKE         DEFINE    PSOMOD        $IOMOD
     CSR   *LIKE         DEFINE    PSMCU         $IMCU
     CSR   *LIKE         DEFINE    $OEDIT        $IEDIT
     C*
     C*    Save fields for default values
     C*
     CSR   *LIKE         DEFINE    $XBEG         $SVBEG
     CSR   *LIKE         DEFINE    $XLEN         $PLEN
     C*
     CSR   E999LK        ENDSR
     C*****************************************************************
     C*****************************************************************
     C*
     C*    SUBROUTINE *INZSR - Initial subroutine - first time only
     C*    --------------------------------------------------------
     C*
     C*    Processing:
     C*                 1.  Open database files
     C*                 2.  Retrieve constants
     C*                 3.  Load speed codes array
     C*
     CSR   *INZSR        BEGSR
     C*          ------    -----
     C*-----------------------------------------------------------------
     C*
     C*    Retrieve General Constants record
     C*
     C*      Returns the following values:
     C*        GCSEP  = account separator character
     C*                 (default allows either '.' or ',')
     C*
     CSR                 OPEN      F0009
     C*
     CSR   *BLANKS       CHAIN     I0009                              81
     C*
     C*    Close file
     C*
     CSR                 CLOSE     F0009
     C*-----------------------------------------------------------------
     C*    Determine if flex is on.
     C*
     CSR                 MOVE      *BLANK        $FLEX             1
     CSR                 CALL      'X0907'                              98
     C*                    ---- -------
     CSR                 PARM                    PSFLEX            1
     C*
B1   CSR   *IN98         IFNE      '1'
     CSR   PSFLEX        ANDEQ     'Y'
     CSR                 MOVEL     '1'           $FLEX
E1   CSR                 ENDIF
     C*-----------------------------------------------------------------
     CSR                 CLEAR                   DSPART
     C*
     C*    Open cost center master file
     C*
     CSR                 MOVE      '0'           $0006             1
     C*
     CSR                 OPEN      F0006                                81
B1   CSR   *IN81         IFEQ      '1'
     CSR                 MOVE      '1'           $0006
E1   CSR                 ENDIF
     C*
     C*-----------------------------------------------------------------
     C*
     C*    Load cost center parts array for flex cost center
     C*
B1   CSR   $FLEX         IFEQ      '1'
     C*
     C*    If flex file does not exist, set off flex
     C*
     CSR                 OPEN      F0907                                81
B2   CSR   *IN81         IFEQ      '1'
     CSR                 MOVEL     *BLANK        $FLEX
X2   CSR                 ELSE
     C*
     C*    Initialize flex cost center parts
     C*
     CSR                 Z-ADD     *ZERO         $XCLEN            5 0          cost ctr length
     CSR                 Z-ADD     *ZERO         $XPART            5 0          part number
     CSR                 Z-ADD     1             #X                             begin position
     C*
     C*    Load cost center parts array for flex cost center
     C*    Subtype 1 = cost center part
     C*
     CSR                 Z-ADD     1             GYRETY
     CSR                 Z-ADD     1             GYSBTY
     CSR   GYKY01        SETLL     I0907
B3   CSR   *IN81         DOUEQ     '1'
     CSR   GYKY01        READE     I0907                                  81
B4   CSR   *IN81         IFEQ      '0'
     C*
     C*
     C*    Load cost center part
     C*
     CSR                 ADD       1             $XPART                         part number
     CSR   $XPART        OCCUR     DSPART
     C*
     C*    Positions and length
     C*
     CSR                 Z-ADD     #X            $XBEG                          begin position
     CSR                 Z-ADD     GYELL         $XLEN                          length
     CSR                 ADD       $XLEN         #X                             next position
     CSR   #X            SUB       1             $XEND                          end position
     C*
     C*    Attributes
     C*
     CSR                 MOVE      GYELTY        $XNUM                          numeric (A/N)
     CSR                 MOVE      GYLR          $XLR                           justify L/R
B5   CSR   GYDTAI        IFEQ      'MCU'
     CSR                 MOVEL     'R'           $XLR
E5   CSR                 ENDIF
     C*
     C*    Accumulate number and length of cost center parts
     C*
     CSR                 ADD       GYELL         $XCLEN                         cost ctr length
     C*
E4   CSR                 ENDIF
E3   CSR                 ENDDO
     C*----------------------------------------------------------------
     C*
     C*    Close Flex Chart file
     C*
     CSR                 CLOSE     F0907
     C*
     C*    If no cost center parts are defined,
     C*    set flex off
     C*
B3   CSR   $XPART        IFEQ      0                                                        ts
     CSR                 MOVEL     *BLANK        $FLEX
E3   CSR                 ENDIF
     C*
     C*    Recalculate cost center begin/end positions
     C*
B3   CSR   $XCLEN        IFLT      $MXMCU
     CSR   $MXMCU        SUB       $XCLEN        #I
B4   CSR   1             DO        $XPART        #X
     CSR   #X            OCCUR     DSPART
     CSR                 ADD       #I            $XBEG
     CSR                 ADD       #I            $XEND
E4   CSR                 ENDDO
E3   CSR                 ENDIF
     C*
E2   CSR                 ENDIF
E1   CSR                 ENDIF
     C*----------------------------------------------------------------
     C*
     C*    Fetch user language preference from F00921 - #9LNGP
     C*
     CSR                 CLEAR                   D00921
     CSR                 CALL      'X00921'
     C*                    ---- --------
     CSR                 PARM                    D00921
     C*
     C*    Retreive preference from QJDF - #$LNGP
     C*
     CSR                 CALL      'X00QJDF'
     C*                    ---- ---------
     CSR                 PARM                    QJDF
     C*-----------------------------------------------------------------
     C*
     C*    Open Cost Center Master - Alternate Description
     C*
B1   CSR   #9LNGP        IFNE      *BLANKS
     CSR                 OPEN      F0006D                               81
     C*
B1   CSR   *IN81         IFEQ      '1'
B1   CSR   $RCNT         OREQ      *ZEROS
     CSR                 MOVE      *BLANKS       $LNGP
E1   CSR                 ENDIF
E1   CSR                 ENDIF
     C*
     C*----------------------------------------------------------------
     C*
     CSR   EINZSR        ENDSR
     C*****************************************************************
