     H/TITLE X09012  - Validate Subsidiary Number
     H* ----------------------------------------------------------------
     H*
     H*    Copyright (c) 1993
     H*    J. D. Edwards & Company
     H*
     H*        This unpublished material is proprietary to
     H*        J. D. Edwards & Company.  All rights reserved.
     H*        The methods and techniques described herein are
     H*        considered trade secrets and/or confidential.
     H*        Reproduction or distribution, in whole or in part,
     H*        is forbidden except by express written permission
     H*        of J. D. Edwards & Company.
     H*
     H* ----------------------------------------------------------------
     H*                                                                -
     F*
     F*    PROGRAM REVISION LOG
     F*    --------------------
     F*
     F*          Date     Programmer     Nature of Revision
     F*        --------   ----------  ------------------------------------
     F*        01/19/93   DOTSON      SAR # 00415425
     F*        04/13/93   DOTSON      SAR # 00559146
     F*        11/08/93   BUSS        SAR # 00681580
     F*        04/11/94   LB266041    SAR # 00729512
     F*        06/05/96   NM5479276   SAR # 01225551
     F*        10/14/96   MAKOOI      SAR # 01278856
     F*        08/01/97   CHAMBERS    SAR # 01668854
     F*
     F*****************************************************************
     F*
     F*    General Description
     F*    -------------------
     F*
     F*    This program performs the subsidiary scrub/unscrub.
     F*
     F*    The input mode can be any of the following
     F*    values:
     F*     ' '= subsidiary in display mode
     F*      1 = subsidiary in database mode
     F*
     F*    The output mode can be any of the following
     F*    values:
     F*     ' '= return subsidiary in display mode
     F*      1 = return subsidiary in database mode
     F*
     F*    The error return parameter will pass back a four digit
     F*    error number if error occurred.  Otherwise, this value will
     F*    be blank.
     F*
     F*****************************************************************
     F*
     F*    General constants
     F*
     FF0009     IF   E           K DISK    USROPN
     F*----------------------------------------------------------------
     F*
     F*    Flex Account Structure
     F*
     FF0907     IF   E           K DISK    USROPN
     F*
     F**************************************************************
     D*****************************************************************
     D*    PROGRAM TABLES AND ARRAYS
     D*    -------------------------
     D*
     D*    subsidiary number array
     D*
     D*
     D*    subsidiary value array
     D*
     D*
     D*    subsidiary part arrays
     D*
     D @PV             S              8    DIM(4)                               part values
     D @PL             S              5  0 DIM(4)                               part lengths
     D*
     D**************************************************************
     D*
     D*    Copy Composite Member for Common Subroutine - C0012
     D*
     D*/COPY JDECPY,E0012
     D**************************************************************
     D*  This is part of a composite common subroutine. In
     D*  order for the subroutine to work correctly, the
     D*  RPG program must /COPY in the following members:
     D*   E0012, C0012
     D*********************************************************************00004
     D*    PROGRAM TABLES AND ARRAYS
     D*    -------------------------
     D*
     D @NM             S              1    DIM(22)                              C0012 Scrub arr
     D @N2             S              1    DIM(22)                              C0012 Scrub arr
     D**************************************************************
     D*****************************************************************
     D*    PROGRAM INPUT SPECIFICATIONS AND DATA STRUCTURES
     D*    ------------------------------------------------
     D*
     D*    Constants
     D*
     D                 DS
     D $@AN            C                   CONST(8)
     D $@A             C                   CONST(8)
     D*----------------------------------------------------------------
     D*
     D*    subsid number
     D*
     D DSSUB           DS
     D  @AN                    1      8
     D                                     DIM(8)                               Account number
     D*
     D DSS             DS
     D  @A                     1      8
     D                                     DIM(8)                               Part values
     D  $SUB                   1      8
     D*----------------------------------------------------------------
     D*
     D*    subsidiary parts definition
     D*
     D DSFLEX          DS                  OCCURS(20)
     D  $XLEN                  1      2  0
     D  $XNUM                  3      3
     D  $XLR                   4      4
     D  $XBEG                  5      6  0
     D  $XEND                  7      8  0
     D*----------------------------------------------------------------
     D*
     D*    subsidiary maximum size
     D*
     D                 DS
     D $MXSUB          C                   CONST(8)
     D*----------------------------------------------------------------
     D*
     D*    Data Structure to Define Indexes in Common Subroutines
     D*
     D*/COPY JDECPY,I00DSINX
     D*                                                                    00001
     D*    This data strucure provides the field definitions of all
     D*    possible array index field names useable by all common
     D*    subroutines.
     D*
     D DSINX           DS                  INZ                                   00001
     D*
     D*    Indexes of 1 digit 0 decimals
     D*
     D  #A                     1      1  0
     D  #B                     2      2  0
     D  #C                     3      3  0
     D  #D                     4      4  0
     D  #E                     5      5  0
     D  #F                     6      6  0
     D*
     D*    Indexes of 2 digits 0 decimals
     D*
     D  #G                     7      8  0
     D  #H                     9     10  0
     D  #I                    11     12  0
     D  #J                    13     14  0
     D  #K                    15     16  0
     D  #L                    17     18  0
     D*
     D*    Indexes of 3 digits 0 decimals
     D*
     D  #M                    19     21  0
     D  #N                    22     24  0
     D  #O                    25     27  0
     D  #P                    28     30  0
     D  #Q                    31     33  0
     D  #R                    34     36  0
     D*
     D*    Indexes of 4 digits 0 decimals
     D*
     D  #S                    37     40  0
     D  #T                    41     44  0
     D  #U                    45     48  0
     D  #V                    49     52  0
     D  #W                    53     56  0
     D  #X                    57     60  0
     D  #Y                    61     64  0
     D  #Z                    65     68  0
     D*
     D*/COPY JDECPY,I00DSPROG
     D*****************************************************************    00003
     D*
     D*    PROGRAM STATUS DATA STRUCTURE
     D*    -----------------------------
     D*
     D*    Portions of this data structure are loaded at the time the
     D*    program is loaded.  Other portions of this data structure
     D*    are loaded as you perform I/O.
     D*
     D*    PURPOSE
     D*    -------
     D*    This common subroutine is set up to be used with C0000
     D*    (Cost Center Security) common subroutine and C0001(Edit
     D*    Action Code) common subroutine.  Those two subroutines
     D*    will retrieve ##USER for the user name.
     D*
     D*    No program calcs are done in this subroutine.
     D*
     D ##PSDS         SDS
     D*
     D*          Program Name
     D  ##PROG                 1     10
     D*          Status Code(09999=I/O Error)
     D  ##STAT                11     15  0
     D*          Previous Status code
     D  ##PSTA                16     20  0
     D*          RPG Source Statement Sequence Number
     D  ##SEQN                21     28
     D*          RPG Routine in Which Exception/Error Occured
     D  ##ROUT                29     36
     D*          Number of Parameters Passed to This Program
     D  ##PARM                37     39  0
     D*          Exception Type(MCH=Machine, CPF=CPF)
     D  ##ETYP                40     42
     D*          Exception Message Number
     D  ##ENBR                43     46
     D*          Machine Instruction/Object Definition Template Number
     D  ##MINO                47     50
     D*          Work Area for Messages
     D  ##MWRK                51     80
     D*          Name of Library in Which Program is Located
     D  ##PLIB                81     90
     D*          Retrieved Exdeption Data.  CPF Messages.
     D  ##MSG                 91    170
     D*          Identification of Exception That Caused RPG9001
     D  ##9001               171    174
     D*          Unused
     D  ##FLR1               175    200
     D*          Name of File for Last I/O(Only Updated if Error)
     D  ##LFIL               201    208
     D*          Status Info on Last File Used(Only on Error)
     D  ##LFST               209    243
     D*          Status Code on Last File Used(Only on Error)
     D  ##LFS5               209    213
     D*          Job Name
     D  ##JOBN               244    253
     D*          User Name From User Profile
     D  ##USER               254    263
     D*          Job Number
     D  ##JOB#               264    269  0
     D*          Date Job Entered the System(MMDDYY)
     D  ##JDT                270    275  0
     D*          Date of Program Execution(MMDDYY)
     D  ##EDT                276    281  0
     D*          Time of Program Execttion(HHMMSS)
     D  ##ETM                282    287  0
     D*          Date Program Was Compiled
     D  ##CDT                288    293  0
     D*          Time Program Was Compiled
     D  ##CTM                294    299  0
     D*          Level of the Compiler
     D  ##LVL                300    303
     D*          Source File Name
     D  ##SRCN               304    313
     D*          Source Library Name
     D  ##SRCL               314    323
     D*          Source File Member Name
     D  ##SRCM               324    333
     D*          Unused
     D  ##FLR2               334    429
     C****************************************************************
     C*    MAINLINE PROGRAM
     C*    ----------------
     C*
     C*    *INZSR subroutine executed first time.
     C*
     C*    If no parameters, bypass routine.
     C*
     C     ##PARM        CABEQ     0             EOJ
     C*                    -----          ---
     C*
     C*    If Flex is not ON, no need to execute this sever.
     C*
     C     GCFLEX        CABNE     'Y'           EOJ
     C*                    -----          ---
     C*
     C*    Initialize routine
     C*
     C                   EXSR      S999
     C*                    ---- ----
     C     PSERR         CABNE     *BLANKS       EOJ
     C*                    -----          ---
     C*------------------------------------------------------------------
     C*
     C*    Move parameters to input work fields
     C*
     C                   MOVEL     PSIMOD        $IMODE                         input mode
     C                   MOVEL     PSOMOD        $OMODE
     C*------------------------------------------------------------------
     C*
     C*    Determine input mode and subsidiary number
     C*      Input parms:
     C*          $IMODE  = input mode work field
     C*          P$SUB   = input subsidiary
     C*      Output parms:
     C*          $IMODE  = input mode work field
     C*          DSS    = subsidiary data structure
     C*
     C                   EXSR      S003
     C*                    ---- ----
     C*
     C*    Exit if errors occurred
     C*
     C     PSERR         CABNE     *BLANKS       EOJ
     C*                    -----          ---
     C*------------------------------------------------------------------
     C*
     C*    Create output subsidiary from input subsidiary
     C*      Input parms:
     C*          $OMODE  = output mode work field
     C*          $IMODE  = input mode work field
     C*          DSS     = subsidiary data structure
     C*      Output parms:
     C*          P$SUB   = input subsidiary
     C*
     C                   EXSR      S005
     C*                    ---- ----
     C*
     C*    Exit if errors occurred
     C*
     C     PSERR         CABNE     *BLANKS       END
     C*                    -----          ---
     C*------------------------------------------------------------------
     C*
     C*    Return.
     C*
     C     END           TAG
     C*          ---       ---
     C*------------------------------------------------------------------
     C*
     C*    Load output parameters
     C*
     C*    subsidiary
     C*
DBN8 C                   MOVE      DSSUB         PSSUB
     C*
     C*    Output mode
     C*
     C                   MOVEL     $OMODE        PSOMOD
     C*
     C*    Input mode
     C*
     C                   MOVEL     $IMODE        PSIMOD
     C*
     C*------------------------------------------------------------------
     C*
     C*    End of program
     C*
     C     EOJ           TAG
     C*          ---       ---
     C*
     C*    Exit program
     C*
     C                   RETURN
     C*
     C*    END MAINLINE PROGRAM
     C*    --------------------
     C*****************************************************************
     C**************************************************************************
     C*
     C*     SUBROUTINE S003  - Load input subsidiary number
     C*     --------------------------------------------
     C*
     C*      Input parms:
     C*          $IMODE  = input mode work field
     C*          P$SUB   = input subsidiary
     C*
     C*      Output parms:
     C*          $IMODE  = input mode work field
     C*          DSS     = subsidiary data structure
     C*
     CSR   S003          BEGSR
     C*          ----      -----
     C*
     C*    Clear subroutine output parameters
     C*
     CSR                 MOVE      *BLANKS       DSS                            sub numb    er
     C*------------------------------------------------------------------
     C*
     C*  If input subsidiary is blank, skip processing
     C*
B1   CSR   P$SUB         IFEQ      *BLANKS                                      sub numb    er
     CSR                 GOTO      E003
     C*                    ---- ----
E1   CSR                 ENDIF
     C*------------------------------------------------------------------
     C*
     C*    Initialize input subsidiary array for parsing
     C*
     CSR                 MOVE      *BLANKS       DSSUB                          sub work
DBN  CSR                 MOVEL     P$SUB         DSSUB                          sub work
     C*------------------------------------------------------------------
     C*
     C*    Determine first position of subsidiary
     C*      Input parms:
     C*          $IMODE  = input mode work field
     C*          DSSUB   = subsidiary work structure
     C*      Output parms:
     C*          $IMODE  = input mode work field
     C*          DSSUB   = subsidiary work structure
     C*          $FPOS   = first position of subsidiary number
     C*
     CSR                 EXSR      S003A
     C*                    ---- -----
     C*
     C*    Exit routine if subsidiary has no first character
     C*
     CSR   $FPOS         CABLE     *ZERO         E003
     C*                    -----          ----
     C*------------------------------------------------------------------
     C*
     C*    Parse input subsid
     C*      Input parms:
     C*          DSSUB   = subsidiary work structure
     C*          $FPOS   = first position of subsidiary number
     C*          $IMODE  = input mode work field
     C*      Output parms:
     C*          $P      = number of subsidiary parts
     C*          @PV     = subsidiary part values
     C*          @PL     = subsidiary part lengths
     C*
     CSR                 EXSR      S003B
     C*                    ---- -----
     C*------------------------------------------------------------------
     C*
     C*    Process parsed input values
     C*
B1   CSR   $IMODE        CASEQ     '1'           S0031
     C*                    -----          -----
     CSR   $IMODE        CASEQ     ' '           S0032
     C*                    -----          -----
E1   CSR                 ENDCS
     C*
     C*    Exit subroutine if error occurred
     C*
     CSR   PSERR         CABNE     *BLANKS       E003
     C*                    -----          ----
     C*------------------------------------------------------------------
     C*
     CSR   E003          ENDSR
     C*****************************************************************
     C**************************************************************************
     C*
     C*     SUBROUTINE S003A - Locate first position
     C*     ----------------------------------------
     C*
     C*      Input parms:
     C*          $IMODE  = input mode work field
     C*          DSSUB   = subsidiary work structure
     C*      Output parms:
     C*          $IMODE  = input mode work field
     C*          DSSUB   = subsidiary account work structure
     C*          $FPOS   = first position of subsidiary number
     C*
     CSR   S003A         BEGSR
     C*          -----     -----
     C*
     C*    Initialize subroutine output parms
     C*
     CSR                 Z-ADD     *ZERO         $FPOS             5 0          first character
     C*------------------------------------------------------------------
     C*
     C*    Loop until first nonblank character is found
     C*
     CSR                 Z-ADD     1             #I
     C*
B1   CSR   $FPOS         DOWEQ     *ZERO
     CSR   #I            ANDLE     $@AN
     CSR                 MOVEL     @AN(#I)       $WRK1             1
     C*
     C*    Process nonblank character
     C*
B2   CSR   $WRK1         IFNE      *BLANKS
     C*
     C*    First nonblank character
     C*
     CSR                 Z-ADD     #I            $FPOS
     C*
E2   CSR                 ENDIF
     C*
     C*    Next position
     C*
     CSR                 ADD       1             #I
E1   CSR                 ENDDO
     C*------------------------------------------------------------------
     CSR   E003A         ENDSR
     C**************************************************************************
     C**************************************************************************
     C*
     C*     SUBROUTINE S003B - Parse input subsidiary
     C*     -----------------------------------------
     C*
     C*      Input parms:
     C*          DSSUB   = subsidiary work structure
     C*          $FPOS   = first position of subsidiary number
     C*          $IMODE  = input mode work field
     C*      Output parms:
     C*          $P      = number of subsidiary parts
     C*          @PV     = subsidiary part values
     C*          @PL     = subsidiary part lengths
     C*
     CSR   S003B         BEGSR
     C*          -----     -----
     C*
     C*    Initialize subroutine output parameters
     C*
     CSR                 CLEAR                   @PV                            part values
     CSR                 CLEAR                   @PL                            part lengths
     CSR                 CLEAR                   $SUBL                          Subl. length
     CSR                 Z-ADD     *ZERO         $P                5 0          # of parts
     C*------------------------------------------------------------------
     C*
     C*    Initialize parsing values
     C*
     CSR                 Z-ADD     $FPOS         #I                             array position
     CSR                 Z-ADD     $FPOS         $BEG              5 0          part begin
     CSR                 Z-ADD     *ZERO         $LEN              5 0          part length
     CSR                 Z-ADD     *ZERO         $LST              5 0          part end
     CSR                 Z-ADD     1             $SEG              2 0          seg length
     CSR                 Z-ADD     1             #X
B1   CSR   #X            IFLE      $XPART
     CSR   #X            OCCUR     DSFLEX
E1   CSR                 ENDIF
     C*
     C*------------------------------------------------------------------
     C*
     C*    Parse subsidiary string
     C*
B1   CSR   #I            DOWLE     $@AN
     CSR                 MOVEL     '0'           $SEP              1
     CSR                 MOVEL     @AN(#I)       $WRK1             1
     C*------------------------------------------------------------------
     C*
     C*    If last character, set implicit delimiter
     C*
B2   CSR   #I            IFEQ      $@AN
     CSR                 Z-ADD     #I            $LST
     CSR                 ADD       1             #I
E2   CSR                 ENDIF
     C*------------------------------------------------------------------
     C*
     C*    Determine if character is a delimiter.
     C*
     C*    Default delimiters
     C*
B2   CSR   $WRK1         IFEQ      '.'                                          default delimit
     CSR   $WRK1         OREQ      ','                                          default delimit
     C*
     C*    System defined delimiter
     C*
     CSR   $WRK1         OREQ      GCSEP                                        system delimit
     CSR   *BLANKS       ANDNE     GCSEP
     CSR                 MOVEL     '1'           $SEP
E2   CSR                 ENDIF
     C*
B2   CSR   $SEP          IFEQ      '1'
     C*
     C*    Implicit delimiter - end of structure reached
     C*
     CSR   #I            ORGT      $@AN                                         end of string
     C*
     C*    Implicit delimiter - no separator entered
     C*
     CSR   $SEG          ORGT      $XLEN                                        new segment g
     CSR   $IMODE        ANDEQ     ' '                                                      g
     CSR   $P            ANDLT     $XPART                                                   g
     C*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . --
     C*
     C*    Load value array if position and length nonzero
     C*
     CSR                 ADD       1             $P                             part number
     CSR   $LST          SUB       $BEG          $LEN                           part length
     CSR                 ADD       1             $LEN                           part length
     C*
     C*    Load @PV with value if position and length are valid
     C*
B3   CSR   $LEN          IFGT      *ZERO
     CSR   $BEG          ANDGT     *ZERO
     CSR   $LEN          SUBST     DSSUB:$BEG    @PV($P)                81      part value
     CSR                 Z-ADD     $LEN          @PL($P)                        part length
E3   CSR                 ENDIF
     C*
     C*    Reset position and length values
     C*
     C*    If no seperator entered, current position is beginning
     C*    of next segment
     C*
B3   CSR   $SEP          IFEQ      '0'
     CSR                 Z-ADD     #I            $BEG                           part begin
     CSR                 Z-ADD     1             $SEG                           seg length
     C*
     C*    If seperator entered, next position is beginning
     C*    of next segment
     C*
X3   CSR                 ELSE
     CSR   #I            ADD       1             $BEG                           part begin
     CSR                 Z-ADD     *ZERO         $SEG                           seg length
E3   CSR                 ENDIF
     C*
     CSR                 Z-ADD     *ZERO         $LEN                           part length
     CSR                 Z-ADD     *ZERO         $LST                           part end
     CSR                 ADD       1             #X
B3   CSR   #X            IFLE      $XPART
     CSR   #X            OCCUR     DSFLEX
E3   CSR                 ENDIF
     C*
X2   CSR                 ELSE
     C*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . --
     C*
     C*    Determine last nonblank character in subsid
     C*
B3   CSR   $WRK1         IFNE      *BLANKS
     CSR   $LST          OREQ      *ZERO
     CSR                 Z-ADD     #I            $LST
E3   CSR                 ENDIF
E2   CSR                 ENDIF
     C*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . --
     C*
     C*    Determine last nonblank character in subsid
     C*
B3   CSR   $WRK1         IFNE      *BLANKS
     CSR                 ADD       1             $SUBL                          Subl. Length
E3   CSR                 ENDIF
     C*
     C*    Increment index
     C*
     CSR                 ADD       1             #I
     CSR                 ADD       1             $SEG
     C*
E1   CSR                 ENDDO
     C*------------------------------------------------------------------
     C*
     C*    If last part is blank, disregard
     C*
B1   CSR   $P            IFGT      *ZERO
B2   CSR   @PV($P)       IFEQ      *BLANKS
     CSR                 Z-ADD     *ZERO         @PL($P)
     CSR                 SUB       1             $P
E2   CSR                 ENDIF
E1   CSR                 ENDIF
     C*----------------------------------------------------------------
     CSR   E003B         ENDSR
     C**************************************************************************
     C**************************************************************************
     C*
     C*     SUBROUTINE S0031 - Process database mode subsidiary parts
     C*     ---------------------------------------------------------
     C*
     C*  Input
     C*       @PV      = subsidiary part values
     C*       @PL      = subsidiary part lengths
     C*       $P       = Number of subsidiary parts
     C*
     C*  Output
     C*       DSS      = subsidiary string without delimiters
     C*
     CSR   S0031         BEGSR
     C*          -----     -----
     C*------------------------------------------------------------------
     C*
     C*    Check for too many subsidiary parts
     C*
B1   CSR   $P            IFGT      1
     CSR                 MOVEL     '3274'        PSERR
     CSR                 GOTO      E0031
     C*                    ---- -----
E1   CSR                 ENDIF
     C*------------------------------------------------------------------
     C*
     C*    Check if subsidiary part is too large
     C*
B1   CSR   @PL(1)        IFGT      $MXSUB
     CSR                 MOVEL     '3274'        PSERR
     CSR                 GOTO      E0031
     C*                    ---- -----
E1   CSR                 ENDIF
     C*----------------------------------------------------------------
     C*
     C*    Build DSS from @PV
     C*
B1   CSR   @PV(1)        IFNE      *BLANKS
DBN  CSR                 MOVEL     @PV(1)        DSS
E1   CSR                 ENDIF
     C*
     CSR   E0031         ENDSR
     C**************************************************************************
     C*
     C*     SUBROUTINE S0032  - Process display mode
     C*     ----------------------------------------
     C*
     C*  Input
     C*       @PV      = subsidiary part values
     C*       @PL      = subsidiary part lengths
     C*       $P       = Number of subsidiary parts
     C*
     C*  Output
     C*       DSS      = subsidiary string without delimiters
     C*
     CSR   S0032         BEGSR
     C*          -----     -----
     C*
     C*------------------------------------------------------------------
     C*
     C*    Check for too many subsidiary parts
     C*
B1   CSR   $P            IFGT      $XPART
     CSR                 MOVEL     '3274'        PSERR
     CSR                 GOTO      E0032
     C*                    ---- -----
E1   CSR                 ENDIF
     C*------------------------------------------------------------------
     C*
     C*    Build DSS from @PV
     C*
     C*    Loop on each subsidiary part
     C*
     CSR                 Z-ADD     1             #I                             @PV index
B1   CSR   1             DO        $XPART        #X
     CSR   #X            OCCUR     DSFLEX
     C*
     C*    Check if subsidiary part too long
     C*
B2   CSR   $SUBL         IFGT      $XLEN
     CSR                 MOVEL     '2474'        PSERR
     CSR                 GOTO      E0032
     C*                    ---- -----
E2   CSR                 ENDIF
     C*
     CSR                 MOVE      *BLANKS       DSSUB
     C*
     C*    Scrub numeric value
     C*
B2   CSR   $XNUM         IFEQ      'N'
     CSR                 MOVEL     @PV(#I)       $PV
     CSR                 MOVEA     $PV           @NM
     CSR                 EXSR      C0012
     C*                    ---- -----
     CSR                 Z-ADD     #NUMR         $NBR29           29 0
     CSR                 MOVE      $NBR29        DSSUB
X2   CSR                 ELSE
     C*
     C*    Load character value
     C*
DBN  CSR                 MOVEL     @PV(#I)       DSSUB
E2   CSR                 ENDIF
     C*
     C*    Calculate position to begin moving from and to
     C*
B2   CSR   $XNUM         IFEQ      'N'
     CSR   $@AN          SUB       $XLEN         $F                5 0
     CSR                 ADD       1             $F
     CSR                 Z-ADD     $XBEG         $BEG
X2   CSR                 ELSE
B3   CSR   $XLR          IFEQ      'R'
     CSR                 Z-ADD     1             $F
     CSR   $XLEN         SUB       @PL(#I)       $BEG
     CSR                 ADD       $XBEG         $BEG
X3   CSR                 ELSE
     CSR                 Z-ADD     1             $F
     CSR                 Z-ADD     $XBEG         $BEG
E3   CSR                 ENDIF
E2   CSR                 ENDIF
     C*
     C*    Move subsidiary part to DSS
     C*
B2   CSR   $BEG          DO        $XEND         #Z
     CSR                 MOVE      @AN($F)       @A(#Z)
     CSR                 ADD       1             $F
E2   CSR                 ENDDO
     C*
     CSR                 ADD       1             #I
E1   CSR                 ENDDO
     C*----------------------------------------------------------------
     C*
     CSR   E0032         ENDSR
     C**************************************************************************
     C**************************************************************************
     C*
     C*     SUBROUTINE S005  - Create output subsidiary
     C*     -------------------------------------------
     C*
     C*      Input parms:
     C*          DSS     = subsidiary data structure
     C*          DSSUB   = subsidiary string
     C*          $OMODE  = output mode work field
     C*          $IMODE  = input mode work field
     C*      Output parms:
     C*          P$SUB   = input subsidiary
     C*
     CSR   S005          BEGSR
     C*          ----      -----
     C*
     CSR                 CLEAR                   DSSUB
     CSR                 CLEAR                   P$SUB
     C*----------------------------------------------------------------
     C*
     C*    Create output subsidiary from input subsidiary
     C*
     C*      Input parms:
     C*          DSS     = subsidiary data structure
     C*          $OMODE  = output mode work field
     C*          $IMODE  = input mode work field
     C*      Output parms:
     C*          DSSUB   = subsidiary string
     C*          P$SUB   = input subsidiary
     C*
B1   CSR   $OMODE        CASEQ     '1'           S0051
     C*                    -----          -----
     CSR   $OMODE        CASEQ     ' '           S0052
     C*                    -----          -----
E1   CSR                 ENDCS
     C*----------------------------------------------------------------
     C*
     CSR   E005          ENDSR
     C*****************************************************************
     C**************************************************************************
     C*
     C*     SUBROUTINE S0051 - Create long subsidiary
     C*     ---------------------------------------------------------
     C*
     C*  Input
     C*       DSS      = subsidiary string without delimiters
     C*       DSSUB    = subsidiary string
     C*
     C*  Output
     C*       P$SUB    = subsid
     C*
     CSR   S0051         BEGSR
     C*          -----     -----
     C*
     C*----------------------------------------------------------------
     C*
     C*    Create output from input
     C*
     CSR                 MOVEL     $SUB          P$SUB
     C*
DBN  CSR                 MOVE      P$SUB         DSSUB
     C*----------------------------------------------------------------
     CSR   E0051         ENDSR
     C**************************************************************************
     C**************************************************************************
     C*
     C*     SUBROUTINE S0052  - Create display subsid with delimiters
     C*     ---------------------------------------------------------
     C*
     C*  Input
     C*       DSS      = subsidiary string without delimiters
     C*       DSSUB    = subsidiary string
     C*
     C*  Output
     C*       $SUB   = subsidiary string with delimiters
     C*
     C*
     CSR   S0052         BEGSR
     C*          -----     -----
     C*
     C*----------------------------------------------------------------
     C*
     C*    Determine delimiter
     C*
     CSR                 MOVEL     '.'           $DEL              1
B1   CSR   GCSEP         IFNE      *BLANK
     CSR                 MOVEL     GCSEP         $DEL
E1   CSR                 ENDIF
     C*
     C*    Load output
     C*
     CSR                 Z-ADD     1             #I                             output array
     C*
     C*    Process each subsidiary part
     C*
B1   CSR   1             DO        $XPART        #X
     CSR   #X            OCCUR     DSFLEX
     C*
     C*    Load subsidiary part
     C*
B2   CSR   $XBEG         DO        $XEND         #O
     CSR                 MOVE      @A(#O)        @AN(#I)
     CSR                 ADD       1             #I
E2   CSR                 ENDDO
     C*
     C*    Insert delimiter if there is more to come
     C*
B2   CSR   #X            IFLT      $XPART
     CSR   $XEND         ADD       1             #O
     CSR   $@A           SUB       $XEND         #M
B3   CSR   #O            IFLE      $@A
     CSR   #M            ANDGT     *ZERO
     CSR   #M            SUBST     DSS:#O        $WRK30           30
B4   CSR   $WRK30        IFNE      *BLANKS
     CSR                 MOVEL     $DEL          @AN(#I)
     CSR                 ADD       1             #I
E4   CSR                 ENDIF
E3   CSR                 ENDIF
E2   CSR                 ENDIF
     C*
E1   CSR                 ENDDO
     C*----------------------------------------------------------------
     C*
     CSR   E0052         ENDSR
     C**************************************************************************
     C*****************************************************************
     C*
     C*    Copy Common Subroutine - Scrub numeric value
     C*
     C*/COPY JDECPY,C0012
     C**************************************************************
     C*  This is part of a composite common subroutine. In
     C*  order for the subroutine to work correctly, the
     C*  RPG program must /COPY in the following members:
     C*   E0012, C0012
     C**************************************************************************
€    C*    REVISION LOG
€    C*    ------------
€    C*
€    C*          Date     Programmer     Nature of Revision
€    C*        --------   ----------  ------------------------------------
€    C*        12/11/97   BECK        SAR# 1810110
€    C*
     C**************************************************************************
     C*    MAINLINE PROGRAM
     C*    ----------------
     C*
     C*
     C*     SUBROUTINE C0012 - Right Justify Numeric Fields
     C*     -----------------------------------------------
     C*
     C*  PURPOSE
     C*  -------
     C*       To provide a subroutine common to all programs which
     C*       right justifies numeric fields and places the sign over
     C*       the low order byte of the fields, designated by either a
     C*       leading or trailing minus sign.  This routine also ignores
     C*       all non-numeric characters in the input field, and
     C*       determines the placement of the decimal point.
     C*
     C*  REMARKS
     C*  -------
     C*
     C*       Prior to executing this subroutine data from an
     C*       alphanumeric input field should be placed in the array
     C*       named '@NM' with a 'MOVEA' command.  The right justified
     C*       number is available from the subroutine field named
     C*       '#NUMR', which is a 15 digit 6 decimal field.
     C*       CAUTION: The largest number that can be handled
     C*       by this subroutine is 999,999,999.999999.
     C*       However, the input field may contain only 15
     C*       numbers.
     C*
     CSR   C0012         BEGSR
     C*          -----     -----
     C*
     CSR                 Z-ADD     0             #NUMR            29 9
     CSR                 Z-ADD     0             #NUMR2           15 2          Compile only
     CSR                 Z-ADD     0             #NUMR9           15 9          Compile only
     C*
     CSR                 MOVEA     @NM           #ALNUM           22
     CSR   #ALNUM        CABEQ     *BLANKS       EN0012
     CSR                 SETOFF                                       818384
     CSR                 MOVEA     *ALL'0'       @N2
     CSR                 Z-ADD     0             #K1               3 0
     CSR                 Z-ADD     0             #K2               3 0
     CSR                 Z-ADD     0             Q#                3 0
     CSR                 Z-ADD     0             J#                3 0
     CSR                 Z-ADD     0             M#                3 0
     C*
     C*    Retrieve date separation and decimal format characters.
     C*
     CSR   ###1          IFEQ      ' '                                          Do once
     CSR                 MOVE      '1'           ###1              1
     CSR                 CALL      'X00SFMT '                           81
     C*                    ---- ----------
     CSR                 PARM      '/'           ###DS             1
     CSR                 PARM      ' '           ###DF             1
     CSR                 MOVE      '.'           ###DC             1
     CSR   ###DF         IFEQ      'J'
     CSR   ###DF         OREQ      'I'
     CSR                 MOVE      ','           ###DC
     CSR                 END
     CSR                 MOVE      ' '           ###EQ             1
     CSR   ###DS         IFEQ      ###DC
     CSR                 MOVE      '1'           ###EQ
     CSR                 END
     CSR                 END
     C*
     C*    If date separator character equals decimal format character,
     C*    Test for multiple decimal point characters and replace with
     C*    US standard date separator character(/).
     C*
     CSR   ###EQ         IFEQ      '1'
     C*
     CSR                 Z-ADD     0             Q#
     CSR                 DO        22            M#
     CSR   @NM(M#)       IFEQ      ###DC
     CSR                 ADD       001           Q#
     CSR                 END
     CSR                 END
     C*
     CSR   Q#            IFGT      1
     CSR                 DO        22            M#
     CSR   @NM(M#)       IFEQ      ###DC
     CSR                 MOVE      '/'           @NM(M#)
     CSR                 END
     CSR                 END
     CSR                 END
     C*
     CSR                 MOVEA     @NM           #ALNUM
     CSR                 END
     C*
     C*    Initialize beginning and ending scan positions.
     C*
     CSR                 Z-ADD     +1            #LOW              3 0
     CSR                 Z-ADD     +22           #HIGH             3 0
     C*
     C*    Find first non-blank character.
     C*
     CSR   ' '           CHECK     #ALNUM        #LOW
     C*
     C*    Find last non-blank character.
     C*
     CSR   ' '           CHECKR    #ALNUM        #HIGH
     C*
     C*    Test minus sign.
     C*    String may be surrounded by quotes... ( dftval from DD )
     C*
     C* &&&      '-'       SCAN #ALNUM                   83
     CSR                 Z-ADD     #LOW          M#
     CSR   @NM(M#)       IFEQ      ''''
     CSR                 ADD       +1            M#
     CSR                 ENDIF
     C*
     CSR   @NM(M#)       COMP      '-'                                    83
     C*
     CSR   *IN83         IFEQ      '0'
     CSR                 Z-ADD     #HIGH         M#
     CSR   @NM(M#)       IFEQ      ''''
     CSR   M#            ANDGT     +1
     CSR                 SUB       1             M#
     CSR                 ENDIF
     C*
     CSR   @NM(M#)       COMP      '-'                                    83
     CSR                 ENDIF
     C*
     C*    Scrub numeric value.
     C*
     CSR                 Z-ADD     #HIGH         M#
     CSR                 Z-ADD     22            Q#
     CSR                 SUB       1             #LOW
     CSR   M#            DOWGT     #LOW
     CSR                 MOVE      @NM(M#)       @NMM#             1
     CSR   @NMM#         IFNE      *BLANKS
     CSR   @NMM#         IFGE      '0'
     CSR   @NMM#         ANDLE     '9'
     CSR   *IN84         IFEQ      '0'
     CSR                 ADD       001           #K1
     CSR                 END
     CSR                 MOVE      @NMM#         @N2(Q#)
     CSR                 SUB       01            Q#
     CSR                 END
     C*
     C*    If decimal point not already found, test for decimal.
     C*
     CSR   *IN84         IFEQ      '0'
     CSR   @NMM#         COMP      ###DC                                  84
     CSR                 END
     C*
     CSR                 END
     CSR                 SUB       001           M#
     CSR                 END
     C*
     C*    Move whole scrubbed number to work field.
     C*
     CSR                 MOVEA     @N2           #ALNUM
     CSR                 MOVE      #ALNUM        #WK29            29 0
     CSR                 Z-ADD     1             #MULTX           11 9
     CSR                 Z-ADD     1             #MULTY           11 9
     C*
     C*    Set up divisor for decimal positions.
     C*
     CSR   *IN84         IFEQ      '1'                                          DECIMAL FND
     CSR   #K1           IFGT      9
     CSR   #K1           SUB       9             #K2
     CSR                 DO        #K2
     CSR                 MULT      .1            #MULTY
     CSR                 END
     CSR                 Z-ADD     9             #K1
     CSR                 END
     CSR                 DO        #K1
     CSR                 MULT      .1            #MULTX
     CSR                 END
     CSR                 ELSE
     CSR                 Z-ADD     0             #K1
     CSR                 Z-ADD     0             #K2
     CSR                 END
     C*
     C*    If negative number, reverse sign on result.
     C*
     CSR   *IN83         IFEQ      '1'
     CSR                 MULT      -1            #WK29
     CSR                 END
     C*
     C*    Position decimal point in result.
     C*
     CSR   #WK29         MULT      #MULTX        #NUMR            29 9
     CSR   #K2           IFGT      0
     CSR                 MULT      #MULTY        #NUMR
     CSR                 END
     C*
     C*    Test for truncation of high value digits.
     C*
     CSR   6             SUB       #K1           M#
     CSR                 ADD       7             M#
     CSR                 Z-ADD     1             Q#
     CSR                 MOVE      ' '           #HV#              1
     CSR   Q#            DOWLE     M#
     CSR   @N2(Q#)       IFGT      '0'
     CSR                 MOVE      '1'           #HV#
     CSR                 Z-ADD     M#            Q#
     CSR                 END
     CSR                 ADD       01            Q#
     CSR                 END
     CSR   #HV#          IFEQ      '1'
     CSR   #WK29         MULT(H)   #MULTX        #NUMR2
     CSR   #K2           IFGT      0
     CSR                 MULT(H)   #MULTY        #NUMR2
     CSR                 END
     CSR                 END
     C*
     C*    Test for truncation of low value digits.
     C*
     CSR                 Z-ADD     0             $NBR3             3 0
     CSR   #K1           IFGT      6
     CSR                 Z-ADD     0             $NBR3
     CSR                 MOVE      #WK29         $NBR1             1 0
     CSR                 MOVE      $NBR1         $NBR3
     CSR                 END
     CSR   #K1           IFGT      7
     CSR                 Z-ADD     0             $NBR3
     CSR                 MOVE      #WK29         $NBR2             2 0
     CSR                 Z-ADD     $NBR2         $NBR3
     CSR                 END
     CSR   #K1           IFGT      8
     CSR                 MOVE      #WK29         $NBR3             3 0
     CSR                 END
     CSR   $NBR3         IFNE      0
     CSR   #WK29         MULT      #MULTX        #NUMR9
     CSR   #K2           IFGT      0
     CSR                 MULT      #MULTY        #NUMR9
     CSR                 END
     CSR                 END
     C*
     CSR                 MOVEA     *BLANK        @NM
     C*
     CSR   EN0012        ENDSR
     C*****************************************************************
     C****************************************************************
     C*
     C*    SUBROUTINE S999   - Initial subroutine
     C*    --------------------------------------
     C*
     C*    Processing:
     C*                 1.  Initialize output parameters.
     C*                 2.  Validate input parameters.
     C*                 3.  Initialize variables.
     C*
     CSR   S999          BEGSR
     C*          ----      -----
     C*-----------------------------------------------------------------
     C*
     C*    Entry parameters...
     C*
     CSR   *ENTRY        PLIST
     C*
     C*    1.  Output mode of entry
     C*
     CSR                 PARM                    PSOMOD            1            output mode
     C*
     C*    2.  Input mode of entry
     C*
     CSR                 PARM                    PSIMOD            1            input mode
     C*
     C*    3.  subsid
     C*
     CSR                 PARM                    PSSUB             8            subsidiary
     C*
     C*    4.  Error flag
     C*
     CSR                 PARM                    PSERR             4            error flag
     C*
     C*-----------------------------------------------------------------
     C*
     C*    Initialize output parameters
     C*
     CSR                 MOVE      *BLANKS       P$SUB
     C*
     CSR                 MOVE      *BLANKS       PSERR                          error flag
     CSR                 MOVE      PSSUB         P$SUB
     C*
     C*-----------------------------------------------------------------
     C*
     C*    Validate parameters
     C*
     C*    Output mode
     C*
B1   CSR   PSOMOD        IFNE      ' '
     CSR   PSOMOD        ANDNE     '1'
     CSR                 MOVEL     '3088'        PSERR
E1   CSR                 ENDIF
     C*
     C*    Input mode
     C*
B1   CSR   PSIMOD        IFNE      ' '
     CSR   PSIMOD        ANDNE     '1'
     CSR                 MOVEL     '3089'        PSERR
E1   CSR                 ENDIF
     C*-----------------------------------------------------------------
     C*
     CSR   E999          ENDSR
     C*****************************************************************
     C*****************************************************************
     C*
     C*    SUBROUTINE S999KL - Key list definitions
     C*    ----------------------------------------
     C*
     CSR   S999KL        BEGSR
     C*
     C*    Flex key list
     C*
     CSR   GYKY01        KLIST
     CSR                 KFLD                    GYRETY
     CSR                 KFLD                    GYSBTY
     C*
     CSR   E999KL        ENDSR
     C*****************************************************************
     C*****************************************************************
     C*
     C*    SUBROUTINE S999LK - *LIKE definitions
     C*    -------------------------------------
     C*
     CSR   S999LK        BEGSR
     C*
     C*    Work fields
     C*
     CSR   *LIKE         DEFINE    PSSUB         P$SUB
     CSR   *LIKE         DEFINE    @PV           $PV
     CSR   *LIKE         DEFINE    $LST          $SUBL
     C*
     C*    Save fields for input parameters
     C*
     CSR   *LIKE         DEFINE    PSIMOD        $IMODE
     CSR   *LIKE         DEFINE    PSOMOD        $OMODE
     C*
     C*
     CSR   E999LK        ENDSR
     C*****************************************************************
     C*****************************************************************
     C*
     C*    SUBROUTINE *INZSR - Initial subroutine - first time only
     C*    --------------------------------------------------------
     C*
     C*    Processing:
     C*                 1.  Open database files
     C*
     CSR   *INZSR        BEGSR
     C*          ------    -----
     C*
     C*    Retrieve General Constants record
     C*
     C*      Returns the following values:
     C*        GCSEP  = account separator character
     C*                 (default allows either '.' or ',')
     C*
     CSR                 OPEN      F0009
     C*
     CSR   *BLANKS       CHAIN     I0009                              81
     C*
     C*    Close file
     C*
     CSR                 CLOSE     F0009
     C*-----------------------------------------------------------------
     C*    Determine if flex is on.
     C*
     C*    Note:
     C*      GCFLEX is the Flex flag in the F0009 file.  P0907 has
     C*      been modified to load this field as needed.  Determining
     C*      Flex will no longer require a call to the X0907 server.
     C*
B1   CSR   GCFLEX        IFEQ      'Y'
     C*
     CSR                 OPEN      F0907                                81
     C*
     CSR                 CLEAR                   DSFLEX
     C*
     C*    Initialize flex subsidiary parts
     C*
     CSR                 Z-ADD     *ZERO         $XPART            5 0          part number
     CSR                 Z-ADD     1             #X                             begin position
     C*
     C*    Load subsid parts array for flex subsidiary
     C*    Subtype 3 = subsidiary part
     C*
     CSR                 Z-ADD     1             GYRETY
     CSR                 Z-ADD     3             GYSBTY
     CSR   GYKY01        SETLL     I0907
B2   CSR   *IN81         DOUEQ     '1'
     CSR   GYKY01        READE     I0907                                  81
B3   CSR   *IN81         IFEQ      '0'
     C*
     C*
     C*    Load subsidiary part
     C*
     CSR                 ADD       1             $XPART                         part number
     CSR   $XPART        OCCUR     DSFLEX
     C*
     C*    Positions and length
     C*
     CSR                 Z-ADD     #X            $XBEG                          begin position
     CSR                 Z-ADD     GYELL         $XLEN                          length
     CSR                 ADD       $XLEN         #X                             next position
     CSR   #X            SUB       1             $XEND                          end position
     C*
     C*    Attributes
     C*
     CSR                 MOVE      GYELTY        $XNUM                          numeric (A/N)
     CSR                 MOVE      GYLR          $XLR                           justify L/R
     C*
E3   CSR                 ENDIF
E2   CSR                 ENDDO
     C*----------------------------------------------------------------
     C*
     C*    Close Flex Chart file
     C*
     CSR                 CLOSE     F0907
     C*
     C*----------------------------------------------------------------
E1   CSR                 ENDIF
     C*
     CSR   EINZSR        ENDSR
     C*****************************************************************
