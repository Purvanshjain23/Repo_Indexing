// ?------------------------------------------------------------------------------------------------
// ?Synon action diagram for PDOJXFR
// ?Date: 14.08.2025 Time: 03:29:07
// ?------------------------------------------------------------------------------------------------

//?Execute user function

//?Retrive Pricing Method Type
EXECUTE FUNCTION(RTV Price Meth Type    RT) TYPE(RTVOBJ) FILE(PDIHREP)          AC1268519;
PARAMETER(PAR.Company_Number);
PARAMETER(PAR.Price_Method_Code);
PARAMETER(PAR.Price_Method_Type);
{
 //?USER: Processing if Data record not found

 MOVE *ALL (To: PAR From: CON);

 //?USER: Process Data record

 MOVE *ALL (To: PAR From: DB1);

}


//?Retrieve Item Information
EXECUTE FUNCTION(RTV Item Conv. Factr   RT) TYPE(RTVOBJ) FILE(CABZREP)          AC1296333;
PARAMETER(PAR.Company_Number);
PARAMETER(PAR.Item_Code);
PARAMETER(PAR.UOM_Primary);
PARAMETER(PAR.Conversion_Factor_1);
PARAMETER(PAR.Operation_Factor_1);
PARAMETER(PAR.UOM_Second);
PARAMETER(PAR.Conversion_Factor_2);
PARAMETER(PAR.Operation_Factor_2);
PARAMETER(PAR.UOM_Third);
PARAMETER(PAR.UOM_Pricing);
PARAMETER(PAR.Unit_Weight);
{
 //?USER: Process Data record

 MOVE *ALL (To: PAR From: DB1);

}


// WRK.U/M - Pricing = PAR.U/M - Pricing
WRK.UOM_Pricing = PAR.UOM_Pricing;

CASE;

// IF PAR.Event Called From is Invoice Update
IF PAR.Event_Called_From = '02';

//?Excecute Retrieve Object to calculate pricing from files
EXECUTE FUNCTION(CLC Pricing using File RT) TYPE(RTVOBJ) FILE(PDIMCPP)          AC1313384;
PARAMETER(PAR.Company_Number);
PARAMETER(PAR.Order_Number);
PARAMETER(PAR.Order_Sequence_Number);
PARAMETER(PAR.Order_Secondary_Line_Seq);
PARAMETER(PAR.Price_based_on_U_M1_S);
PARAMETER(PAR.Price_based_on_U_M2_S);
PARAMETER(PAR.Price_based_on_U_M3_S);
PARAMETER(PAR.U_M_Ordered);
PARAMETER(PAR.Unit_Price);
PARAMETER(PAR.Price_Method_Type);
PARAMETER(PAR.UOM_Pricing);
{
 //?USER: Initialize routine

 // PAR.Unit Price = CON.*ZERO
 PAR.Unit_Price = *ZERO;

 //?USER: Process Data record

 //?** If a change is made here or a routine is added here then a
 //?** similar routine must also be added to the CLC Pricing Using WORK RT
 //?** in this file and to the CLC Read/Proc. Detail
 //?** in the Price Method Detail file. These need to be kept in sync.
 //?*** 01 PROCESS COMPONANT MKTPRC IF SELECTED *
 CASE;

 // IF DB1.Price Method Componant is MKTPRC
 IF DB1.Price_Method_Componant = 'MKTPRC';

 // AND DB1.PD Status is Active
 AND DB1.PD_Status = 'A';

 //?Process Retrieve Market Pricing Componant
 DO;

 //?Pricing Retrieved Amount is not equal to 0
 CASE;

 // IF DB1.Componant Price NE WRK.ZERO
 IF DB1.Componant_Price <> WRK.ZERO;

 //?Accumulate Final Price
 // PAR.Unit Price = PAR.Unit Price + DB1.Componant Price
 PAR.Unit_Price = PAR.Unit_Price + DB1.Componant_Price;

 ENDIF;

 ENDDO;

 ENDIF;

 //?       04=Unused ( TCRDVY )
 //?*** 09 PROCESS COMPONANT CFRTOV IF SELECTED *
 CASE;

 // IF DB1.Price Method Componant is CFRTOV
 IF DB1.Price_Method_Componant = 'CFRTOV';

 // AND DB1.PD Status is Active
 AND DB1.PD_Status = 'A';

 //?Process Company/Customer freight Rate Overage Componant
 DO;

 //?Update Pricing Detail if Freight Overage is not equal to 0.
 CASE;

 // IF DB1.Componant Price NE WRK.ZERO
 IF DB1.Componant_Price <> WRK.ZERO;

 //?Accumulate Final Price
 // PAR.Unit Price = PAR.Unit Price + DB1.Componant Price
 PAR.Unit_Price = PAR.Unit_Price + DB1.Componant_Price;

 ENDIF;

 ENDDO;

 ENDIF;

 //?*** 10 PROCESS COMPONANT CIOVMK IF SELECTED *
 CASE;

 // IF DB1.Price Method Componant is CIOVMK
 IF DB1.Price_Method_Componant = 'CIOVMK';

 // AND DB1.PD Status is Active
 AND DB1.PD_Status = 'A';

 //?Process Item Market Overage Componant
 DO;

 //?Update Pricing Detail if Market  Overage is not equal to 0.
 CASE;

 // IF DB1.Componant Price NE WRK.ZERO
 IF DB1.Componant_Price <> WRK.ZERO;

 //?Accumulate Final Price
 // PAR.Unit Price = PAR.Unit Price + DB1.Componant Price
 PAR.Unit_Price = PAR.Unit_Price + DB1.Componant_Price;

 ENDIF;

 ENDDO;

 ENDIF;

 //?*** 11 PROCESS COMPONANT IOVMKT IF SELECTED *
 CASE;

 // IF DB1.Price Method Componant is IOVMKT
 IF DB1.Price_Method_Componant = 'IOVMKT';

 // AND DB1.PD Status is Active
 AND DB1.PD_Status = 'A';

 //?Process Item Market Overage Componant
 DO;

 //?Update Pricing Detail if Market Overage is not equal to 0.
 CASE;

 // IF DB1.Componant Price NE WRK.ZERO
 IF DB1.Componant_Price <> WRK.ZERO;

 //?Accumulate Final Price
 // PAR.Unit Price = PAR.Unit Price + DB1.Componant Price
 PAR.Unit_Price = PAR.Unit_Price + DB1.Componant_Price;

 ENDIF;

 ENDDO;

 ENDIF;

 //?*** 12 PROCESS COMPONANT EXTEND IF SELECTED *
 CASE;

 // IF DB1.Price Method Componant is EXTEND
 IF DB1.Price_Method_Componant = 'EXTEND';

 // AND DB1.PD Status is Active
 AND DB1.PD_Status = 'A';

 //?Process Extended Price Method Componant
 DO;

 //?Pricing Detail if Extended is not equal to 0.
 CASE;

 // IF DB1.Componant Price NE WRK.ZERO
 IF DB1.Componant_Price <> WRK.ZERO;

 //?Accumulate Final Price
 // PAR.Unit Price = PAR.Unit Price + DB1.Componant Price
 PAR.Unit_Price = PAR.Unit_Price + DB1.Componant_Price;

 // PAR.U/M - Pricing = PAR.U/M - Ordered
 PAR.UOM_Pricing = PAR.U_M_Ordered;

 ENDIF;

 ENDDO;

 ENDIF;

 //?*** 13 PROCESS COMPONANT OVRIDE IF SELECTED *
 CASE;

 // IF DB1.Price Method Componant is OVRIDE
 IF DB1.Price_Method_Componant = 'OVRIDE';

 // AND DB1.PD Status is Active
 AND DB1.PD_Status = 'A';

 //?Process Manual Pricing Componant
 DO;

 //?Pricing Detail if Override Amt is not equal to 0.
 CASE;

 // IF DB1.Componant Price NE WRK.ZERO
 IF DB1.Componant_Price <> WRK.ZERO;

 //?Accumulate Final Price
 // PAR.Unit Price = PAR.Unit Price + DB1.Componant Price
 PAR.Unit_Price = PAR.Unit_Price + DB1.Componant_Price;

 ENDIF;

 ENDDO;

 ENDIF;

 //?*** 14 Process Component ACCRLS if selected *
 CASE;

 // IF DB1.Price Method Componant is ACCRLS
 IF DB1.Price_Method_Componant = 'ACCRLS';

 // AND DB1.PD Status is Active
 AND DB1.PD_Status = 'A';

 //?** Process Retrieve Market Pricing Componant
 //?Pricing Retrieved Amount is not equal to 0
 CASE;

 // IF DB1.Componant Price NE WRK.ZERO
 IF DB1.Componant_Price <> WRK.ZERO;

 //?Accumulate Final Price
 // PAR.Unit Price = PAR.Unit Price + DB1.Componant Price
 PAR.Unit_Price = PAR.Unit_Price + DB1.Componant_Price;

 ENDIF;

 ENDIF;

 //?*** 15 PROCESS COMPONANT CFRTAB IF SELECTED *
 CASE;

 // IF DB1.Price Method Componant is CFRTAB
 IF DB1.Price_Method_Componant = 'CFRTAB';

 // AND DB1.PD Status is Active
 AND DB1.PD_Status = 'A';

 //?Process Company/Customer freight Rate Overage Componant
 DO;

 //?Update Pricing Detail if Freight Absorbed is not equal to 0.
 CASE;

 // IF DB1.Componant Price NE WRK.ZERO
 IF DB1.Componant_Price <> WRK.ZERO;

 //?Accumulate Final Price
 // PAR.Unit Price = PAR.Unit Price + DB1.Componant Price
 PAR.Unit_Price = PAR.Unit_Price + DB1.Componant_Price;

 ENDIF;

 ENDDO;

 ENDIF;

 //?*** 16 PROCESS COMPONANT IOVFRT IF SELECTED *
 CASE;

 // IF DB1.Price Method Componant is IOVFRT
 IF DB1.Price_Method_Componant = 'IOVFRT';

 // AND DB1.PD Status is Active
 AND DB1.PD_Status = 'A';

 //?Process Item Market Overage Componant
 DO;

 //?Update Pricing Detail if Market Overage is not equal to 0.
 CASE;

 // IF DB1.Componant Price NE WRK.ZERO
 IF DB1.Componant_Price <> WRK.ZERO;

 //?Accumulate Final Price
 // PAR.Unit Price = PAR.Unit Price + DB1.Componant Price
 PAR.Unit_Price = PAR.Unit_Price + DB1.Componant_Price;

 ENDIF;

 ENDDO;

 ENDIF;

 //?P205--New Components
 //?*** 17 PROCESS COMPONANT CIMSLV IF SELECTED *
 CASE;

 // IF DB1.Price Method Componant is CIMSLV
 IF DB1.Price_Method_Componant = 'CIMSLV';

 // AND DB1.PD Status is Active
 AND DB1.PD_Status = 'A';

 //?Process Item Market Overage Componant
 DO;

 //?Update Pricing Detail if Market Overage is not equal to 0.
 CASE;

 // IF DB1.Componant Price NE WRK.ZERO
 IF DB1.Componant_Price <> WRK.ZERO;

 //?Accumulate Final Price
 // PAR.Unit Price = PAR.Unit Price + DB1.Componant Price
 PAR.Unit_Price = PAR.Unit_Price + DB1.Componant_Price;

 ENDIF;

 ENDDO;

 ENDIF;

 //?*** 18 PROCESS COMPONANT CIPFEE IF SELECTED *
 CASE;

 // IF DB1.Price Method Componant is CIPFEE
 IF DB1.Price_Method_Componant = 'CIPFEE';

 // AND DB1.PD Status is Active
 AND DB1.PD_Status = 'A';

 //?Process Item Market Overage Componant
 DO;

 //?Update Pricing Detail if Market Overage is not equal to 0.
 CASE;

 // IF DB1.Componant Price NE WRK.ZERO
 IF DB1.Componant_Price <> WRK.ZERO;

 //?Accumulate Final Price
 // PAR.Unit Price = PAR.Unit Price + DB1.Componant Price
 PAR.Unit_Price = PAR.Unit_Price + DB1.Componant_Price;

 ENDIF;

 ENDDO;

 ENDIF;

 //?*** 19 PROCESS COMPONANT CIFRTO IF SELECTED *
 CASE;

 // IF DB1.Price Method Componant is CIFRTO
 IF DB1.Price_Method_Componant = 'CIFRTO';

 // AND DB1.PD Status is Active
 AND DB1.PD_Status = 'A';

 //?Process Item Market Overage Componant
 DO;

 //?Update Pricing Detail if Market Overage is not equal to 0.
 CASE;

 // IF DB1.Componant Price NE WRK.ZERO
 IF DB1.Componant_Price <> WRK.ZERO;

 //?Accumulate Final Price
 // PAR.Unit Price = PAR.Unit Price + DB1.Componant Price
 PAR.Unit_Price = PAR.Unit_Price + DB1.Componant_Price;

 ENDIF;

 ENDDO;

 ENDIF;

 //?*** 20 PROCESS COMPONANT CITMOV IF SELECTED *
 CASE;

 // IF DB1.Price Method Componant is CITMOV
 IF DB1.Price_Method_Componant = 'CITMOV';

 // AND DB1.PD Status is Active
 AND DB1.PD_Status = 'A';

 //?Process Item Market Overage Componant
 DO;

 //?Update Pricing Detail if Market Overage is not equal to 0.
 CASE;

 // IF DB1.Componant Price NE WRK.ZERO
 IF DB1.Componant_Price <> WRK.ZERO;

 //?Accumulate Final Price
 // PAR.Unit Price = PAR.Unit Price + DB1.Componant Price
 PAR.Unit_Price = PAR.Unit_Price + DB1.Componant_Price;

 ENDIF;

 ENDDO;

 ENDIF;

 //?*** 21 PROCESS COMPONANT CSFRTO IF SELECTED *
 CASE;

 // IF DB1.Price Method Componant is CSFRTO
 IF DB1.Price_Method_Componant = 'CSFRTO';

 // AND DB1.PD Status is Active
 AND DB1.PD_Status = 'A';

 //?Process Item Market Overage Componant
 DO;

 //?Update Pricing Detail if Market Overage is not equal to 0.
 CASE;

 // IF DB1.Componant Price NE WRK.ZERO
 IF DB1.Componant_Price <> WRK.ZERO;

 //?Accumulate Final Price
 // PAR.Unit Price = PAR.Unit Price + DB1.Componant Price
 PAR.Unit_Price = PAR.Unit_Price + DB1.Componant_Price;

 ENDIF;

 ENDDO;

 ENDIF;

 //?*** 22 PROCESS COMPONANT PSITPR IF SELECTED *
 CASE;

 // IF DB1.Price Method Componant is PSITPR
 IF DB1.Price_Method_Componant = 'PSITPR';

 // AND DB1.PD Status is Active
 AND DB1.PD_Status = 'A';

 //?Process Item Market Overage Componant
 DO;

 //?Update Pricing Detail if Market Overage is not equal to 0.
 CASE;

 // IF DB1.Componant Price NE WRK.ZERO
 IF DB1.Componant_Price <> WRK.ZERO;

 //?Accumulate Final Price
 // PAR.Unit Price = PAR.Unit Price + DB1.Componant Price
 PAR.Unit_Price = PAR.Unit_Price + DB1.Componant_Price;

 ENDIF;

 ENDDO;

 ENDIF;

 //?*** 23 PROCESS COMPONANT PSMKTO IF SELECTED *
 CASE;

 // IF DB1.Price Method Componant is PSMKTO
 IF DB1.Price_Method_Componant = 'ITMKTO';

 // AND DB1.PD Status is Active
 AND DB1.PD_Status = 'A';

 //?Process Item Market Overage Componant
 DO;

 //?Update Pricing Detail if Market Overage is not equal to 0.
 CASE;

 // IF DB1.Componant Price NE WRK.ZERO
 IF DB1.Componant_Price <> WRK.ZERO;

 //?Accumulate Final Price
 // PAR.Unit Price = PAR.Unit Price + DB1.Componant Price
 PAR.Unit_Price = PAR.Unit_Price + DB1.Componant_Price;

 ENDIF;

 ENDDO;

 ENDIF;

 //?*** 24 PROCESS COMPONANT MKTOVR IF SELECTED *
 CASE;

 // IF DB1.Price Method Componant is MKTOVR
 IF DB1.Price_Method_Componant = 'MKTOVR';

 // AND DB1.PD Status is Active
 AND DB1.PD_Status = 'A';

 //?Process Item Market Overage Componant
 DO;

 //?Update Pricing Detail if Market Overage is not equal to 0.
 CASE;

 // IF DB1.Componant Price NE WRK.ZERO
 IF DB1.Componant_Price <> WRK.ZERO;

 //?Accumulate Final Price
 // PAR.Unit Price = PAR.Unit Price + DB1.Componant Price
 PAR.Unit_Price = PAR.Unit_Price + DB1.Componant_Price;

 ENDIF;

 ENDDO;

 ENDIF;

 //?E2494-New Component for Gate price AND Flat Duty Priced items
 //?*** 25 PROCESS COMPONANT GATADJ IF SELECTED AND IS ACTIVE-*
 CASE;

 // IF DB1.Price Method Componant is GATADJ
 IF DB1.Price_Method_Componant = 'GATADJ';

 // AND DB1.PD Status is Active
 AND DB1.PD_Status = 'A';

 //?Process Gate Adjustment Componant
 DO;

 //?Update Pricing Detail if Gate adj is not equal to 0.
 CASE;

 // IF DB1.Componant Price NE WRK.ZERO
 IF DB1.Componant_Price <> WRK.ZERO;

 //?Accumulate Final Price
 // PAR.Unit Price = PAR.Unit Price + DB1.Componant Price
 PAR.Unit_Price = PAR.Unit_Price + DB1.Componant_Price;

 ENDIF;

 ENDDO;

 ENDIF;

 //?*** 26 PROCESS COMPONENT DVGADJ IF SELECTED AND IS ACTIVE-*
 CASE;

 // IF DB1.Price Method Componant is DVFADJ
 IF DB1.Price_Method_Componant = 'DVFADJ';

 // AND DB1.PD Status is Active
 AND DB1.PD_Status = 'A';

 //?Process Gate/Final Adjustment Componant
 DO;

 //?Update Pricing Detail if Gate adj is not equal to 0.
 CASE;

 // IF DB1.Componant Price NE WRK.ZERO
 IF DB1.Componant_Price <> WRK.ZERO;

 //?Accumulate Final Price
 // PAR.Unit Price = PAR.Unit Price + DB1.Componant Price
 PAR.Unit_Price = PAR.Unit_Price + DB1.Componant_Price;

 ENDIF;

 ENDDO;

 ENDIF;

}


// IF PAR.Event Called From is Pre-Update Invoice
IF PAR.Event_Called_From = **;

//?Excecute Retrieve Object to calculate pricing from files
EXECUTE FUNCTION(CLC Pricing Using WORK RT) TYPE(RTVOBJ) FILE(PDIMCPP)          AC1313713;
PARAMETER(PAR.Company_Number);
PARAMETER(PAR.Order_Number);
PARAMETER(PAR.Order_Sequence_Number);
PARAMETER(PAR.Order_Secondary_Line_Seq);
PARAMETER(PAR.Price_based_on_U_M1_S);
PARAMETER(PAR.Price_based_on_U_M2_S);
PARAMETER(PAR.Price_based_on_U_M3_S);
PARAMETER(PAR.U_M_Ordered);
PARAMETER(PAR.Unit_Price);
PARAMETER(PAR.Price_Method_Type);
PARAMETER(PAR.UOM_Pricing);
{
 //?USER: Initialize routine

 // PAR.Unit Price = CON.*ZERO
 PAR.Unit_Price = *ZERO;

 //?USER: Process Data record

 //?** If a change is made here or a routine is added here then a
 //?** similar routine must also be added to the CLC Pricing using File RT
 //?** in this file and to the CLC Read/Proc. Detail
 //?** in the Price Method Detail file. These need to be kept in sync.
 //?*** 01 PROCESS COMPONANT MKTPRC IF SELECTED *
 CASE;

 // IF DB1.Price Method Componant is MKTPRC
 IF DB1.Price_Method_Componant = 'MKTPRC';

 // AND DB1.PD Status is Active
 AND DB1.PD_Status = 'A';

 //?Process Retrieve Market Pricing Componant
 DO;

 //?Update Pricing Retrieved Amount is not equal to 0
 CASE;

 // IF DB1.Componant Price NE WRK.ZERO
 IF DB1.Componant_Price <> WRK.ZERO;

 //?Accumulate Final Price
 // PAR.Unit Price = PAR.Unit Price + DB1.Componant Price
 PAR.Unit_Price = PAR.Unit_Price + DB1.Componant_Price;

 ENDIF;

 ENDDO;

 ENDIF;

 //?       04=Unused ( TCRDVY )
 //?*** 09 PROCESS COMPONANT CFRTOV IF SELECTED *
 CASE;

 // IF DB1.Price Method Componant is CFRTOV
 IF DB1.Price_Method_Componant = 'CFRTOV';

 // AND DB1.PD Status is Active
 AND DB1.PD_Status = 'A';

 //?Process Company/Customer freight Rate Overage Componant
 DO;

 //?Update Pricing Detail if Freight Overage is not equal to 0.
 CASE;

 // IF DB1.Componant Price NE WRK.ZERO
 IF DB1.Componant_Price <> WRK.ZERO;

 //?Accumulate Final Price
 // PAR.Unit Price = PAR.Unit Price + DB1.Componant Price
 PAR.Unit_Price = PAR.Unit_Price + DB1.Componant_Price;

 ENDIF;

 ENDDO;

 ENDIF;

 //?*** 10 PROCESS COMPONANT CIOVMK IF SELECTED *
 CASE;

 // IF DB1.Price Method Componant is CIOVMK
 IF DB1.Price_Method_Componant = 'CIOVMK';

 // AND DB1.PD Status is Active
 AND DB1.PD_Status = 'A';

 //?Process Item Market Overage Componant
 DO;

 //?Update Pricing Detail if Market  Overage is not equal to 0.
 CASE;

 // IF DB1.Componant Price NE WRK.ZERO
 IF DB1.Componant_Price <> WRK.ZERO;

 //?Accumulate Final Price
 // PAR.Unit Price = PAR.Unit Price + DB1.Componant Price
 PAR.Unit_Price = PAR.Unit_Price + DB1.Componant_Price;

 ENDIF;

 ENDDO;

 ENDIF;

 //?*** 11 PROCESS COMPONANT IOVMKT IF SELECTED *
 CASE;

 // IF DB1.Price Method Componant is IOVMKT
 IF DB1.Price_Method_Componant = 'IOVMKT';

 // AND DB1.PD Status is Active
 AND DB1.PD_Status = 'A';

 //?Process Item Market Overage Componant
 DO;

 //?Update Pricing Detail if Market Overage is not equal to 0.
 CASE;

 // IF DB1.Componant Price NE WRK.ZERO
 IF DB1.Componant_Price <> WRK.ZERO;

 //?Accumulate Final Price
 // PAR.Unit Price = PAR.Unit Price + DB1.Componant Price
 PAR.Unit_Price = PAR.Unit_Price + DB1.Componant_Price;

 ENDIF;

 ENDDO;

 ENDIF;

 //?*** 12 PROCESS COMPONANT EXTEND IF SELECTED *
 CASE;

 // IF DB1.Price Method Componant is EXTEND
 IF DB1.Price_Method_Componant = 'EXTEND';

 // AND DB1.PD Status is Active
 AND DB1.PD_Status = 'A';

 //?Process Extended Price Method Componant
 DO;

 //?Update Pricing Detail if Extended is not equal to 0.
 CASE;

 // IF DB1.Componant Price NE WRK.ZERO
 IF DB1.Componant_Price <> WRK.ZERO;

 //?Accumulate Final Price
 // PAR.Unit Price = PAR.Unit Price + DB1.Componant Price
 PAR.Unit_Price = PAR.Unit_Price + DB1.Componant_Price;

 // PAR.U/M - Pricing = PAR.U/M - Ordered
 PAR.UOM_Pricing = PAR.U_M_Ordered;

 ENDIF;

 ENDDO;

 ENDIF;

 //?*** 13 PROCESS COMPONANT OVRIDE IF SELECTED *
 CASE;

 // IF DB1.Price Method Componant is OVRIDE
 IF DB1.Price_Method_Componant = 'OVRIDE';

 // AND DB1.PD Status is Active
 AND DB1.PD_Status = 'A';

 //?Process Manual Pricing Componant
 DO;

 //?Update Pricing Detail if Override Amt is not equal to 0.
 CASE;

 // IF DB1.Componant Price NE WRK.ZERO
 IF DB1.Componant_Price <> WRK.ZERO;

 //?Accumulate Final Price
 // PAR.Unit Price = PAR.Unit Price + DB1.Componant Price
 PAR.Unit_Price = PAR.Unit_Price + DB1.Componant_Price;

 ENDIF;

 ENDDO;

 ENDIF;

 //?*** 14 Process Component ACCRLS if selected *
 CASE;

 // IF DB1.Price Method Componant is ACCRLS
 IF DB1.Price_Method_Componant = 'ACCRLS';

 // AND DB1.PD Status is Active
 AND DB1.PD_Status = 'A';

 //?** Process Retrieve Accruals Pricing Componant
 //?Update Pricing Retrieved Amount is not equal to 0
 CASE;

 // IF DB1.Componant Price NE WRK.ZERO
 IF DB1.Componant_Price <> WRK.ZERO;

 //?Accumulate Final Price
 // PAR.Unit Price = PAR.Unit Price + DB1.Componant Price
 PAR.Unit_Price = PAR.Unit_Price + DB1.Componant_Price;

 ENDIF;

 ENDIF;

 //?*** 15 PROCESS COMPONANT CFRTAB IF SELECTED *
 CASE;

 // IF DB1.Price Method Componant is CFRTAB
 IF DB1.Price_Method_Componant = 'CFRTAB';

 // AND DB1.PD Status is Active
 AND DB1.PD_Status = 'A';

 //?Process Company/Customer freight Rate Absprbed Componant
 DO;

 //?Update Pricing Detail if Freight Absorbed is not equal to 0.
 CASE;

 // IF DB1.Componant Price NE WRK.ZERO
 IF DB1.Componant_Price <> WRK.ZERO;

 //?Accumulate Final Price
 // PAR.Unit Price = PAR.Unit Price + DB1.Componant Price
 PAR.Unit_Price = PAR.Unit_Price + DB1.Componant_Price;

 ENDIF;

 ENDDO;

 ENDIF;

 //?*** 16 PROCESS COMPONANT IOVFRT IF SELECTED *
 CASE;

 // IF DB1.Price Method Componant is IOVFRT
 IF DB1.Price_Method_Componant = 'IOVFRT';

 // AND DB1.PD Status is Active
 AND DB1.PD_Status = 'A';

 //?Process Item Market Overage Componant
 DO;

 //?Update Pricing Detail if Market Overage is not equal to 0.
 CASE;

 // IF DB1.Componant Price NE WRK.ZERO
 IF DB1.Componant_Price <> WRK.ZERO;

 //?Accumulate Final Price
 // PAR.Unit Price = PAR.Unit Price + DB1.Componant Price
 PAR.Unit_Price = PAR.Unit_Price + DB1.Componant_Price;

 ENDIF;

 ENDDO;

 ENDIF;

 //?P205--New Components
 //?*** 17 PROCESS COMPONANT CIMSLV IF SELECTED *
 CASE;

 // IF DB1.Price Method Componant is CIMSLV
 IF DB1.Price_Method_Componant = 'CIMSLV';

 // AND DB1.PD Status is Active
 AND DB1.PD_Status = 'A';

 //?Process Item Market Overage Componant
 DO;

 //?Update Pricing Detail if Market Overage is not equal to 0.
 CASE;

 // IF DB1.Componant Price NE WRK.ZERO
 IF DB1.Componant_Price <> WRK.ZERO;

 //?Accumulate Final Price
 // PAR.Unit Price = PAR.Unit Price + DB1.Componant Price
 PAR.Unit_Price = PAR.Unit_Price + DB1.Componant_Price;

 ENDIF;

 ENDDO;

 ENDIF;

 //?*** 18 PROCESS COMPONANT CIPFEE IF SELECTED *
 CASE;

 // IF DB1.Price Method Componant is CIPFEE
 IF DB1.Price_Method_Componant = 'CIPFEE';

 // AND DB1.PD Status is Active
 AND DB1.PD_Status = 'A';

 //?Process Item Market Overage Componant
 DO;

 //?Update Pricing Detail if Market Overage is not equal to 0.
 CASE;

 // IF DB1.Componant Price NE WRK.ZERO
 IF DB1.Componant_Price <> WRK.ZERO;

 //?Accumulate Final Price
 // PAR.Unit Price = PAR.Unit Price + DB1.Componant Price
 PAR.Unit_Price = PAR.Unit_Price + DB1.Componant_Price;

 ENDIF;

 ENDDO;

 ENDIF;

 //?*** 19 PROCESS COMPONANT CIFRTO IF SELECTED *
 CASE;

 // IF DB1.Price Method Componant is CIFRTO
 IF DB1.Price_Method_Componant = 'CIFRTO';

 // AND DB1.PD Status is Active
 AND DB1.PD_Status = 'A';

 //?Process Item Market Overage Componant
 DO;

 //?Update Pricing Detail if Market Overage is not equal to 0.
 CASE;

 // IF DB1.Componant Price NE WRK.ZERO
 IF DB1.Componant_Price <> WRK.ZERO;

 //?Accumulate Final Price
 // PAR.Unit Price = PAR.Unit Price + DB1.Componant Price
 PAR.Unit_Price = PAR.Unit_Price + DB1.Componant_Price;

 ENDIF;

 ENDDO;

 ENDIF;

 //?*** 20 PROCESS COMPONANT CITMOV IF SELECTED *
 CASE;

 // IF DB1.Price Method Componant is CITMOV
 IF DB1.Price_Method_Componant = 'CITMOV';

 // AND DB1.PD Status is Active
 AND DB1.PD_Status = 'A';

 //?Process Item Market Overage Componant
 DO;

 //?Update Pricing Detail if Market Overage is not equal to 0.
 CASE;

 // IF DB1.Componant Price NE WRK.ZERO
 IF DB1.Componant_Price <> WRK.ZERO;

 //?Accumulate Final Price
 // PAR.Unit Price = PAR.Unit Price + DB1.Componant Price
 PAR.Unit_Price = PAR.Unit_Price + DB1.Componant_Price;

 ENDIF;

 ENDDO;

 ENDIF;

 //?*** 21 PROCESS COMPONANT CSFRTO IF SELECTED *
 CASE;

 // IF DB1.Price Method Componant is CSFRTO
 IF DB1.Price_Method_Componant = 'CSFRTO';

 // AND DB1.PD Status is Active
 AND DB1.PD_Status = 'A';

 //?Process Item Market Overage Componant
 DO;

 //?Update Pricing Detail if Market Overage is not equal to 0.
 CASE;

 // IF DB1.Componant Price NE WRK.ZERO
 IF DB1.Componant_Price <> WRK.ZERO;

 //?Accumulate Final Price
 // PAR.Unit Price = PAR.Unit Price + DB1.Componant Price
 PAR.Unit_Price = PAR.Unit_Price + DB1.Componant_Price;

 ENDIF;

 ENDDO;

 ENDIF;

 //?*** 22 PROCESS COMPONANT PSITPR IF SELECTED *
 CASE;

 // IF DB1.Price Method Componant is PSITPR
 IF DB1.Price_Method_Componant = 'PSITPR';

 // AND DB1.PD Status is Active
 AND DB1.PD_Status = 'A';

 //?Process Item Market Overage Componant
 DO;

 //?Update Pricing Detail if Market Overage is not equal to 0.
 CASE;

 // IF DB1.Componant Price NE WRK.ZERO
 IF DB1.Componant_Price <> WRK.ZERO;

 //?Accumulate Final Price
 // PAR.Unit Price = PAR.Unit Price + DB1.Componant Price
 PAR.Unit_Price = PAR.Unit_Price + DB1.Componant_Price;

 ENDIF;

 ENDDO;

 ENDIF;

 //?*** 23 PROCESS COMPONANT PSMKTO IF SELECTED *
 CASE;

 // IF DB1.Price Method Componant is PSMKTO
 IF DB1.Price_Method_Componant = 'ITMKTO';

 // AND DB1.PD Status is Active
 AND DB1.PD_Status = 'A';

 //?Process Item Market Overage Componant
 DO;

 //?Update Pricing Detail if Market Overage is not equal to 0.
 CASE;

 // IF DB1.Componant Price NE WRK.ZERO
 IF DB1.Componant_Price <> WRK.ZERO;

 //?Accumulate Final Price
 // PAR.Unit Price = PAR.Unit Price + DB1.Componant Price
 PAR.Unit_Price = PAR.Unit_Price + DB1.Componant_Price;

 ENDIF;

 ENDDO;

 ENDIF;

 //?*** 24 PROCESS COMPONANT MKTOVR IF SELECTED *
 CASE;

 // IF DB1.Price Method Componant is MKTOVR
 IF DB1.Price_Method_Componant = 'MKTOVR';

 // AND DB1.PD Status is Active
 AND DB1.PD_Status = 'A';

 //?Process Item Market Overage Componant
 DO;

 //?Update Pricing Detail if Market Overage is not equal to 0.
 CASE;

 // IF DB1.Componant Price NE WRK.ZERO
 IF DB1.Componant_Price <> WRK.ZERO;

 //?Accumulate Final Price
 // PAR.Unit Price = PAR.Unit Price + DB1.Componant Price
 PAR.Unit_Price = PAR.Unit_Price + DB1.Componant_Price;

 ENDIF;

 ENDDO;

 ENDIF;

 //?E2494-New Component for Gate price AND Flat Duty Priced items
 //?*** 25 PROCESS COMPONANT GATADJ IF SELECTED AND IS ACTIVE-*
 CASE;

 // IF DB1.Price Method Componant is GATADJ
 IF DB1.Price_Method_Componant = 'GATADJ';

 // AND DB1.PD Status is Active
 AND DB1.PD_Status = 'A';

 //?Process Gate Adjustment Component
 DO;

 //?Update Pricing Detail if Gate adj is not equal to 0.
 CASE;

 // IF DB1.Componant Price NE WRK.ZERO
 IF DB1.Componant_Price <> WRK.ZERO;

 //?Accumulate Final Price
 // PAR.Unit Price = PAR.Unit Price + DB1.Componant Price
 PAR.Unit_Price = PAR.Unit_Price + DB1.Componant_Price;

 ENDIF;

 ENDDO;

 ENDIF;

 //?*** 26 PROCESS COMPONENT DVGADJ IF SELECTED AND IS ACTIVE-*
 CASE;

 // IF DB1.Price Method Componant is DVFADJ
 IF DB1.Price_Method_Componant = 'DVFADJ';

 // AND DB1.PD Status is Active
 AND DB1.PD_Status = 'A';

 //?Update Pricing Detail if Gate adj is not equal to 0.
 CASE;

 // IF DB1.Componant Price NE WRK.ZERO
 IF DB1.Componant_Price <> WRK.ZERO;

 //?Accumulate Final Price
 // PAR.Unit Price = PAR.Unit Price + DB1.Componant Price
 PAR.Unit_Price = PAR.Unit_Price + DB1.Componant_Price;

 ENDIF;

 ENDIF;

}


ENDIF;

//?*****************************************************************
//?This Code was Brought in from CLC Read/Proc. Detail  RT
DO;

//?Convert from CWT to Pricing U/M if Market or Formula Pricing
CASE;

// IF PAR.Price Method Type is Market or Formula
IF PAR.Price_Method_Type = 'F'/'K';

// Call program CLC Cvt Price-From CW  XF.
CALL PROGRAM(CLC Cvt Price-From CW  XF) ('PDZ2XFR');
PARAMETER(PAR.Company_Number);
PARAMETER(PAR.Item_Code);
PARAMETER(PAR.Unit_Price);
PARAMETER(WRK.Price_Adjustment_Amount);

// PAR.Unit Price = WRK.Price Adjustment Amount
PAR.Unit_Price = WRK.Price_Adjustment_Amount;

ENDIF;

//?Price has been converted to Pricing U/M Price
//?Now convert to the 3 U/M's Parms which will also calc Selling
//?U/M Price.
// Call program CLC Convert Price Qtys XF.
CALL PROGRAM(CLC Convert Price Qtys XF) ('PDKGXFR');
PARAMETER(PAR.Company_Number);
PARAMETER(PAR.Item_Code);
PARAMETER(PAR.UOM_Pricing);
PARAMETER(PAR.Price_based_on_U_M1_S);
PARAMETER(PAR.Price_based_on_U_M2_S);
PARAMETER(PAR.Price_based_on_U_M3_S);
PARAMETER(PAR.Unit_Price);

//?U/M - Pricing was moved to Wrk context at the beginning.  If the
//?Pricing Method = EXT then the "Par.U/M - Price" was changed to the
//?U/M - Ordered, therefore move back the original value prior to exit.
//?ALSO: If U/M was not Hundred Weight, and not Extention, then The
//?Price had been changed to CW for Computation. Therefore Convert to
//?the Original U/M.
// PAR.U/M - Pricing = WRK.U/M - Pricing
PAR.UOM_Pricing = WRK.UOM_Pricing;

ENDDO;

//?*****************************************************************
//?This Code was brought in from CLC Price Item         XF
DO;

//?If Extended Method=for Price, use Pricing U/M & Load Unit Price
CASE;

// IF PAR.Price Method Type is Extended Pricing
IF PAR.Price_Method_Type = 'X';

//?If U/M Priced = Primary then execute
CASE;

// IF PAR.U/M - Pricing EQ PAR.U/M - Primary
IF PAR.UOM_Pricing = PAR.UOM_Primary;

// PAR.Unit Price = PAR.Price based on U/M1 S
PAR.Unit_Price = PAR.Price_based_on_U_M1_S;

ENDIF;

//?If U/M Priced = Secondary then execute
CASE;

// IF PAR.U/M - Pricing EQ PAR.U/M - Second
IF PAR.UOM_Pricing = PAR.UOM_Second;

// PAR.Unit Price = PAR.Price based on U/M2 S
PAR.Unit_Price = PAR.Price_based_on_U_M2_S;

ENDIF;

//?If U/M Priced = Third then execute
CASE;

// IF PAR.U/M - Pricing EQ PAR.U/M - Third
IF PAR.UOM_Pricing = PAR.UOM_Third;

// PAR.Unit Price = PAR.Price based on U/M3 S
PAR.Unit_Price = PAR.Price_based_on_U_M3_S;

ENDIF;

ENDIF;

//?If U/M Priced = Primary then execute
CASE;

// IF PAR.U/M - Ordered EQ PAR.U/M - Primary
IF PAR.U_M_Ordered = PAR.UOM_Primary;

// PAR.Unit Price Ordered U/M = PAR.Price based on U/M1 S
PAR.Unit_Price_Ordered_U_M = PAR.Price_based_on_U_M1_S;

ENDIF;

//?If U/M Priced = Secondary then execute
CASE;

// IF PAR.U/M - Ordered EQ PAR.U/M - Second
IF PAR.U_M_Ordered = PAR.UOM_Second;

// PAR.Unit Price Ordered U/M = PAR.Price based on U/M2 S
PAR.Unit_Price_Ordered_U_M = PAR.Price_based_on_U_M2_S;

ENDIF;

//?If U/M Priced = Third then execute
CASE;

// IF PAR.U/M - Ordered EQ PAR.U/M - Third
IF PAR.U_M_Ordered = PAR.UOM_Third;

// PAR.Unit Price Ordered U/M = PAR.Price based on U/M3 S
PAR.Unit_Price_Ordered_U_M = PAR.Price_based_on_U_M3_S;

ENDIF;

ENDDO;

//?*****************************************************************
