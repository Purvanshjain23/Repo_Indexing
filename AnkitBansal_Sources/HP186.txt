      *****************  RPG PROGRAM HEADING  ***********************
      *
      * SYSTEM:      HOG PRODUCTION
      * PROGRAM:     HP186
      * TITLE:       MAINTAIN POSTED TRANSFER
      * PROGRAMMER:  LEANNE FEDOR
      * CREATED:     08/27/02
      *
      *           THIS FUNCTION IS ONLY FOR I.S. PERSONNEL...DO NOT GIVE TO USERS.
      *
      *           THE PROGRAM WILL ONLY UPDATE A MOVEMENT---NO CREATE OR DELETE.
      *           ALL LOGIC THAT PROTECTED DISPOSED/CLOSED GROUPS HAS BEEN REMOVED!
      *           ALL 'PERIOD' LOGIC HAS BEEN REMOVED!
      *           NO EDITS ARE PERFORMED TO DETERMINE THAT A TRUCKER IS ACTIVE!
      *
      * FUNCTION: THIS PROGRAM IS A SOMEWHAT CLONE OF HP139.
      *
      *           THIS PROGRAM IS CALLED FROM:
      *                HP486-WORK WITH POSTED TRANFSERS (a clone of HP439)
      *
      *
      ****************************************************************
      * MODIFICATIONS:
      ****************************************************************
      * DATE      PROGRAMMER
      *
      * 01/18/06  LeAnne Fedor
      *           Recompile only.
      *           Field "Bin Set" was removed from HSP020-Building Rooms file
      *
      * 04/09/09  LeAnne Ramsey
      *           Changed the $clean subroutine. Since we are now purging data, the
      *           BGF groups (which never close) may no longer have the movements that
      *           initially moved hogs into the groups. So, the "clean-up" routine is
      *           flipping them from OP back to CR...we do not want that.
      *
      * 07/02/09  LeAnne Ramsey
      *           Recompile only. Added new field 'Continuous Flow Flag' to Hog Group file.
      *
      * 05/20/11  LeAnne Ramsey (E1557)
      *           Recompile only. Added Yard Dead to HSJ085E.
      *
      * 01/21/13  LeAnne Ramsey (E2410)
      *           Kim Humbard requested that we change the logic for BGF Warning
      *           Message HS00344 to kick in when the Average Lbs is <10...as well
      *           as the current condition/check of >20 lbs. She says that this
      *           may be a temp change....if it happens too often, they will want
      *           me to remove the <10 logic.
      *
      * 10/15/13  LeAnne Ramsey (E2831)
      *           Recompile only. Added field 'MTech Reference'.
      *
      * 10/21/13  LeAnne Ramsey (E2831)
      *           Added MTech Reference as a parm on the calls to:
      *               HP538-Select Trucker
      /EJECT
      ****************************************************************
      * FILE SPECIFICATIONS
      ****************************************************************
      *
     FHPD186    CF   E             WORKSTN SFILE(HP186S1:HDRRN1)
     F                                     INFDS(IOFEED)
      *
     FHSP018    IF   E           K DISK
      *    FARM SITE
      *
      *
     Fhsp019    if   e           k disk
      *    Farm buildings
      *
      *
     Fhsp020    if   e           k disk
      *    building rooms
      *
      *
     FHSP034    IF   E           K DISK
      *  HOG GROUPS
      *
      *
     FHSL034D   UF   E           K DISK    rename(hgrec:hgrecd)
      *  Hog groups
      *
      *
     Fhsl034o   if   e           k disk    rename(hgrec:hgreco)
      *  Hog groups  (open and created groups only)
      *
      *
     Fhsl034p   if   e           k disk    rename(hgrec:hgrecp) prefix(p1)
      *  Hog groups (open groups only)
      *
      *
     FHSP046    IF   E           K DISK
      *    TRUCKER
      *
      *
     FHSP058    UF A E           K DISK
      *  MOVEMENT EVENT
      *
      *
     FHSJ058A   IF   E           K DISK    RENAME(MEREC:MERECA)
      *  MOVEMENT EVENT
      *  (SELECT:  MEMTCD = T AND MEODFL = D)
      *
      *
     Fhsl068d   if   e           k disk
      *  Killed/dead hogs
      *
      *
     FHSP074    UF A E           K DISK
      *  TRANSFER HEADER
      *
      *
     FHSP075    UF A E           K DISK
      *  TRANSFER DETAIL
      *
      *
     FHSP078    UF   E           K DISK
      *  REJECTED HEAD WITH REASONS
      *
      *
     Fhsl085b   if   e           k disk
      *  Sales movement detail
      *
      *
     Fhsj085e   if   e           k disk    rename(sgrec:sgrece)
      *  Sales detail + Sales header
      *
      *
      /EJECT
      ****************************************************************
      * STANDALONE FIELDS
      ****************************************************************
      *
      * Define parms for the generic movement program
      *
     D zzcymd          s              8  0
      *
     D @@nu50          s              5  0
     D gpihd           s                   like(@@nu50)
     D pinhd           s                   like(@@nu50)
     D tinhd           s                   like(@@nu50)
     D tisphd          s                   like(@@nu50)
     D tidphd          s                   like(@@nu50)
     D pouhd           s                   like(@@nu50)
     D touhd           s                   like(@@nu50)
     D tosphd          s                   like(@@nu50)
     D todphd          s                   like(@@nu50)
     D rinhd           s                   like(@@nu50)
     D rouhd           s                   like(@@nu50)
     D qinhd           s                   like(@@nu50)
     D qouhd           s                   like(@@nu50)
     D morhd           s                   like(@@nu50)
     D inahd           s                   like(@@nu50)
      *
     D @@nu92          s              9  2
     D pinlb           s                   like(@@nu92)
     D tinlb           s                   like(@@nu92)
     D tisplb          s                   like(@@nu92)
     D tidplb          s                   like(@@nu92)
     D poulb           s                   like(@@nu92)
     D toulb           s                   like(@@nu92)
     D tosplb          s                   like(@@nu92)
     D todplb          s                   like(@@nu92)
     D rinlb           s                   like(@@nu92)
     D roulb           s                   like(@@nu92)
     D qinlb           s                   like(@@nu92)
     D qoulb           s                   like(@@nu92)
     D morlb           s                   like(@@nu92)
      *
      *
      * Workfields for date manipulation
      *
     D wkcymdiso       s               D   datfmt(*iso)
     D wkcutoffdt      s                   like(hgopdt)
     D wkalphadt       s              8
      *
      /eject
      ****************************************************************
      * TABLE AND ARRAY SPECIFICATIONS
      ****************************************************************
      *
      *---------------------------------------------------------------
      *  STANDARD MESSAGE ARRAYS
      *---------------------------------------------------------------
      *
      *---------------------------------------------------------------
      * STANDARD ERROR MESSAGE HANDLING DATA STRUCTURES
      *---------------------------------------------------------------
      *
      * FOR ERROR MESSAGE HANDLING, A PACKED INDEX (E) IS REQUIRED.
      * FOR PROGRAM READABILITY, DEFINE A CORRESPONDING ERROR COUNT
      * FIELD CALLED 'ERROR'. ALSO DEFINE CURSOR LOCATION FIELDS.
      *
     D                 DS                  INZ
     D  ERROR                  1      2P 0
     D  E                      1      2P 0
      *
      * THIS DATA STRUCTURE SUPPLIES THE NAME OF THE MESSAGE FILE TO
      * THE MESSAGE HANDLING CL PROGRAM.  THE FIELD NAME MSGFIL MUST BE
      * CONSTANT. THE VALUE IN QUOTES IS THE NAME OF THE SPECIFIC
      * MESSAGE FILE CONTAINING THE USER DEFINED MESSAGES.
      *
     D                 DS                  INZ
     D  MSGFIL                 1     10    INZ('HSMSGF    ')
      *
      * THE FOLLOWING 3 DATA STRUCTURES ARE USED TO SPEED MESSAGE
      * HANDLING SINCE IT IS FASTER TO CLEAR DATA STRUCTURES THAN
      * ARRAYS.  EACH IS ASSOCIATED WITH A STANDARD MESSAGE ARRAY.
      *
     D MGI             DS           140    INZ
     D  MGID                   1    140
     D                                     DIM(20)                              MSG ID ARRAY
      *
     D MGD             DS          1000    INZ
     D  MGDT                   1   1000
     D                                     DIM(20)                              MSG PARMS
      *
     D MGWK            DS            50    INZ
     D  MGW                    1     50
     D                                     DIM(50)                              MSG WORK PARMS
      *
      *---------------------------------------------------------------
      * STANDARD PROGRAM STATUS DATA STRUCTURE
      *---------------------------------------------------------------
      *    EXTERNALLY DEFINED AS UTPGFR (RECORD FORMAT: PGMDSR)
     D PGMDS         ESDS                  EXTNAME(UTPGFR)
      *
      *---------------------------------------------------------------
      * STANDARD WORKSTATION INFORMATION DATA STRUCTURE
      *---------------------------------------------------------------
      *    EXTERNALLY DEFINED AS UTWSFR (RECORD FORMAT: UTIDFRR)
     D IOFEED        E DS                  EXTNAME(UTWSFR)
      *
      *---------------------------------------------------------------
      * STANDARD DATABASE FILE INFORMATION DATA STRUCTURE
      *---------------------------------------------------------------
      *    EXTERNALLY DEFINED AS UTDBFR (RECORD FORMAT: FDBCKD)
     D DBFEED        E DS                  EXTNAME(UTDBFR)
      *
      *---------------------------------------------------------------
      *STANDARD SUBFILE SELECTOR CONVERSION
      *---------------------------------------------------------------
     D                 DS
     D  DFOPT                  1      2
     D  WKOPT1                 1      1
     D  WKOPT2                 2      2
      *
      *---------------------------------------------------------------
      * DESTINATION HOG GROUP ARRAY
      *---------------------------------------------------------------
      *
     D GRP             S              7  0 DIM(50)                              DEST GROUPS
      *
      *---------------------------------------------------------------
      *  DATE FORMATS
      *---------------------------------------------------------------
      *
      * DATE IN MMDDYY FORMAT
      *
     D                 DS
     D  WKMDY                  1      6  0
     D  WKMM                   1      2  0
     D  WKDD                   3      4  0
     D  WKYY                   5      6  0
      *
      * DATE IN CCYYMMDD FORMAT
      *
     D                 DS
     D  WKCYMD                 1      8  0
     D  WKCEN                  1      2  0
     D  WKYER                  3      4  0
     D  WKMON                  5      6  0
     D  WKDAY                  7      8  0
      *
      * TIME IN HOURS AND MINUTES FOR EDITING OF
      * DATA ENTRY
      *
     D                 DS
     D  WKHHMM                 1      4  0
     D  WKHOUR                 1      2  0
     D  WKMIN                  3      4  0
      *
      *---------------------------------------------------------------
      * TIME FORMAT FOR RETRIEVAL OF SYSTEM TIME FOR RECORD TIME STAMP
      *---------------------------------------------------------------
      *
     D                 DS
     D  HHMMSS                 1      6  0
     D  HHMM                   1      4  0
      *
      *---------------------------------------------------------------
      *  NAMED CONSTANTS
      *---------------------------------------------------------------
      *
     D REVISE          C                   CONST('REVISE')
     D YES             C                   CONST('Y')
     D NO              C                   CONST('N')
     D SET1            C                   CONST('SET1  ')
     D EDIT1           C                   CONST('EDIT1 ')
     D SCRN1           C                   CONST('SCRN1 ')
     D EXIT            C                   CONST('EXIT  ')
      *
      * The following is a dummy C-spec to keep the D-specs from
      * running over into the C-specs on the compile listing. It
      * serves no other purpose and can be deleted at any time.
      *
     C                   if        sdpgm = *blank
     C                   endif
      /EJECT
      ****************************************************************
      * MAINLINE
      ****************************************************************
      *
     C                   MOVEL     SET1          ROUTNE
      *
     C     *INLR         DOWEQ     *OFF                                         MAIN DO LOOP
      *
     C     ROUTNE        CASEQ     SET1          $SET1
     C     ROUTNE        CASEQ     SCRN1         $SCRN1
     C     ROUTNE        CASEQ     EDIT1         $EDIT1
      *
     C     ROUTNE        CASEQ     EXIT          $EXIT
     C                   ENDCS
     C                   ENDDO                                                  MAIN DO LOOP
      /EJECT
      *----------------------------------------------------------------
      * SUBROUTINE TO SET ENVIRONMENT FOR SCREEN 1
      *----------------------------------------------------------------
      *
     C     $SET1         BEGSR
      *
      *
      * IF THE USER IS REVISING, VERIFY THAT THE TRANSFER MOVEMENT
      *    THAT THE USER SELECTED STILL EXISTS AND SETUP THE HEADER
      *    INFO FOR THE CONTROL RECORD
      *
     C     C1MVSN        CHAIN(N)  HSP074                             90
     C     *IN90         IFEQ      *OFF                                         IF FOUND
     C                   EXSR      $HDR
     C                   ELSE
     C                   MOVEL     YES           NOTFLG
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS00592'     MGID(E)
     C                   CLEAR                   MGW
     C                   MOVEL     C1MVSN        XXMVSN
     C                   MOVEA     XXMVSN        MGW(1)
     C                   MOVEA     MGW           MGDT(E)
     C                   ENDIF
     C                   ENDIF                                                  IF FOUND
      *
      *  CLEAR/FILL THE SUBFILE
      *
     C                   EXSR      $CLR1
     C                   EXSR      $FRSH1
      *
      *  SET ROUTINE TO DISPLAY SCREEN
      *
     C                   MOVEL     SCRN1         ROUTNE
      *
     C                   ENDSR
      /EJECT
      *---------------------------------------------------------------
      * SUBROUTINE TO PERFORM OPERATOR I/O FOR SCREEN 1
      *---------------------------------------------------------------
      *
     C     $SCRN1        BEGSR
      *
      * SET THE PAGE OF THE SUBFILE TO DISPLAY
      *
     C                   SELECT
     C     WKFLOW        WHENEQ    0
     C     ERROR         ANDEQ     0
     C                   Z-ADD     1             HDPAG1
      *
     C     RESET         WHENEQ    YES
     C     WKFLOW        IFGT      HDRRN1
     C                   ELSE
     C                   Z-ADD     WKFLOW        HDPAG1
     C                   ENDIF
     C                   ENDSL
      *
      * SET THE INDICATORS TO CONTROL SCREEN FIELDS
      *
     C                   EXSR      $C1IND
      *
      * IF THE USER HAS EDITED THE DATA, THEN ISSUE THE 'ACCEPT
      * ENTRIES' MESSAGE
      *
     C                   if        editfl = yes and
     C                             (error = 0 or error = warmsg)
     C                   add       1             error
     C                   movel     'HS09026'     mgid(e)
     C                   endif
      *
      * WRITE THE ERROR MESSAGES FROM THE ERROR ARRAYS TO THE
      * ERROR MESSAGE SUBFILE
      *
     C                   EXSR      $WRMSG
      *
      *
      * THIS SUBFILE HAS FOLD/UNFOLD CAPABILITIES.  THE DDS USES THE
      * KEYWORDS (SFLDROP, SFLFOLD) TO DETERMINE WHETHER THE
      * USER IS FOLDED OR UNFOLDED AND TO REDISPLAY THE SCREEN IN THE
      * SAME MODE AS WHEN HE LAST SAW IT.  INDICATORS 88 AND 89 ARE
      * ASSIGNED IN THE DDS TO SFLDROP AND SFLFOLD.
      *
      *
     C                   setoff                                       8889
     C                   if        fold = '0'
     C                   seton                                        88
     C                   else
     C                   seton                                        89
     C                   endif
      *
      *  WRITE SCREEN 1 TO CRT
      *
     C                   WRITE     HP186K1
     C                   WRITE     HP186EC
     C                   EXFMT     HP186C1
      *
      * RESET THE COUNT FIELD FOR WARNING MESSAGES
      *
     C                   Z-ADD     0             WARMSG
      *
      * RETRIEVE THE LOWEST SUBFILE RRN ON THE SCREEN FROM THE DSPF
      * FEEDBACK AREA (IDFLOW) AND MOVE IT TO A WORK FIELD.  THIS VALUE
      * WILL BE USED LATER TO CONTROL THE REPOSITIONING OF THE SUBFILE.
      *
     C                   Z-ADD     IDFLOW        WKFLOW
     C                   MOVEL     NO            RESET
     C                   MOVEL     NO            EDITFL
      *
      * CLEAR ALL MESSAGES
      *
     C                   EXSR      $CLMSG
      *
      * GET USER'S ENTRY AND RESET STANDARD RESPONSE
      *
     C                   SELECT
     C     *IN03         WHENEQ    *ON                                          F3-EXIT
     C                   MOVEL     '03'          RTNCD
     C                   MOVEL     EXIT          ROUTNE
      *
     C     *IN04         WHENEQ    *ON                                          F4-PROMPT
     C                   EXSR      $F4S1
     C                   MOVEL     SCRN1         ROUTNE
      *
     C     *IN05         WHENEQ    *ON                                          F5-REFRESH
     C                   MOVEL     YES           RESET
     C                   MOVEL     SET1          ROUTNE
      *
     C     *IN09         WHENEQ    *ON                                          F9-ACCEPT
     C                   EXSR      $ACCEPT
      *
     C     *IN12         WHENEQ    *ON                                          F12-PREVIOUS
     C                   MOVEL     '12'          RTNCD
     C                   MOVEL     EXIT          ROUTNE
      *
     C     *IN25         WHENEQ    *ON                                          F25-ROLLUP
     C     IDFLOW        ADD       WKPLIN        WKDIFF
     C     HDRRN1        IFGE      WKDIFF                                       IF SOMETHING
     C                   ELSE
     C                   Z-ADD     COUNT         HDRRN1
     C                   EXSR      $SETOF
     C                   EXSR      $CLRLN
     C                   DO        WKPLIN                                       DO FILL
     C                   EXSR      $BLANK
     C                   ENDDO                                                  DO FILL
     C                   ENDIF                                                  IF SOMETHING
     C                   MOVEL     SCRN1         ROUTNE
      *
     C     NOTFLG        WHENEQ    YES                                           MOVE GONE
     C                   MOVEL     SET1          ROUTNE
     C                   OTHER
      *
      * USER PRESSED 'ENTER'
      *
     C                   EXSR      $EDIT1
     C                   ENDSL
      *
     C                   ENDSR
      /EJECT
      *---------------------------------------------------------------
      * SUBROUTINE TO EDIT INPUT FIELDS FOR SCREEN 1
      *---------------------------------------------------------------
      *
     C     $EDIT1        BEGSR
      *
     C                   MOVEL     YES           EDITFL
      *
      * EDIT THE CONTROL RECORD
      *
     C                   EXSR      $EDC1
      *
      * EDIT THE SUBFILE IF THERE ARE NO ERRORS IN THE CONTROL
      * RECORD. IF THERE ARE ERRORS IN THE CONTROL RECORD, YOU
      * NEED TO REWRITE ANY SUBFILE RECORDS WITH THE ERROR INDICATORS
      * OFF.
      *
     C                   if        error = 0 or error = warmsg
     C                   EXSR      $EDS1
     C                   ELSE
     C                   EXSR      $OFFIN
     C                   ENDIF
      *
     C                   if        error = 0 or error = warmsg
     C                   Z-ADD     1             HDPAG1
     C                   ENDIF
     C                   MOVEL     SCRN1         ROUTNE
      *
     C                   ENDSR
      /EJECT
      *---------------------------------------------------------------
      * SUBROUTINE TO READ CHANGED RECORDS IN SUBFILE AND
      *          EDIT FOR VALID SUBFILE OPTIONS FOR SCREEN 1
      *---------------------------------------------------------------
      *
     C     $EDOP1        BEGSR
      *
      * CONVERT OPTION USER ENTERED TO STANDARD FORMAT. FOR EXAMPLE,
      * A ' 1', '01', AND '1 ' MUST BE STANDARDIZED TO ' 1'.
      *
     C     WKOPT2        IFEQ      *BLANK                                       IF 2 = BLANK
     C                   MOVE      WKOPT1        WKOPT2
     C                   MOVE      *BLANK        WKOPT1
     C                   ENDIF                                                  IF 2 = BLANK
      *
     C     WKOPT1        IFEQ      *ZEROS                                       IF 1 IS ZERO
     C                   MOVE      *BLANK        WKOPT1
     C                   ENDIF                                                  IF 1 IS ZERO
      *
      * TEST FOR VALID SUBFILE OPTION ENTRY
      *
     C                   SELECT
     C     DFOPT         WHENNE    *BLANK                                       WH BAD OPT
     C     DFOPT         ANDNE     ' 2'
     C     DFOPT         ANDNE     ' 4'
     C                   SETON                                        30
     C                   MOVEL     NO            LNOKFL
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS09006'     MGID(E)
     C                   EXSR      $ERR1
     C                   ENDIF
      *
     C     DFOPT         WHENEQ    ' 2'
     C     DFRJHD        ANDLE     0
     C                   SETON                                        30
     C                   MOVEL     NO            LNOKFL
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS00597'     MGID(E)
     C                   CLEAR                   MGW
     C                   MOVEA     DFOPT         MGW(1)
     C                   MOVEA     MGW           MGDT(E)
     C                   ENDIF
     C                   EXSR      $ERR1
     C                   ENDSL
      *
      * IF THE USER ENTERED OPTION 4, DELETE ANY REJECT REASONS
      * THAT MAY EXIST FOR THIS TRANSFER MOVEMENT LINE
      *
     C     DFOPT         IFEQ      ' 4'
     C                   EXSR      $DLTLR
     C                   MOVE      *BLANK        DFOPT
     C                   ENDIF
      *
     C                   ENDSR
      /EJECT
      *---------------------------------------------------------------
      * SUBROUTINE TO EDIT THE CONTROL RECORD INFO ON SCREEN 1
      *---------------------------------------------------------------
      *
     C     $EDC1         BEGSR
      *
      *
      * SCHEDULED SHIP DATE
      *
     C                   EXSR      $SCDT
      * TRUCKER
      *
     C     C1TICD        IFNE      *BLANK                                       IF TRUCK ID
     C     C1TICD        CHAIN     HSP046                             91
     C     *IN91         IFEQ      *ON                                          IF BAD
     C                   SETON                                        33
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS00235'     MGID(E)
     C                   CLEAR                   MGW
     C                   MOVEA     C1TICD        MGW(1)
     C                   MOVEA     MGW           MGDT(E)
     C                   ENDIF
     C                   ENDIF                                                  IF BAD
     C                   ENDIF                                                  IF TRUCK ID
      *
      * SHIPPED DATE
      *
     C                   EXSR      $SHDT
      *
      * SHIPPED IN TIME
      *
     C     C1SITM        IFNE      0
     C                   MOVEL     'SI'          WKTIME
     C                   Z-ADD     C1SITM        WKHHMM
     C                   EXSR      $TIME
     C                   ENDIF
      *
      * SHIPPED OUT TIME
      *
     C     C1SOTM        IFNE      0
     C                   MOVEL     'SO'          WKTIME
     C                   Z-ADD     C1SOTM        WKHHMM
     C                   EXSR      $TIME
     C                   ENDIF
      *
      * RECEIVED DATE
      *
     C                   EXSR      $RCDT
      *
      * RECEIVED IN TIME
      *
     C     C1RITM        IFNE      0
     C                   MOVEL     'RI'          WKTIME
     C                   Z-ADD     C1RITM        WKHHMM
     C                   EXSR      $TIME
     C                   ENDIF
      *
      * RECEIVED OUT TIME
      *
     C     C1ROTM        IFNE      0
     C                   MOVEL     'RO'          WKTIME
     C                   Z-ADD     C1ROTM        WKHHMM
     C                   EXSR      $TIME
     C                   ENDIF
      *
      * ORIGIN FARM SITE
     C                   EXSR      $ORFS
      *
      * DESTINATION FARM
     C                   EXSR      $DNFS
      *
      * SCHEDULED HEAD TO SHIP
      *
     C     C1SCHD        IFLT      0
     C                   SETON                                        79
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS09000'     MGID(E)
     C                   ENDIF
     C                   ENDIF
      *
      * SHIPPED HEAD
      *
     C                   SELECT
     C     C1SHHD        WHENEQ    0
     C     C1MSCD        ANDEQ     'SH'
     C                   SETON                                        36
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS00621'     MGID(E)
     C                   ENDIF
      *
     C     C1SHHD        WHENLT    0
     C                   SETON                                        36
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS09000'     MGID(E)
     C                   ENDIF
     C                   ENDSL
      *
      * SHIPPED POUNDS
      *   2) CANNOT BE 0 WHEN STATUS IS 'SHIPPED'
      *   3) CAN NEVER BE NEGATIVE
      *   4) CANNOT BE LESS THAN THE 'SAVED' POUNDS THAT HAVE
      *      ALREADY BEEN DISTRIBUTED TO GROUPS ON SUBFILE LINES THAT
      *      ARE NOW PROTECTED FROM USER ENTRY
      *   5) IF THE SHIPPED POUNDS ENTERED BY THE USER EQUAL THE
      *      'SAVED' POUNDS BUT THE SHIPPED HEAD ENTERED BY THE USER
      *      DOES NOT EQUAL THE 'SAVED' HEAD, THEN THE USER HAS
      *      INCREASED OR DECREASED HEAD WITHOUT CHANGING POUNDS
      *
     C                   SELECT
     C     C1SHLB        WHENEQ    0
     C     C1MSCD        ANDEQ     'SH'
     C                   SETON                                        37
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS00620'     MGID(E)
     C                   ENDIF
      *
     C     C1SHLB        WHENLT    0
     C                   SETON                                        37
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS09000'     MGID(E)
     C                   ENDIF
      *
     C     C1SHLB        WHENLT    SVSHLB
     C                   SETON                                        37
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS00643'     MGID(E)
     C                   CLEAR                   MGW
     C                   MOVE      C1SHLB        XXLB
     C                   MOVEA     XXLB          MGW(1)
     C                   MOVE      SVSHLB        XXLB
     C                   MOVEA     XXLB          MGW(6)
     C                   MOVEA     MGW           MGDT(E)
     C                   ENDIF
      *
     C     C1SHLB        WHENEQ    SVSHLB
     C     C1SHHD        ANDNE     SVSHHD
     C                   SETON                                        37
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS00644'     MGID(E)
     C                   CLEAR                   MGW
     C                   MOVE      SVSHLB        XXLB
     C                   MOVEA     XXLB          MGW(1)
     C                   MOVE      C1SHLB        XXLB
     C                   MOVEA     XXLB          MGW(6)
     C                   MOVEA     MGW           MGDT(E)
     C                   ENDIF
     C                   ENDSL
      *
      * Calculate average shipped pounds to show in control record as a visual
      * check for user that shipped pounds value is realistic.
      *
     c                   z-add     0             c1avshlb
     C                   if        c1shhd <> 0
     C     c1shlb        div(h)    c1shhd        c1avshlb
     C                   endif
      *
      * ARRIVED HEAD
      *
     C                   SELECT
      *
     C     C1ARHD        WHENEQ    0
     C     C1MSCD        ANDEQ     'SH'
     C                   SETON                                        72
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS00623'     MGID(E)
     C                   ENDIF
      *
     C     C1ARHD        WHENLT    0
     C                   SETON                                        72
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS09000'     MGID(E)
     C                   ENDIF
     C                   ENDSL
      *
      * ARRIVED POUNDS
      *   2) CANNOT BE 0 WHEN STATUS IS 'SHIPPED'
      *   3) CAN NEVER BE NEGATIVE
      *   4) CANNOT BE LESS THAN THE 'SAVED' POUNDS THAT HAVE
      *      ALREADY BEEN DISTRIBUTED TO GROUPS ON SUBFILE LINES THAT
      *      ARE NOW PROTECTED FROM USER ENTRY
      *   5) IF THE ARRIVED POUNDS ENTERED BY THE USER EQUAL THE
      *      'SAVED' POUNDS BUT THE ARRIVED HEAD ENTERED BY THE USER
      *      DOES NOT EQUAL THE 'SAVED' HEAD, THEN THE USER HAS
      *      INCREASED OR DECREASED HEAD WITHOUT CHANGING POUNDS
      *
      *
     C                   SELECT
     C     C1ARLB        WHENEQ    0
     C     C1MSCD        ANDEQ     'SH'
     C                   SETON                                        73
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS00622'     MGID(E)
     C                   ENDIF
      *
     C     C1ARLB        WHENLT    0
     C                   SETON                                        73
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS09000'     MGID(E)
     C                   ENDIF
      *
     C     C1ARLB        WHENLT    SVARLB
     C                   SETON                                        73
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS00645'     MGID(E)
     C                   CLEAR                   MGW
     C                   MOVE      C1ARLB        XXLB
     C                   MOVEA     XXLB          MGW(1)
     C                   MOVE      SVARLB        XXLB
     C                   MOVEA     XXLB          MGW(6)
     C                   MOVEA     MGW           MGDT(E)
     C                   ENDIF
      *
     C     C1ARLB        WHENEQ    SVARLB
     C     C1ARHD        ANDNE     SVARHD
     C                   SETON                                        73
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS00646'     MGID(E)
     C                   CLEAR                   MGW
     C                   MOVE      SVARLB        XXLB
     C                   MOVEA     XXLB          MGW(1)
     C                   MOVE      C1ARLB        XXLB
     C                   MOVEA     XXLB          MGW(6)
     C                   MOVEA     MGW           MGDT(E)
     C                   ENDIF
     C                   ENDSL
      *
      * Calculate average arrived pounds to show in control record as a visual
      * check for user that arrived pounds value is realistic.
      *
     C                   z-add     0             c1avarlb
     C                   if        c1arhd <> 0
     C     c1arlb        div(h)    c1arhd        c1avarlb
     C                   endif
      *
     C                   ENDSR
      /EJECT
      *----------------------------------------------------------------
      * EDIT ORIGIN FARM SITE
      *----------------------------------------------------------------
      *
     C     $ORFS         BEGSR
      *
     C                   MOVE      *BLANK        c1orfsnm
     C     c1orfscd      IFEQ      0                                            IF NO ORIG
     C                   SETON                                        31
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS09001'     MGID(E)
     C                   ENDIF
     C                   ELSE
      *
      * CHECK THAT FARM SITE EXISTS IN THE FARM SITE MASTER FILE
      *
     C     c1orfscd      CHAIN     HSP018                             92
     C     *IN92         IFEQ      *OFF                                         IF GOOD ORIG
     C                   MOVEL     FSFSNM        c1orfsnm
     C                   MOVEL     FSFSBO        WKORBO
     C                   ELSE
      *
      * INVALID FARM SITE
     C                   SETON                                        31
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS00131'     MGID(E)
     C                   CLEAR                   MGW
     C                   MOVE      c1orfscd      xxalphfscd
     C                   MOVEA     xxalphfscd    MGW(1)
     C                   MOVEA     MGW           MGDT(E)
     C                   ENDIF
     C                   ENDIF                                                  IF GOOD ORIG
     C                   ENDIF                                                  IF NO ORIG
      *
     C                   ENDSR
      /EJECT
      *----------------------------------------------------------------
      * EDIT DESTINATION FARM SITE
      *----------------------------------------------------------------
      *
     C     $DNFS         BEGSR
      *
     C                   MOVE      *BLANK        c1dnfsnm
     C     c1dnfscd      IFEQ      0                                            IF NO DEST
     C                   SETON                                        32
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS09001'     MGID(E)
     C                   ENDIF
     C                   ELSE
      *
      * CHECK THAT FARM SITE EXISTS IN THE FARM SITE MASTER FILE
      *
     C                   Z-ADD     0             SVHDSQFT
      *
     C     c1dnfscd      CHAIN     HSP018                             92
     C     *IN92         IFEQ      *OFF                                         IF GOOD DEST
     C                   MOVEL     FSFSNM        c1dnfsnm
     C                   MOVEL     FSFSBO        WKDNBO
     C                   Z-ADD     FSHDSQFT      SVHDSQFT
     C                   ELSE
      *
      * INVALID FARM SITE
     C                   SETON                                        32
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS00131'     MGID(E)
     C                   CLEAR                   MGW
     C                   MOVE      c1dnfscd      xxalphfscd
     C                   MOVEA     xxalphfscd    MGW(1)
     C                   MOVEA     MGW           MGDT(E)
     C                   ENDIF
     C                   ENDIF                                                  IF GOOD DEST
     C                   ENDIF                                                  IF NO DEST
      *
     C                   ENDSR
      /EJECT
      *----------------------------------------------------------------
      * EDIT SCHEDULED SHIP DATE
      *----------------------------------------------------------------
      *
     C     $SCDT         BEGSR
      *
     C                   SELECT
     C     C1MDY         WHENEQ    0
     C                   SETON                                        76
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVE      'HS00607'     MGID(E)
     C                   ENDIF
     C                   OTHER
      *
      * VALIDATE THAT THE DATE IS VALID AND ADD CENTURY VALUES
      * TO THE WORK FIELD FOR LATER USE IN THE UPDATING ROUTINE.
      *
     C                   Z-ADD     C1MDY         PFRM8
     C                   Z-ADD     0             PTO8
     C                   MOVEL     'MDY '        PFRFMT
     C                   MOVEL     'CYMD'        PTOFMT
     C                   Z-ADD     0             PDAYS
     C                   MOVE      *BLANK        PCODE
     C                   MOVE      *BLANK        PRTRN
      *
     C                   EXSR      $DATE
      *
     C     PRTRN         IFNE      *BLANK                                       IF INVALID
     C                   SETON                                        76
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVE      'HS09004'     MGID(E)
     C                   ENDIF
     C                   ELSE
     C                   Z-ADD     PTO8          WKSCDT
     C                   ENDIF                                                  IF INVALID
      *
     C                   ENDSL
      *
     C                   ENDSR
      /EJECT
      *----------------------------------------------------------------
      * EDIT SHIPPED DATE
      *----------------------------------------------------------------
      *
     C     $SHDT         BEGSR
      *
     C                   SELECT
     C     C1SMDY        WHENEQ    0
     C     C1MSCD        ANDEQ     'SH'
     C                   SETON                                        38
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVE      'HS00599'     MGID(E)
     C                   ENDIF
     C                   OTHER
      *
      * VALIDATE THAT THE SHIPPED DATE IS VALID AND ADD CENTURY VALUES
      * TO THE WORK FIELD FOR LATER USE IN THE UPDATING ROUTINE.
      *
     C                   Z-ADD     C1SMDY        PFRM8
     C                   Z-ADD     0             PTO8
     C                   MOVEL     'MDY '        PFRFMT
     C                   MOVEL     'CYMD'        PTOFMT
     C                   Z-ADD     0             PDAYS
     C                   MOVE      *BLANK        PCODE
     C                   MOVE      *BLANK        PRTRN
      *
     C                   EXSR      $DATE
      *
     C     PRTRN         IFNE      *BLANK                                       IF INVALID
     C                   SETON                                        38
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVE      'HS09004'     MGID(E)
     C                   ENDIF
     C                   ELSE
     C                   Z-ADD     PTO8          WKSHDT
     C                   ENDIF                                                  IF INVALID
      *
      * IF THE DATE IS VALID,
      *     CHECK THAT IT IS NOT GREATER THAN TODAY'S DATE
      *
     C     *IN38         IFEQ      *OFF                                         IF GOOD DATE
      *
     C                   SELECT
     C     WKSHDT        WHENGT    WKUDAT
     C                   SETON                                        38
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS00426'     MGID(E)
     C                   ENDIF
     C                   ENDSL
      *
     C                   ENDIF                                                  IF GOOD DATE
     C                   ENDSL
      *
     C                   ENDSR
      /EJECT
      *----------------------------------------------------------------
      * EDIT TIME
      *----------------------------------------------------------------
      *
     C     $TIME         BEGSR
      *
     C                   MOVEL     NO            WKTMFL
      *
     C                   SELECT
      *
      * TIME CAN NEVER BE NEGATIVE
      *
     C     WKHHMM        WHENLT    0
     C                   MOVEL     YES           WKTMFL
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS09000'     MGID(E)
     C                   ENDIF
      *
      * INVALID HOURS AND MINUTES
      *
     C     WKMIN         WHENGT    59
     C     WKHOUR        ANDGT     24
     C                   MOVEL     YES           WKTMFL
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS09025'     MGID(E)
     C                   ENDIF
      *
      * MINUTES CAN NEVER BE GREATER THAN 59
      *
     C     WKMIN         WHENGT    59
     C                   MOVEL     YES           WKTMFL
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS09024'     MGID(E)
     C                   ENDIF
      *
      * HOURS CAN NEVER BE GREATER THAN 24
      *
     C     WKHOUR        WHENGT    24
     C                   MOVEL     YES           WKTMFL
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS09023'     MGID(E)
     C                   ENDIF
      *
      * TIME CAN NEVER BE GREATER THAN MIDNIGHT
      *
     C     WKHHMM        WHENGT    2400
     C                   MOVEL     YES           WKTMFL
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS09022'     MGID(E)
     C                   ENDIF
      *
     C                   ENDSL
      *
      *  SET THE ERROR INDICATOR FOR THE APPROPRIATE TIME FIELD
      *
     C     WKTMFL        IFEQ      YES
     C                   SELECT
     C     WKTIME        WHENEQ    'SI'
     C                   SETON                                        35
     C     WKTIME        WHENEQ    'SO'
     C                   SETON                                        34
     C     WKTIME        WHENEQ    'RI'
     C                   SETON                                        40
     C     WKTIME        WHENEQ    'RO'
     C                   SETON                                        41
     C                   ENDSL
     C                   ENDIF
      *
     C                   ENDSR
      /EJECT
      *----------------------------------------------------------------
      * EDIT RECEIVED DATE
      *----------------------------------------------------------------
      *
     C     $RCDT         BEGSR
      *
     C                   SELECT
     C     C1RMDY        WHENEQ    0
     C     C1MSCD        ANDEQ     'SH'
     C                   SETON                                        39
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVE      'HS00605'     MGID(E)
     C                   ENDIF
     C                   OTHER
      *
      * VALIDATE THAT THE RECEIVED DATE IS VALID AND ADD CENTURY VALUES
      * TO THE WORK FIELD FOR LATER USE IN THE UPDATING ROUTINE.
      *
     C                   Z-ADD     C1RMDY        PFRM8
     C                   Z-ADD     0             PTO8
     C                   MOVEL     'MDY '        PFRFMT
     C                   MOVEL     'CYMD'        PTOFMT
     C                   Z-ADD     0             PDAYS
     C                   MOVE      *BLANK        PCODE
     C                   MOVE      *BLANK        PRTRN
      *
     C                   EXSR      $DATE
      *
     C     PRTRN         IFNE      *BLANK                                       IF INVALID
     C                   SETON                                        39
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVE      'HS09004'     MGID(E)
     C                   ENDIF
     C                   ELSE
     C                   Z-ADD     PTO8          WKRCDT
     C                   ENDIF                                                  IF INVALID
      *
      * IF THE DATE IS VALID,
      *     CHECK THAT IT IS NOT GREATER THAN TODAY'S DATE
      *     CHECK THAT IT IS NOT LESS THAN THE SHIPPED DATE
      *
     C     *IN39         IFEQ      *OFF                                         IF GOOD DATE
      *
     C                   SELECT
     C     WKRCDT        WHENGT    WKUDAT
     C                   SETON                                        39
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS00426'     MGID(E)
     C                   ENDIF
      *
     C     WKRCDT        WHENLT    WKSHDT
     C     *IN38         ANDEQ     *OFF
     C                   SETON                                        39
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS09015'     MGID(E)
     C                   ENDIF
     C                   ENDSL
      *
     C                   ENDIF                                                  IF GOOD DATE
     C                   ENDSL
      *
     C                   ENDSR
      /EJECT
      *---------------------------------------------------------------
      * SUBROUTINE TO CLEAR THE SUBFILE ON SCREEN 1
      *---------------------------------------------------------------
      *
     C     $CLR1         BEGSR
      *
      *
      * CLEAR CONTROL RECORD ACCUMULATORS
      *
     C                   Z-ADD     0             C1SCHD
     C                   Z-ADD     0             C1SHHD
     C                   Z-ADD     0             C1ARHD
     C                   Z-ADD     0             C1RCHD
     C                   Z-ADD     0             C1DOHD
      *
     C                   Z-ADD     0             C1SHLB
     C                   Z-ADD     0             C1AVSHLB
     C                   Z-ADD     0             C1ARLB
     C                   Z-ADD     0             C1AVARLB
     C                   Z-ADD     0             C1RCLB
     C                   Z-ADD     0             C1DOLB
      *
      * CLEAR WORKFIELD ACCUMULATORS
      *
     C                   Z-ADD     0             WKSCHD
     C                   Z-ADD     0             WKSHHD
     C                   Z-ADD     0             WKARHD
     C                   Z-ADD     0             WKQLHD
     C                   Z-ADD     0             WKRJHD
     C                   Z-ADD     0             WKDOHD
      *
     C                   Z-ADD     0             HDRRN1
     C                   Z-ADD     0             COUNT
     C                   Z-ADD     0             WKLNNO
      *
      * CLEAR ACCUMULATORS THAT HOLD TOTALS FOR A MOVEMENT
      * ASSOCIATED WITH PROTECTED SUBFILE LINES.
      *
     C                   Z-ADD     0             SVSHHD
     C                   Z-ADD     0             SVARHD
     C                   Z-ADD     0             SVQLHD
     C                   Z-ADD     0             SVRJHD
     C                   Z-ADD     0             SVDOHD
      *
     C                   Z-ADD     0             SVSHLB
     C                   Z-ADD     0             SVARLB
     C                   Z-ADD     0             SVRCLB
     C                   Z-ADD     0             SVDOLB
      *
     C                   CLEAR                   HP186S1
     C                   SETON                                        83        SFLCLR
     C                   WRITE     HP186C1
     C                   SETOFF                                       818283
      *                                                    81=SFLDSP
      *                                                    82=SFLEND
      *                                                    83=SFLCLR
     C                   ENDSR
      /EJECT
      *---------------------------------------------------------------
      * SUBROUTINE TO REFRESH/FILL THE SUBFILE ON SCREEN 1
      *---------------------------------------------------------------
      *
     C     $FRSH1        BEGSR
      *
      *
      * SET INDICATORS TO CONTROL/PROTECT SCREEN FIELDS
      * IN SUBFILE AND ON CONTROL RECORD.
      *
     C                   EXSR      $SFIND
     C                   EXSR      $C1IND
      *
      *
      * LOADING THE SUBFILE IN THIS PROGRAM IS DIFFERENT THAN IN THE
      * SHELL PROGRAMS AND DEPENDS ON THE 'MODE'.
      * FOR REVISE MODE, WE LOAD A PAGE OF DATABASE RECORDS AND, IF WE
      *                  HIT EOF, WE FINISH THE PAGE WITH BLANK LINES.
      *
     C                   SELECT
     C     MODE          WHENEQ    REVISE
     C     C1MVSN        SETLL     HSP075
     C     *IN82         DOUEQ     *ON
     C                   EXSR      $LOAD1
     C                   ENDDO
      *
      * CALCULATE ARRIVED HEAD AND POUNDS:
      *    = (QUALITY + REJECTED) + DEAD
      *    = RECEIVED + DEAD
      *
     C     C1RCHD        ADD       C1DOHD        C1ARHD
     C     C1RCLB        ADD       C1DOLB        C1ARLB
      *
      * Calculate average arrived pounds to show in control record as a visual
      * check for user that arrived pounds value is realistic.
      *
     C                   z-add     0             c1avarlb
     C                   if        c1arhd <> 0
     C     c1arlb        div(h)    c1arhd        c1avarlb
     C                   endif
      *
      *
      * Calculate average shipped pounds to show in control record as a visual
      * check for user that shipped pounds value is realistic.
      *
     c                   z-add     0             c1avshlb
     C                   if        c1shhd <> 0
     C     c1shlb        div(h)    c1shhd        c1avshlb
     C                   endif
      *
      *
      * FILL UP THE SUBFILE PAGE WITH BLANK LINES IF NECESSARY
      *
     C     WKPLIN        IFNE      0
     C     WKPLIN        ANDNE     COUNT
     C     COUNT         DIV       WKPLIN        WKFLD
     C                   MVR                     WKRMDR
     C     WKPLIN        SUB       WKRMDR        WKDIFF
     C                   EXSR      $CLRLN
     C                   EXSR      $SETOF
     C                   DO        WKDIFF
     C                   EXSR      $BLANK
     C                   ENDDO
     C                   ENDIF
      *
     C                   ENDSL
      *
     C                   ENDSR
      /EJECT
      *---------------------------------------------------------------
      * SETUP THE TRANSFER HEADER DATA FOR THE CONTROL RECORD
      *---------------------------------------------------------------
      *
     C     $HDR          BEGSR
      *
     C                   MOVEL     MHMSCD        C1MSCD
     C                   Z-ADD     MHORFS        c1orfscd
     C                   Z-ADD     MHDNFS        c1dnfscd
     C                   Z-ADD     MHSITM        C1SITM
     C                   Z-ADD     MHSOTM        C1SOTM
     C                   Z-ADD     MHRITM        C1RITM
     C                   Z-ADD     MHROTM        C1ROTM
     C                   MOVEL     MHTICD        C1TICD
      *
      * RETRIEVE ORIGIN FARM SITE NAME
      *
     C     c1orfscd      CHAIN     HSP018                             92
     C     *IN92         IFEQ      *OFF
     C                   MOVEL     FSFSNM        c1orfsnm
     C                   ELSE
     C                   MOVEL(P)  'UNKNOWN'     c1orfsnm
     C                   ENDIF
      *
      * RETRIEVE DESTINATION FARM SITE NAME
      *
     C     c1dnfscd      CHAIN     HSP018                             92
     C     *IN92         IFEQ      *OFF
     C                   MOVEL     FSFSNM        c1dnfsnm
     C                   ELSE
     C                   MOVEL(P)  'UNKNOWN'     c1dnfsnm
     C                   ENDIF
      *
      * FLIP SCHEDULED SHIP DATE TO MDY FORMAT
      *
     C                   Z-ADD     MHSCDT        WKCYMD
     C                   EXSR      $TOMDY
     C                   Z-ADD     WKMDY         C1MDY
      *
      * FLIP SHIPPED DATE TO MDY FORMAT
      *
     C                   Z-ADD     MHSHDT        WKCYMD
     C                   EXSR      $TOMDY
     C                   Z-ADD     WKMDY         C1SMDY
      *
      * FLIP RECEIVED DATE TO MDY FORMAT
      *
     C                   Z-ADD     MHRCDT        SVRCDT
     C                   Z-ADD     MHRCDT        WKCYMD
     C                   EXSR      $TOMDY
     C                   Z-ADD     WKMDY         C1RMDY
      *
     C                   ENDSR
      /EJECT
      *---------------------------------------------------------------
      * SUBROUTINE TO LOAD THE SUBFILE ON SCREEN 1
      *---------------------------------------------------------------
      *
     C     $LOAD1        BEGSR
      *
      *  RETRIEVE TRANSFER DETAIL RECORDS FOR THE TRANSFER MOVEMENT.
      *
     C     C1MVSN        READE(N)  HSP075                                 82
     C     *IN82         IFEQ      *OFF                                         IF NOT EOF
     C                   SETON                                        85
      *
      * CLEAR FIELDS IN SUBFILE LINE
      *
     C                   EXSR      $CLRLN
      *
      * ACCUMULATE HEAD VALUES FOR CONTROL RECORD
      *
     C                   ADD       MDSCHD        C1SCHD
     C                   ADD       MDSHHD        C1SHHD
     C                   ADD       MDQLHD        C1RCHD
     C                   ADD       MDRJHD        C1RCHD
     C                   ADD       MDDOHD        C1DOHD
      *
      * ACCUMULATE POUNDS VALUES FOR CONTROL RECORD
      *
     C                   ADD       MDSHLB        C1SHLB
     C                   ADD       MDQLLB        C1RCLB
     C                   ADD       MDRJLB        C1RCLB
     C                   ADD       MDDOLB        C1DOLB
      *
      * SET UP LINE NUMBER FIELDS--A WORKFIELD IN CASE YOU HAVE TO
      * FILL THE REST OF THE PAGE WITH BLANK LINES--AND THE HIDDEN
      * FIELD ON THE SUBFILE RECORD.
      *
     C                   Z-ADD     MDLNNO        WKLNNO
     C                   Z-ADD     MDLNNO        HDLNNO
      *
     C                   Z-ADD     MDORSN        hdorhgsn
     C                   Z-ADD     MDDNSN        hddnhgsn
      *
     C                   Z-ADD     MDSCHD        DFSCHD
     C                   Z-ADD     MDSHHD        DFSHHD
     C                   Z-ADD     MDQLHD        DFQLHD
     C                   Z-ADD     MDRJHD        DFRJHD
     C                   Z-ADD     MDKOAHD       DFKOAHD
     C                   Z-ADD     MDDOAHD       DFDOAHD
      *
      * RETRIEVE ALPHA HOG GROUP CODES AND GROUP STATUS
      *
     C                   EXSR      $GRPCD
      *
      * RESET SUBFILE INDICATORS
      *
     C                   EXSR      $SETOF
     C                   EXSR      $SFIND
      *
     C                   ADD       1             COUNT
     C                   ADD       1             HDRRN1
     C                   MOVE      *BLANK        DFOPT
      *
     C                   WRITE     HP186S1
     C                   SETON                                        81
     C                   Z-ADD     HDRRN1        HDPAG1
     C                   ENDIF                                                  IF NOT EOF
      *
     C                   ENDSR
      /EJECT
      *---------------------------------------------------------------
      * $BLANK- SUBROUTINE TO LOAD BLANK SUBFILE RECORDS FOR SCREEN 1
      *---------------------------------------------------------------
      *
     C     $BLANK        BEGSR
      *
     C                   EXSR      $SFIND
      *
     C                   ADD       1             WKLNNO
     C                   Z-ADD     WKLNNO        HDLNNO
      *
     C                   ADD       1             COUNT
     C                   ADD       1             HDRRN1
      *
     C                   EXSR      $SFIND
     C                   WRITE     HP186S1
      *
     C                   SETON                                        81
     C                   Z-ADD     HDRRN1        HDPAG1
      *
     C                   ENDSR
      /EJECT
      *---------------------------------------------------------------
      * CLEAR SUBFILE LINE
      *---------------------------------------------------------------
      *
      * THIS SUBROUTINE INITIALIZES THE FIELDS IN THE SUBFILE RECORD
      *
     C     $CLRLN        BEGSR
      *
      * ORIGIN
     C                   MOVE      *BLANK        DFORBLCD
     C                   MOVE      *BLANK        DFORRMCD
     C                   MOVE      *BLANK        dforhgcd
     C                   Z-ADD     0             DFSCHD
     C                   Z-ADD     0             DFSHHD
     C                   MOVE      *BLANK        dforgscd
     C                   MOVE      *BLANK        dforptcd
     C                   MOVE      *BLANK        dforppcd
      *
     C                   Z-ADD     0             hdorhgsn
     C                   Z-ADD     0             HDSHLB
      *
      * DESTINATION
     C                   MOVE      *BLANK        DFOPT
     C                   MOVE      *BLANK        DFDNBLCD
     C                   MOVE      *BLANK        DFDNRMCD
     C                   MOVE      *BLANK        dfdnhgcd
     C                   Z-ADD     0             DFQLHD
     C                   Z-ADD     0             DFRJHD
     C                   Z-ADD     0             dfkoahd
     C                   Z-ADD     0             dfdoahd
     C                   MOVE      *BLANK        dfdngscd
     C                   MOVE      *BLANK        dfdnptcd
     C                   MOVE      *BLANK        dfdnppcd
      *
     C                   Z-ADD     0             hddnhgsn
     C                   Z-ADD     0             HDQLLB
     C                   Z-ADD     0             HDRJLB
     C                   Z-ADD     0             HDDOLB
      *
      *
     C                   ENDSR
      /EJECT
      *---------------------------------------------------------------
      * REWRITE THE SUBFILE RECORDS WITH THE INDICATORS OFF
      *---------------------------------------------------------------
      *
      * THIS SUBROUTINE KEEPS THE CURSOR FROM BEING IN THE SUBFILE
      * WHILE THE DISPLAYED ERROR MESSAGE IS FOR THE CONTROL RECORD.
      *
     C     $OFFIN        BEGSR
      *
      * READ/PROCESS ALL THE CHANGED SUBFILE RECORDS
      *
     C                   SETOFF                                       80
     C     *IN80         DOUEQ     *ON                                          DO PROCESS
     C                   READC     HP186S1                                80
     C     *IN80         IFEQ      *OFF                                         IF REC READ
      *
      * SETON MDT
     C                   SETON                                        85
      *
      * SET OFF THE ERROR INDICATORS IN THE SUBFILE
      * AND THEN RESET SUBFILE INDICATORS
      *
     C                   EXSR      $SETOF
     C                   EXSR      $SFIND
      *
     C                   UPDATE    HP186S1
     C                   ENDIF                                                  IF REC READ
     C                   ENDDO                                                  DO PROCESS
      * SET MDT
     C                   SETOFF                                       85
      *
     C                   ENDSR
      /EJECT
      *------------------------------------------------------------------
      * SUBROUTINE TO READ AND EDIT CHANGED SUBFILE RECORDS FOR SCREEN 1
      *------------------------------------------------------------------
      *
     C     $EDS1         BEGSR
      *
      * CLEAR THE OUTPUT ONLY ACCUMULATORS IN CONTROL RECORD
      *
     C                   Z-ADD     0             C1DOHD
     C                   Z-ADD     0             C1DOLB
     C                   Z-ADD     0             C1RCHD
     C                   Z-ADD     0             C1RCLB
      *
      * CLEAR WORKFIELD ACCUMULATORS
      *
     C                   Z-ADD     0             WKSCHD
     C                   Z-ADD     0             WKSHHD
     C                   Z-ADD     0             WKARHD
     C                   Z-ADD     0             WKQLHD
     C                   Z-ADD     0             WKRJHD
     C                   Z-ADD     0             WKDOHD
      *
      * SET THE FLAG THAT WILL DETERMINE WHETHER THE USER KEYED
      * ANY SUBFILE ENTRIES.
      *
     C                   MOVEL     NO            ENTRFL
      *
     C                   move      *blank        svorptcd
     C                   move      *blank        svorppcd
      *
     C                   move      *blank        svdnptcd
     C                   move      *blank        svdnppcd
      *
      * READ/PROCESS ALL THE CHANGED SUBFILE RECORDS
      *
     C                   SETOFF                                       80
     C     *IN80         DOUEQ     *ON                                          DO PROCESS
     C                   READC     HP186S1                                80
     C     *IN80         IFEQ      *OFF                                         IF REC READ
      *
      * SETON MDT
     C                   SETON                                        85
      *
      * SET OFF THE ERROR INDICATORS IN THE SUBFILE
      *
     C                   EXSR      $SETOF
      *
      * IF THERE ARE NO USER ENTRIES FOR THE CHANGED SUBFILE RECORD,
      * CLEAR ALL FIELDS ON THE LINE AND ALSO DELETE ANY REJECTED
      * HEAD REASONS THAT MAY EXIST FOR THIS MOVEMENT LINE.
      *
     C     DFORBLCD      IFEQ      *BLANK                                       IF ENTRY
     C     DFORRMCD      ANDEQ     *BLANK
     C     dforhgcd      ANDEQ     *BLANK
     C     DFSCHD        ANDEQ     0
     C     DFSHHD        ANDEQ     0
     C     DFOPT         ANDEQ     *BLANK
     C     DFDNBLCD      ANDEQ     *BLANK
     C     DFDNRMCD      ANDEQ     *BLANK
     C     dfdnhgcd      ANDEQ     *BLANK
     C     DFQLHD        ANDEQ     0
     C     DFRJHD        ANDEQ     0
     C     dfkoahd       ANDEQ     0
     C     dfdoahd       ANDEQ     0
     C                   EXSR      $CLRLN
     C                   EXSR      $DLTLR
     C                   ELSE
      *
      * ACCUMULATE QUALITY AND REJECTED VALUES INTO RECEIVED FIELDS
      *
     C                   ADD       DFQLHD        C1RCHD
     C                   ADD       DFRJHD        C1RCHD
     C                   ADD       dfkoahd       C1DOHD
     C                   ADD       dfdoahd       C1DOHD
      *
      * ACCUMULATE SCHEDULED AND SHIPPED HEAD INTO WORKFIELDS FOR
      * COMPARISON WITH THE TOTAL VALUES KEYED BY THE USER
      *
     C                   ADD       DFSCHD        WKSCHD
     C                   ADD       DFSHHD        WKSHHD
     C                   ADD       DFQLHD        WKQLHD
     C                   ADD       DFRJHD        WKRJHD
     C                   ADD       dfkoahd       WKDOHD
     C                   ADD       dfdoahd       WKDOHD
      *
      * ACCUMULATE DESTINATION HEAD INTO A WORKFIELD FOR COMPARISON
      * WITH THE ARRIVED HEAD VALUE THE USER KEYED IN THE HEADER
      *
     C                   ADD       DFQLHD        WKARHD
     C                   ADD       DFRJHD        WKARHD
     C                   ADD       dfkoahd       WKARHD
     C                   ADD       dfdoahd       WKARHD
      *
     C                   MOVEL     YES           ENTRFL
     C                   MOVEL     YES           LNOKFL
      *
      *
      * The user must at least enter an origin building or group. If neither are
      * entered, issue message; otherwise, validate and attempt to retrieve/
      * default in the missing values.
      *
     C                   if        dforblcd = *blank and                        If no origin bld/grp
     C                             dforhgcd = *blank
     C                   seton                                        4547
     C                   if        error < maxmsg
     C                   add       1             error
     C                   movel     'HS09132'     mgid(e)
     C                   exsr      $err1
     C                   endif
     C                   else
      *
     C                   exsr      $edorigin
     C                   endif                                                  If no origin bld/grp
      *
      *
      * The user must at least enter a destination building or group. If neither
      * are entered, issue message; otherwise, validate and attempt to retrieve/
      * default in the missing values.
      *
     C                   if        dfdnblcd = *blank and                        If no destination
     C                             dfdnhgcd = *blank
     C                   seton                                        4675
     C                   if        error < maxmsg
     C                   add       1             error
     C                   movel     'HS09132'     mgid(e)
     C                   exsr      $err1
     C                   endif
     C                   else
      *
      * Perform destination edits
      *
     C                   exsr      $eddest
     C                   endif                                                  If no destination
      *
     C                   ENDIF                                                  IF ENTRY
      *
      *
      * If user wanted to enter Reject Reasons and there were no errors on the
      * subfile line, then call the program to enter Reject Reasons.
      *
     C     DFOPT         IFEQ      ' 2'
     C     LNOKFL        ANDEQ     YES
     C                   CALL      'HP149'
     C                   PARM                    C1MVSN
     C                   PARM                    HDLNNO
     C                   PARM                    c1dnfscd
     C                   PARM                    c1dnfsnm
     C                   PARM                    dfdnhgcd
     C                   PARM                    DFRJHD
     C                   PARM                    RTNCD
     C                   MOVE      *BLANK        DFOPT
     C                   ENDIF
      *
      *
      * RESET INDICATORS
      *
     C                   EXSR      $SFIND
     C                   UPDATE    HP186S1
     C                   EXSR      $SETOF
     C                   ENDIF                                                  IF REC READ
     C                   ENDDO                                                  DO PROCESS
      * SET MDT
     C                   SETOFF                                       85
      *
      *---------------------------------------------------------------
      * AFTER ALL SUBFILE RECORDS HAVE BEEN EDITED,
      * ISSUE AN ERROR MESSAGE IF THERE ARE NO SUBFILE ENTRIES
      *---------------------------------------------------------------
      *
     C     ENTRFL        IFEQ      NO                                           IF NO ENTRY
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS00593'     MGID(E)
     C                   ENDIF
     C                   ENDIF                                                  IF NO ENTRY
      *
      * IF THERE ARE NO ERRORS ON THE SUBFILE, CHECK THAT THE
      * ACCUMULATED HEAD VALUES MATCH THE USER-KEYED VALUES.
      *
     C                   if        error = 0 or error = warmsg                  IF NO ERROR
      *
     C     C1SCHD        IFNE      WKSCHD                                       IF NE SCHED
     C                   SETON                                        79
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS00624'     MGID(E)
     C                   CLEAR                   MGW
     C                   MOVE      C1SCHD        XXHD
     C                   MOVEA     XXHD          MGW(1)
     C                   MOVE      WKSCHD        XXHD6
     C                   MOVEA     XXHD6         MGW(6)
     C                   MOVEA     MGW           MGDT(E)
     C                   ENDIF
     C                   ENDIF                                                  IF NE SCHED
      *
     C     C1SHHD        IFNE      WKSHHD                                       IF NE SHIP
     C                   SETON                                        36
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS00625'     MGID(E)
     C                   CLEAR                   MGW
     C                   MOVE      C1SHHD        XXHD
     C                   MOVEA     XXHD          MGW(1)
     C                   MOVE      WKSHHD        XXHD6
     C                   MOVEA     XXHD6         MGW(6)
     C                   MOVEA     MGW           MGDT(E)
     C                   ENDIF
     C                   ENDIF                                                  IF NE SHIP
      *
     C     C1ARHD        IFNE      WKARHD                                       IF NE ARRIVE
     C                   SETON                                        72
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS00626'     MGID(E)
     C                   CLEAR                   MGW
     C                   MOVE      C1ARHD        XXHD
     C                   MOVEA     XXHD          MGW(1)
     C                   MOVE      WKARHD        XXHD6
     C                   MOVEA     XXHD6         MGW(6)
     C                   MOVEA     MGW           MGDT(E)
     C                   ENDIF
     C                   ENDIF                                                  IF NE ARRIVE
     C                   ENDIF                                                  IF NO ERROR
      *
      *----------------------------------------------------------------
      * IF THE SUBFILE STILL HAS NO ERRORS, DISTRIBUTE THE 'ARRIVED'
      * POUNDS KEYED IN BY THE USER TO THE CONTROL RECORD FIELDS FOR
      * 'RECEIVED' POUNDS AND 'DOA' POUNDS.
      *----------------------------------------------------------------
      *
     C                   if        error = 0 or error = warmsg                  IF ALL OK
      *
      * CALCULATE AVERAGE ARRIVED POUNDS TO DISTRIBUTE. (NOTE:
      * THIS AVERAGE WILL EXCLUDE VALUES FROM PROTECTED RECORDS.)
      *
     C                   EXSR      $DSTAR
      *
      * REDUCE THE 'QUALITY' HEAD BY THE NUMBER OF QUALITY HEAD
      * ASSOCIATED WITH PROTECTED RECORDS. THEN, CALCULATE THE
      * QUALITY POUNDS ASSOCATED WITH DESTINATION GROUPS THAT ARE
      * NOT PROTECTED.
      *
     C     WKQLHD        SUB       SVQLHD        WKHD
     C     WKHD          MULT(H)   WKAALB        WKLB
     C                   ADD       WKLB          C1RCLB
      *
      * REDUCE THE 'REJECTED' HEAD BY THE NUMBER OF 'REJECTED' HEAD
      * ASSOCIATED WITH PROTECTED RECORDS. THEN, CALCULATE THE
      * 'REJECTED' POUNDS ASSOCATED WITH DESTINATION GROUPS THAT ARE
      * NOT PROTECTED.
      *
     C     WKRJHD        SUB       SVRJHD        WKHD
     C     WKHD          MULT(H)   WKAALB        WKLB
     C                   ADD       WKLB          C1RCLB
      *
      * REDUCE THE 'DEAD' HEAD BY THE NUMBER OF 'DEAD' HEAD
      * ASSOCIATED WITH PROTECTED RECORDS. THEN, CALCULATE THE
      * 'DEAD' POUNDS ASSOCATED WITH DESTINATION GROUPS THAT ARE
      * NOT PROTECTED.
      *
     C     WKDOHD        SUB       SVDOHD        WKHD
     C     WKHD          MULT(H)   WKAALB        WKLB
     C                   ADD       WKLB          C1DOLB
      *
      * DETERMINE IF THERE ARE ANY REMAINING ARRIVED POUNDS TO
      * DISTRIBUTE.
      *
     C     C1RCLB        ADD       C1DOLB        WKLB
     C     WKARLB        SUB       WKLB          WKLB
      *
      * DISTRIBUTE DIFFERENCE
      *
     C     WKLB          IFNE      0
     C                   SELECT
     C     C1RCLB        WHENNE    0
     C                   ADD       WKLB          C1RCLB
     C                   OTHER
     C                   ADD       WKLB          C1DOLB
     C                   ENDSL
     C                   ENDIF
      *
      * ADD BACK IN THE POUNDS SAVED FROM PROTECTED RECORDS--
      * WHICH WERE SUBTRACTED OUT PRIOR TO CALCULATING THE AVERAGE.
      *
     C                   ADD       SVRCLB        C1RCLB
     C                   ADD       SVDOLB        C1DOLB
      *
      *
      * Issue a warning message when Shipped Pounds does not equal Arrived Pounds.
      *
     C                   if        c1shlb <> c1arlb
     c                   seton                                        3773
     C                   if        error < maxmsg
     C                   add       1             error
     C                   add       1             warmsg
     C                   movel     'HS00341'     mgid(e)
     C                   endif
     C                   endif
      *
      * Issue warning messages when the origin phase is:
      *  1) BGF and the average arrived pounds are over 20
      *  2) Nursery and the average arrived pounds are over 90
      *  3) Grow finish and the average arrived pounds are over 450
      *
     C                   select
     C                   when      svorppcd = 'BGF  ' and
     C                             (c1avarlb < 10 or c1avarlb > 20)
     C                   seton                                        68
     C                   if        error < maxmsg
     C                   add       1             error
     C                   add       1             warmsg
     C                   movel     'HS00344'     mgid(e)
     C                   endif
      *
     C                   when      svorppcd = 'NUR  ' and c1avarlb > 90
     C                   seton                                        68
     C                   if        error < maxmsg
     C                   add       1             error
     C                   add       1             warmsg
     C                   movel     'HS00345'     mgid(e)
     C                   endif
      *
     C                   when      svorppcd = 'GF   ' and c1avarlb > 450
     C                   seton                                        68
     C                   if        error < maxmsg
     C                   add       1             error
     C                   add       1             warmsg
     C                   movel     'HS00346'     mgid(e)
     C                   endif
     C                   endsl
      *
     C                   ENDIF                                                  IF ALL OK
      *
     C                   ENDSR
      /EJECT
      *----------------------------------------------------------------
      * Edits for origin entries
      *----------------------------------------------------------------
      *
     C     $edorigin     begsr
      *
      * Validate:
      *  1) Building
      *  2) Room
      *  3) Hog group
      *
     C                   exsr      $orblcd
      *
      * Edit room if a) it is not blank and b) it was not edited previously
      * in the logic that attempted to default a group for a building.
      * (The check on indicator 47 keeps you from issuing a second invalid
      * room message.)
      *
     C                   if        dforrmcd <> *blank and *in47 = *off
     C                   exsr      $orrmcd
     C                   endif
      *
     C                   exsr      $orhgcd
      *
      *
      * VALIDATE SCHEDULED HEAD
      *
     C     DFSCHD        IFLT      0
     C                   SETON                                        74
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS09000'     MGID(E)
     C                   EXSR      $ERR1
     C                   ENDIF
     C                   ENDIF
      *
      * VALIDATE SHIPPED HEAD
      *
     C                   SELECT
     C     DFSHHD        WHENLT    0
     C                   SETON                                        71
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS09000'     MGID(E)
     C                   EXSR      $ERR1
     C                   ENDIF
      *
     C     DFSHHD        WHENEQ    0
     C     C1MSCD        ANDEQ     'SH'
     C                   SETON                                        71
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS00630'     MGID(E)
     C                   EXSR      $ERR1
     C                   ENDIF
     C                   ENDSL
      *
      *
      * If you have valid Shipped head, make sure that distributed Shipped Pounds
      * will not truncate.
      *
     C                   if        dfshhd > 0 and *in71 = *off                  If shipped
     C     dfshhd        mult      c1avshlb      wktrunlb
     C                   if        wktrunlb > 99999                             If truncated
     C                   seton                                        71
     C                   if        error < maxmsg
     C                   add       1             error
     C                   movel     'HS09072'     mgid(e)
     C                   exsr      $err1
     C                   endif
     C                   endif                                                  If truncated
     C                   endif                                                  If good shipped
      *
      *
     C                   endsr
      /EJECT
      *----------------------------------------------------------------
      * Validate origin building
      *----------------------------------------------------------------
      *
     C     $orblcd       begsr
      *
      * If building is blank and hog group is entered, default building and
      * room from hog group.
      *
     C                   if        dforblcd = *blank and dforhgcd <> *blank
     C     dforhgcd      chain     hsp034                             92
     C                   if        *in92 = *off
     C                   move      hgblcd        dforblcd
     C                   move      hgrmcd        dforrmcd
     C                   endif
     C                   endif
      *
      * Validations:
      *  1) building is required
      *  2) building must exist on the specified farm site
      *
     C                   select
     C                   when      dforblcd = *blank
     C                   seton                                        45
     C                   if        error < maxmsg
     C                   add       1             error
     C                   exsr      $err1
     C                   eval      mgid(e) = 'HS09001'
     C                   endif
     C                   other
      *
     C     key01         chain     hsp019                             92
     C                   if        *in92 = *on                                  If not found
     C                   seton                                        45
     C                   if        error < maxmsg
     C                   add       1             error
     C                   exsr      $err1
     C                   eval      mgid(e) = 'HS00116'
     C                   clear                   mgw
     C                   movea     dforblcd      mgw(1)
     C                   move      c1orfscd      xxalphfscd
     C                   movea     xxalphfscd    mgw(6)
     C                   movea     mgw           mgdt(e)
     C                   endif
     C                   endif                                                  If not found
     C                   endsl
      *
      * Attempt to default in a group when:
      *   1) building is valid and group is blank and
      *   2) room is blank or valid
      *
     C                   if        *in45 = *off and dforhgcd = *blank             If valid building
      *
     C                   if        dforrmcd <> *blank
     C                   exsr      $orrmcd
     C                   endif
      *
     C                   if        *in47 = *off                                 If room OK/blank
     C                   exsr      $orgroup
     C                   endif                                                  If room OK/blank
     C                   endif                                                  If valid building
      *
     C                   endsr
      /EJECT
      *----------------------------------------------------------------
      * Validate origin room
      *----------------------------------------------------------------
      *
      * Validations:
      *  1) required
      *  2) must exist in the building on the farm site
      *  3) must have an active status
      *
     C     $orrmcd       begsr
      *
     C                   select
     C                   when      dforrmcd = *blank
     C                   seton                                        47
     C                   if        error < maxmsg
     C                   add       1             error
     C                   exsr      $err1
     C                   eval      mgid(e) = 'HS09001'
     C                   endif
     C                   other
      *
      * Check that the room exists in the building on the farm site
     *
     C     key02         chain     hsp020                             92
     C                   if        *in92 = *on                                  If no hit
     C                   seton                                        47
     C                   if        error < maxmsg
     C                   add       1             error
     C                   exsr      $err1
     C                   eval      mgid(e) = 'HS00117'
     C                   clear                   mgw
     C                   movea     dforrmcd      mgw(1)
     C                   movea     dforblcd      mgw(6)
     C                   move      c1orfscd      xxalphfscd
     C                   movea     xxalphfscd    mgw(11)
     C                   movea     mgw           mgdt(e)
     C                   endif
     C                   else
     *
      * Room must have an 'active' status
     *
     C                   if        brrmst <> 'A'                                If not active
     C                   seton                                        47
     C                   if        error < maxmsg
     C                   add       1             error
     C                   exsr      $err1
     C                   eval      mgid(e) = 'HS00726'
     C                   clear                   mgw
     C                   movea     dforrmcd      mgw(1)
     C                   movea     mgw           mgdt(e)
     C                   endif
     C                   endif                                                  If not active
     C                   endif                                                  If no hit
      *
     C                   endsl
      *
     C                   endsr
      /eject
      *--------------------------------------------------------------------
      * Attempt to find a default group in the origin building
      *--------------------------------------------------------------------
      *
      * If only one group is open in that building or building/room, default
      * it in. But, if multiple groups are open, issue a message to the
      * user to select a group.
      *
     C     $orgroup      begsr
      *
      * Key with either a) farm/building if room is blank or b) farm/
      * building/room if room is populated.
      *
     C                   if        dforrmcd = *blank
     C     key01         chain     hsl034p                            92
     C                   else
     C     key02         chain     hsl034p                            92
     C                   endif
      *
     C                   if        *in92 = *off                                 If open group
      *
      * Check to see if there is another open group.
      * Key with either a) farm/building if room is blank or b) farm/
      * building/room if room is populated.
      *
     C                   if        dforrmcd = *blank
     C     key01         reade     hsl034p                                92
     C                   else
     C     key02         reade     hsl034p                                92
     C                   endif
      *
     C                   if        *in92 = *off                                 If mult group
     C                   seton                                        44
     C                   if        error < maxmsg
     C                   add       1             error
     C                   clear                   mgw
     C                   movea     dforblcd      mgw(1)
      *
     C                   select
     C                   when      dforrmcd = *blank
     C                   movel     'HS00721'     mgid(e)
     C                   other
     C                   movel     'HS00765'     mgid(e)
     C                   movea     dforrmcd      mgw(6)
     C                   endsl
      *
     C                   movea     mgw           mgdt(e)
     C                   exsr      $err1
     C                   endif
     C                   else
      *
      * Only one group is open; default in its values.
      *
     C                   movel     p1hghgcd      dforhgcd
     C                   movel     p1hgrmcd      dforrmcd
     C                   endif                                                  If mult group
     C                   else
      *
      * No groups are open in this building/room
      *
     C                   seton                                        44
     C                   if        error < maxmsg
     C                   add       1             error
     C                   clear                   mgw
     C                   move      c1orfscd      xxalphfscd
     C                   movea     xxalphfscd    mgw(1)
     C                   movea     dforblcd      mgw(6)
      *
     C                   select
     C                   when      dforrmcd = *blank
     C                   movel     'HS00722'     mgid(e)
     C                   other
     C                   movel     'HS00766'     mgid(e)
     C                   movea     dforrmcd      mgw(11)
     C                   endsl
      *
     C                   movea     mgw           mgdt(e)
     C                   exsr      $err1
     C                   endif
     C                   endif                                                  If open group
      *
     C                   endsr
      /EJECT
      *----------------------------------------------------------------
      * EDIT ORIGIN HOG GROUP
      *----------------------------------------------------------------
      *
     C     $orhgcd       BEGSR
      *
     C                   MOVE      *BLANK        dforgscd
     C                   MOVE      *BLANK        dforptcd
     C                   MOVE      *BLANK        dforppcd
      *
     C                   SELECT
     C     dforhgcd      WHENEQ    *BLANK
     C                   SETON                                        44
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS09001'     MGID(E)
     C                   EXSR      $ERR1
     C                   ENDIF
     C                   OTHER
      *
     C     dforhgcd      CHAIN     HSP034                             91
     C     *IN91         IFEQ      *ON                                          IF BAD GROUP
     C                   SETON                                        44
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS00261'     MGID(E)
     C                   CLEAR                   MGW
     C                   MOVEA     dforhgcd      MGW(1)
     C                   MOVEA     MGW           MGDT(E)
     C                   EXSR      $ERR1
     C                   ENDIF
     C                   ELSE
      *
     C                   MOVEL     HGPTCD        dforptcd
     C                   MOVEL     HGPPCD        dforppcd
      *
      * ORIGIN MUST ALWAYS HAVE AN OPEN DATE ON OR BEFORE ALL DATES THAT ARE NOT
      * ZERO.
      *
     C                   IF        C1MDY <> 0 AND                               If sched
     C                             HGOPDT > WKSCDT
     C                   SETON                                        44
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS00488'     MGID(E)
     C                   CLEAR                   MGW
      *
     C                   MOVEA     dforhgcd      MGW(1)
      *
     C                   Z-ADD     HGOPDT        WKCYMD
     C                   EXSR      $TOMDY
     C                   MOVE      WKMDY         xxdt06
     C                   MOVEA     xxdt06        MGW(8)
      *
     C                   MOVE      c1mdy         xxdt06
     C                   MOVEA     xxdt06        MGW(14)
     C                   MOVEA     MGW           MGDT(E)
     C                   EXSR      $ERR1
     C                   ENDIF
     C                   ENDIF                                                  If sched
      *
     C                   IF        C1SMDY <> 0 AND                              If ship
     C                             HGOPDT > WKSHDT
     C                   SETON                                        44
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS00460'     MGID(E)
     C                   CLEAR                   MGW
      *
     C                   MOVEA     dforhgcd      MGW(1)
      *
     C                   Z-ADD     HGOPDT        WKCYMD
     C                   EXSR      $TOMDY
     C                   MOVE      WKMDY         xxdt06
     C                   MOVEA     xxdt06        MGW(8)
      *
     C                   MOVE      c1smdy        xxdt06
     C                   MOVEA     xxdt06        MGW(14)
     C                   MOVEA     MGW           MGDT(E)
     C                   EXSR      $ERR1
     C                   ENDIF
     C                   ENDIF                                                  If ship
      *
      *
      * GROUP MUST BE ON THE ORIGIN FARM
      *
     C     HGFSCD        IFNE      c1orfscd                                     IF DIFF FARM
     C                   SETON                                        44
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS00468'     MGID(E)
     C                   CLEAR                   MGW
     C                   MOVEA     dforhgcd      MGW(1)
     C                   MOVE      HGFSCD        xxalphfscd
     C                   MOVEA     xxalphfscd    MGW(8)
     C                   MOVE      c1orfscd      xxalphfscd
     C                   MOVEA     xxalphfscd    MGW(13)
     C                   MOVEA     MGW           MGDT(E)
     C                   EXSR      $ERR1
     C                   ENDIF
     C                   ENDIF                                                  IF DIFF FARM
      *
      *
      * Group building must match subfile building---if there is a building
      * on the subfile.
     C                   select
     C                   when      dforblcd = *blank
     C                   movel     hgblcd        dforblcd
     C                   other
     C                   if        dforblcd <> hgblcd                           If mismatch building
     C                   seton                                        44
     C                   if        error < maxmsg
     C                   add       1             error
     C                   movel     'HS00481'     mgid(e)
     C                   clear                   mgw
     C                   movea     dforhgcd      mgw(1)
     C                   movea     hgblcd        mgw(8)
     C                   movea     dforblcd      mgw(13)
     C                   movea     mgw           mgdt(e)
     C                   exsr      $err1
     C                   endif
     C                   endif                                                  If mismatch building
     C                   endsl
      *
      *
      * Group room must match subfile room---if there is a room
      * on the subfile.
     C                   select
     C                   when      dforrmcd = *blank
     C                   movel     hgrmcd        dforrmcd
     C                   other
     C                   if        dforrmcd <> hgrmcd                           If mismatch room
     C                   seton                                        44
     C                   if        error < maxmsg
     C                   add       1             error
     C                   movel     'HS00482'     mgid(e)
     C                   clear                   mgw
     C                   movea     dforhgcd      mgw(1)
     C                   movea     hgrmcd        mgw(8)
     C                   movea     dforrmcd      mgw(13)
     C                   movea     mgw           mgdt(e)
     C                   exsr      $err1
     C                   endif
     C                   endif                                                  If mismatch room
     C                   endsl
      *
      * All origin groups must have the same production type
      *
     C                   if        svorptcd <> *blank and                       If type
     C                             svorptcd <> dforptcd
     C                   seton                                        44
     C                   if        error < maxmsg
     C                   add       1             error
     C                   movel     'HS01140'     mgid(e)
     C                   clear                   mgw
     C                   movea     dforptcd      mgw(1)
     C                   movea     svorptcd      mgw(6)
     C                   movea     mgw           mgdt(e)
     C                   exsr      $err1
     C                   endif
     C                   endif                                                  If type
      *
      * All origin groups must have the same production phase
      *
     C                   if        svorppcd <> *blank and                       If phase
     C                             svorppcd <> dforppcd
     C                   seton                                        44
     C                   if        error < maxmsg
     C                   add       1             error
     C                   movel     'HS01143'     mgid(e)
     C                   clear                   mgw
     C                   movea     dforppcd      mgw(1)
     C                   movea     svorppcd      mgw(6)
     C                   movea     mgw           mgdt(e)
     C                   exsr      $err1
     C                   endif
     C                   endif                                                  If phase
      *
     C                   ENDIF                                                  IF BAD GROUP
     C                   ENDSL
      *
     C     *IN44         IFEQ      *OFF
     C                   Z-ADD     HGHGSN        hdorhgsn
     C                   MOVEL     HGGSCD        dforgscd
      *
     C                   if        svorptcd = *blank
     C                   move      dforptcd      svorptcd
     C                   endif
      *
     C                   if        svorppcd = *blank
     C                   move      dforppcd      svorppcd
     C                   endif
      *
     C                   ELSE
     C                   MOVEL     NO            LNOKFL
     C                   ENDIF
      *
     C                   ENDSR
      /EJECT
      *----------------------------------------------------------------
      * Edits for destination entries
      *----------------------------------------------------------------
      *
     C     $eddest       begsr
      *
      *
      * Validate destination:
      *  1) Building
      *  2) Room
      *  3) Hog group
      *
     C                   exsr      $dnblcd
      *
      * Edit room if a) it is not blank and b) it was not edited previously
      * in the logic that attempted to default a group for a building.
      * (The check on indicator 77 keeps you from issuing a second invalid
      * room message.)
      *
     C                   if        dfdnrmcd <> *blank and *in77 = *off
     C                   exsr      $dnrmcd
     C                   endif
      *
      * Edit destination hog group
      *
     C                   exsr      $dnhgcd
      *
      * VALIDATE QUALITY HEAD
      *
     C                   SELECT
     C     DFQLHD        WHENLT    0
     C                   SETON                                        48
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS09000'     MGID(E)
     C                   EXSR      $ERR1
     C                   ENDIF
      *
     C     C1MSCD        WHENEQ    'SH'
     C     DFQLHD        ANDEQ     0
     C     DFRJHD        ANDEQ     0
     C     dfkoahd       ANDEQ     0
     C     dfdoahd       ANDEQ     0
     C                   SETON                                        48
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS00631'     MGID(E)
     C                   EXSR      $ERR1
     C                   ENDIF
     C                   ENDSL
      *
      * If you have valid quality head, make sure that distributed Arrived Pounds
      * will not truncate.
      *
     C                   if        dfqlhd > 0 and *in48 = *off                  If good quality
     C     dfqlhd        mult      c1avarlb      wktrunlb
     C                   if        wktrunlb > 99999                             If truncated
     C                   seton                                        48
     C                   if        error < maxmsg
     C                   add       1             error
     C                   movel     'HS09068'     mgid(e)
     C                   exsr      $err1
     C                   endif
     C                   endif                                                  If truncated
     C                   endif                                                  If good quality
      *
      * VALIDATE DEAD-ON-ARRIVAL HEAD
      *
     C                   SELECT
     C     dfdoahd       WHENLT    0
     C                   SETON                                        70
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS09000'     MGID(E)
     C                   EXSR      $ERR1
     C                   ENDIF
     C                   ENDSL
      *
      * If you have valid DOA head, make sure that distributed Arrived Pounds
      * will not truncate.
      *
     C                   if        dfdoahd > 0 and *in70 = *off                 If doa
     C     dfdoahd       mult      c1avarlb      wktrunlb
     C                   if        wktrunlb > 99999                             If truncated
     C                   seton                                        70
     C                   if        error < maxmsg
     C                   add       1             error
     C                   movel     'HS09070'     mgid(e)
     C                   exsr      $err1
     C                   endif
     C                   endif                                                  If truncated
     C                   endif                                                  If good doa
      *
      *
      * VALIDATE KILLED-ON-ARRIVAL HEAD
      *
     C                   SELECT
     C     DFKOAHD       WHENLT    0
     C                   SETON                                        69
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS09000'     MGID(E)
     C                   EXSR      $ERR1
     C                   ENDIF
     C                   ENDSL
      *
      *
      * If you have valid KOA head, make sure that distributed Arrived Pounds
      * will not truncate.
      *
     C                   if        dfkoahd > 0 and *in69 = *off                 If good quality
     C     dfkoahd       mult      c1avarlb      wktrunlb
     C                   if        wktrunlb > 99999                             If truncated
     C                   seton                                        69
     C                   if        error < maxmsg
     C                   add       1             error
     C                   movel     'HS09071'     mgid(e)
     C                   exsr      $err1
     C                   endif
     C                   endif                                                  If truncated
     C                   endif                                                  If good quality
      *
      *
      * Validate subfile option for rejected head reasons.
      *
     C                   EXSR      $EDOP1
      *
      * VALIDATE REJECTED HEAD
      * DETERMINE IF REJECT REASONS EXIST FOR THIS LINE
      *
     C     key05         SETLL     HSP078
     C                   SETOFF                                       95
     C                   Z-ADD     0             WKHD
      *
     C     *IN95         DOUEQ     *ON
     C     key05         READE(N)  HSP078                                 95
     C     *IN95         IFEQ      *OFF
     C                   ADD       RJRJHD        WKHD
     C                   ENDIF
     C                   ENDDO
      *
     C                   SELECT
     C     DFRJHD        WHENLT    0
     C                   SETON                                        49
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS09000'     MGID(E)
     C                   EXSR      $ERR1
     C                   ENDIF
      *
     C     DFRJHD        WHENNE    WKHD
      *
     C                   SELECT
     C     DFRJHD        WHENEQ    0
     C                   SETON                                        49
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS00611'     MGID(E)
     C                   CLEAR                   MGW
     C                   MOVEL     WKHD          XXRJHD
     C                   MOVEA     XXRJHD        MGW(1)
     C                   MOVEA     MGW           MGDT(E)
     C                   EXSR      $ERR1
     C                   ENDIF
      *
     C     DFRJHD        WHENLT    WKHD
     C                   SETON                                        49
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS00604'     MGID(E)
     C                   CLEAR                   MGW
     C                   MOVEL     WKHD          XXRJHD
     C                   MOVEA     XXRJHD        MGW(1)
     C                   MOVEA     MGW           MGDT(E)
     C                   EXSR      $ERR1
     C                   ENDIF
     C                   ENDSL
     C                   ENDSL
      *
      *
      * If you have valid Reject head, make sure that distributed Arrived Pounds
      * will not truncate.
      *
     C                   if        dfrjhd > 0 and *in49 = *off                  If good reject
     C     dfrjhd        mult      c1avarlb      wktrunlb
     C                   if        wktrunlb > 99999                             If truncated
     C                   seton                                        49
     C                   if        error < maxmsg
     C                   add       1             error
     C                   movel     'HS09069'     mgid(e)
     C                   exsr      $err1
     C                   endif
     C                   endif                                                  If truncated
     C                   endif                                                  If good reject
      *
     C                   endsr
      /EJECT
      *----------------------------------------------------------------
      * Validate destination building
      *----------------------------------------------------------------
      *
     C     $dnblcd       begsr
      *
      * If building is blank and hog group is entered, default building and
      * room from hog group.
      *
     C                   if        dfdnblcd = *blank and dfdnhgcd <> *blank
     C     dfdnhgcd      chain     hsp034                             92
     C                   if        *in92 = *off
     C                   move      hgblcd        dfdnblcd
     C                   move      hgrmcd        dfdnrmcd
     C                   endif
     C                   endif
      *
      * Validations:
      *  1) building is required
      *  2) building must exist on the specified farm site
      *
     C                   select
     C                   when      dfdnblcd = *blank
     C                   seton                                        75
     C                   if        error < maxmsg
     C                   add       1             error
     C                   exsr      $err1
     C                   eval      mgid(e) = 'HS09001'
     C                   endif
     C                   other
      *
     C     key03         chain     hsp019                             92
     C                   if        *in92 = *on                                  If not found
     C                   seton                                        75
     C                   if        error < maxmsg
     C                   add       1             error
     C                   exsr      $err1
     C                   eval      mgid(e) = 'HS00116'
     C                   clear                   mgw
     C                   movea     dfdnblcd      mgw(1)
     C                   move      c1dnfscd      xxalphfscd
     C                   movea     xxalphfscd    mgw(6)
     C                   movea     mgw           mgdt(e)
     C                   endif
     C                   endif                                                  If not found
     C                   endsl
      *
      * Attempt to default in a group when:
      *   1) building is valid and group is blank and
      *   2) room is blank or valid
      *
     C                   if        *in75 = *off and dfdnhgcd = *blank             If valid building
      *
     C                   if        dfdnrmcd <> *blank
     C                   exsr      $dnrmcd
     C                   endif
      *
     C                   if        *in77 = *off                                 If room OK/blank
     C                   exsr      $dngroup
     C                   endif                                                  If room OK/blank
     C                   endif                                                  If valid building
      *
     C                   endsr
      /EJECT
      *----------------------------------------------------------------
      * Validate destination room
      *----------------------------------------------------------------
      *
      * Validations:
      *  1) required
      *  2) must exist in the building on the farm site
      *  3) must have an active status
      *
     C     $dnrmcd       begsr
      *
     C                   select
     C                   when      dfdnrmcd = *blank
     C                   seton                                        77
     C                   if        error < maxmsg
     C                   add       1             error
     C                   exsr      $err1
     C                   eval      mgid(e) = 'HS09001'
     C                   endif
     C                   other
      *
      * Check that the room exists in the building on the farm site
     *
     C     key04         chain     hsp020                             92
     C                   if        *in92 = *on                                  If no hit
     C                   seton                                        77
     C                   if        error < maxmsg
     C                   add       1             error
     C                   exsr      $err1
     C                   eval      mgid(e) = 'HS00117'
     C                   clear                   mgw
     C                   movea     dfdnrmcd      mgw(1)
     C                   movea     dfdnblcd      mgw(6)
     C                   move      c1dnfscd      xxalphfscd
     C                   movea     xxalphfscd    mgw(11)
     C                   movea     mgw           mgdt(e)
     C                   endif
     C                   else
     *
      * Room must have an 'active' status
     *
     C                   if        brrmst <> 'A'                                If not active
     C                   seton                                        77
     C                   if        error < maxmsg
     C                   add       1             error
     C                   exsr      $err1
     C                   eval      mgid(e) = 'HS00726'
     C                   clear                   mgw
     C                   movea     dfdnrmcd      mgw(1)
     C                   movea     mgw           mgdt(e)
     C                   endif
     C                   endif                                                  If not active
     C                   endif                                                  If no hit
      *
     C                   endsl
      *
     C                   endsr
      /eject
      *-----------------------------------------------------------------------
      * Attempt to find a default group in the destination building
      *-----------------------------------------------------------------------
      *
     C     $dngroup      begsr
      *
      * If only one group is open/created in that building or building/room, default
      * it in. But, if multiple groups are open/created, issue a message to the
      * user to select a group.
      *
      * Key with either a) farm/building if room is blank or b) farm/
      * building/room if room is populated.
      *
     C                   if        dfdnrmcd = *blank
     C     key03         chain     hsl034o                            92
     C                   else
     C     key04         chain     hsl034o                            92
     C                   endif
     C                   if        *in92 = *off                                 If open/created
      *
      * Check to see if there is another open/created group.
      * Key with either a) farm/building if room is blank or b) farm/
      * building/room if room is populated.
      *
      *
     C                   if        dfdnrmcd = *blank
     C     key03         reade     hsl034o                                92
     C                   else
     C     key04         reade     hsl034o                                92
     C                   endif
      *
     C                   if        *in92 = *off                                 If mult group
     C                   seton                                        46
     C                   if        error < maxmsg
     C                   add       1             error
     C                   clear                   mgw
     C                   movea     dfdnblcd      mgw(1)
      *
     C                   select
     C                   when      dfdnrmcd = *blank
     C                   movel     'HS00767'     mgid(e)
     C                   other
     C                   movel     'HS00769'     mgid(e)
     C                   movea     dfdnrmcd      mgw(6)
     C                   endsl
      *
     C                   movea     mgw           mgdt(e)
     C                   exsr      $err1
     C                   endif
     C                   else
      *
      * Only one group is open/created; default in its values.
      *
     C                   movel     hghgcd        dfdnhgcd
     C                   movel     hgrmcd        dfdnrmcd
     C                   endif                                                  If mult group
     C                   else
      *
      * No groups are open/created in this building/room
      *
     C                   seton                                        46
     C                   if        error < maxmsg
     C                   add       1             error
     C                   clear                   mgw
     C                   move      c1dnfscd      xxalphfscd
     C                   movea     xxalphfscd    mgw(1)
     C                   movea     dfdnblcd      mgw(6)
      *
     C                   select
     C                   when      dfdnrmcd = *blank
     C                   movel     'HS00768'     mgid(e)
     C                   other
     C                   movel     'HS00770'     mgid(e)
     C                   movea     dfdnrmcd      mgw(11)
     C                   endsl
      *
     C                   movea     mgw           mgdt(e)
     C                   exsr      $err1
     C                   endif
     C                   endif                                                  If open/created
      *
     C                   endsr
      /EJECT
      *----------------------------------------------------------------
      * Edit destination hog group
      *----------------------------------------------------------------
      *
     C     $dnhgcd       BEGSR
      *
     C                   MOVE      *BLANK        dfdngscd
     C                   MOVE      *BLANK        dfdnptcd
     C                   MOVE      *BLANK        dfdnppcd
     C                   z-add     0             svhgsn
     C                   z-add     0             svopdt
     C                   move      *blank        svgscd
      *
      * Validations:
      *  1) required
      *  2) must be valid in hog group file
      *  3) must have a status of created or open
      *  4) must be on the destination farm
      *  5) cannot be the same group as the origin group
      *
     C                   SELECT
     C     dfdnhgcd      WHENEQ    *BLANK
     C                   SETON                                        46
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS09001'     MGID(E)
     C                   EXSR      $ERR1
     C                   ENDIF
     C                   OTHER
      *
     C     dfdnhgcd      CHAIN     HSP034                             91
     C     *IN91         IFEQ      *ON                                          IF BAD GROUP
     C                   SETON                                        46
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS00261'     MGID(E)
     C                   CLEAR                   MGW
     C                   MOVEA     dfdnhgcd      MGW(1)
     C                   MOVEA     MGW           MGDT(E)
     C                   EXSR      $ERR1
     C                   ENDIF
     C                   ELSE
      *
     C                   MOVEL     HGPTCD        dfdnptcd
     C                   MOVEL     HGPPCD        dfdnppcd
     C                   z-add     hghgsn        svhgsn
     C                   z-add     hgopdt        svopdt
     C                   move      hggscd        svgscd
      *
      * GROUP MUST HAVE A STATUS OF OPENED OR CREATED
      *
     C     HGGSCD        IFEQ      'VD'                                         IF STATUS
     C                   SETON                                        46
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS00602'     MGID(E)
     C                   CLEAR                   MGW
     C                   MOVEA     dfdnhgcd      MGW(1)
     C                   MOVEA     HGGSCD        MGW(8)
     C                   MOVEA     MGW           MGDT(E)
     C                   EXSR      $ERR1
     C                   ENDIF
     C                   ENDIF                                                  IF STATUS
      *
      *
      * GROUP MUST BE ON THE DESTINATION FARM
      *
     C     HGFSCD        IFNE      c1dnfscd                                     IF DIFF FARM
     C                   SETON                                        46
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS00468'     MGID(E)
     C                   CLEAR                   MGW
     C                   MOVEA     dfdnhgcd      MGW(1)
     C                   MOVE      HGFSCD        xxalphfscd
     C                   MOVEA     xxalphfscd    MGW(8)
     C                   MOVE      c1dnfscd      xxalphfscd
     C                   MOVEA     xxalphfscd    MGW(13)
     C                   MOVEA     MGW           MGDT(E)
     C                   EXSR      $ERR1
     C                   ENDIF
     C                   ENDIF                                                  IF DIFF FARM
     C                   ENDIF                                                  IF BAD GROUP
      *
      *
      * Group building must match subfile building---if there is a building
      * on the subfile.
      *
     C                   select
     C                   when      dfdnblcd = *blank
     C                   movel     hgblcd        dfdnblcd
     C                   other
     C                   if        dfdnblcd <> hgblcd                           If mismatch building
     C                   seton                                        46
     C                   if        error < maxmsg
     C                   add       1             error
     C                   movel     'HS00481'     mgid(e)
     C                   clear                   mgw
     C                   movea     dfdnhgcd      mgw(1)
     C                   movea     hgblcd        mgw(8)
     C                   movea     dfdnblcd      mgw(13)
     C                   movea     mgw           mgdt(e)
     C                   exsr      $err1
     C                   endif
     C                   endif                                                  If mismatch building
     C                   endsl
      *
      *
      * Group room must match subfile room---if there is a room
      * on the subfile.
     C                   select
     C                   when      dfdnrmcd = *blank
     C                   movel     hgrmcd        dfdnrmcd
     C                   other
     C                   if        dfdnrmcd <> hgrmcd                           If mismatch room
     C                   seton                                        46
     C                   if        error < maxmsg
     C                   add       1             error
     C                   movel     'HS00482'     mgid(e)
     C                   clear                   mgw
     C                   movea     dfdnhgcd      mgw(1)
     C                   movea     hgrmcd        mgw(8)
     C                   movea     dfdnrmcd      mgw(13)
     C                   movea     mgw           mgdt(e)
     C                   exsr      $err1
     C                   endif
     C                   endif                                                  If mismatch room
     C                   endsl
      *
      * All destination groups must have the same production phase
      *
     C                   if        svdnppcd <> *blank and                       If phase
     C                             svdnppcd <> dfdnppcd
     C                   seton                                        46
     C                   if        error < maxmsg
     C                   add       1             error
     C                   movel     'HS01142'     mgid(e)
     C                   clear                   mgw
     C                   movea     dfdnppcd      mgw(1)
     C                   movea     svdnppcd      mgw(6)
     C                   movea     mgw           mgdt(e)
     C                   exsr      $err1
     C                   endif
     C                   endif                                                  If phase
      *
      *
      * All destination groups must have the same production type
      *
     C                   if        svdnptcd <> *blank and                       If type
     C                             svdnptcd <> dfdnptcd
     C                   seton                                        46
     C                   if        error < maxmsg
     C                   add       1             error
     C                   movel     'HS01141'     mgid(e)
     C                   clear                   mgw
     C                   movea     dfdnptcd      mgw(1)
     C                   movea     svdnptcd      mgw(6)
     C                   movea     mgw           mgdt(e)
     C                   exsr      $err1
     C                   endif
     C                   endif                                                  If type
      *
     C                   ENDSL
      *
      *
      * THE ORIGIN AND DESTINATION GROUP CANNOT BE THE SAME GROUP
      *
     C     *IN44         IFEQ      *OFF
     C     *IN46         ANDEQ     *OFF
     C     dforhgcd      ANDEQ     dfdnhgcd
     C                   SETON                                        46
     C     ERROR         IFLT      MAXMSG
     C                   ADD       1             ERROR
     C                   MOVEL     'HS00609'     MGID(E)
     C                   EXSR      $ERR1
     C                   ENDIF
     C                   ENDIF
      *
      * If you have 1) a Received Date and 2) an Open Date for the Destination Group,
      *  1) determine if 'baby' pigs are being moved into an 'old' group
      *
     C                   if        wkrcdt <> 0 and svopdt <> 0
     C                   exsr      $babypigs
     C                   endif
      *
      * If you have a saved Received Date (ie: you are not in CREATE mode),
      *  1) check that there are no open date issues
      *
     C                   if        svrcdt <> 0
     C                   exsr      $checkopen
     C                   endif
      *
     C     *IN46         IFEQ      *OFF                                         If OK
     C                   Z-ADD     SVHGSN        hddnhgsn
     C                   MOVEL     SVGSCD        dfdngscd
      *
     C                   if        svdnptcd = *blank
     C                   move      dfdnptcd      svdnptcd
     C                   endif
      *
     C                   if        svdnppcd = *blank
     C                   move      dfdnppcd      svdnppcd
     C                   endif
      *
     C                   ELSE
     C                   MOVEL     NO            LNOKFL
     C                   ENDIF                                                  If OK
      *
     C                   ENDSR
      /EJECT
      *-------------------------------------------------------------------------
      * Issue 'warning' message if 'baby' pigs are being moved into an old group
      *-------------------------------------------------------------------------
      *
     C     $babypigs     begsr
      *
      * Add 21 days to the 'open date' of the group. (Typically, all pigs should move
      * into 'new' groups within the first 3 weeks after the group opens.)
      *
     C                   movel     svopdt        wkcymdiso
     C                   adddur    21:*days      wkcymdiso
     C                   move      wkcymdiso     wkcutoffdt
      *
      * Issue a Warning message for a) BGF to Nursery and b) Nursery to Grow Finish
      * moves where the 'received date' is after this calculated cut-off date.
      *
     C                   if        wkrcdt > wkcutoffdt                          If baby
      *
     C                   select
     C                   when      dforppcd = 'BGF  ' and dfdnppcd = 'NUR  '
     C                   if        error < maxmsg
     C                   add       1             error
     C                   add       1             warmsg
     C                   movel     'HS00348'     mgid(e)
     C                   clear                   mgw
     C                   movea     dfdnhgcd      mgw(1)
     C                   movel     svopdt        wkalphadt
     C                   movea     wkalphadt     mgw(8)
     C                   movea     mgw           mgdt(e)
     C                   endif
      *
     C                   when      dforppcd = 'NUR  ' and dfdnppcd = 'GF   '
     C                   if        error < maxmsg
     C                   add       1             error
     C                   add       1             warmsg
     C                   movel     'HS00347'     mgid(e)
     C                   clear                   mgw
     C                   movea     dfdnhgcd      mgw(1)
     C                   movel     svopdt        wkalphadt
     C                   movea     wkalphadt     mgw(8)
     C                   movea     mgw           mgdt(e)
     C                   endif
     C                   endsl
      *
     C                   endif                                                  If baby
      *
     C                   endsr
      /EJECT
      *----------------------------------------------------------------
      * Check that Open Dates for Destination Groups are still OK
      *----------------------------------------------------------------
      *
     C     $checkopen    begsr
      *
      * If the destination group on the subfile line has changed, check that
      * removing the old destination group from this line doesn't screw up that
      * old group's open date.
      *
     C                   if        dfdnhgcd <> hddnoldhg
     C                   exsr      $oldgroup
     C                   endif
      *
      *
      * If the Received Date of the movement has changed, check that the new
      * Received Date doesn't screw up the group's open date.
      *
     C                   if        svrcdt <> 0 and svrcdt < wkrcdt
     C                   exsr      $newgroup
     C                   endif
      *
     C                   endsr
      /EJECT
      *------------------------------------------------------------------------
      * Check if there is only 1 movement into the group
      *------------------------------------------------------------------------
      *
     C     $onlyone      begsr
      *
     C     key08         setll     hsj058a
      *
     C                   dou       *in93 = *on                                  Do loop
     C     key08         reade     hsj058a                                93
     C                   if        *in93 = *off and memvsn <> c1mvsn            If not EOF
     C                   move      no            checkmore
     C                   endif                                                  If not EOF
     C                   enddo                                                  Do loop
      *
     C                   endsr
      /EJECT
      *-----------------------------------------------------------------------------------------
      * Find the date of the first transfer of pigs into the group after the group's open date
      *-----------------------------------------------------------------------------------------
      *
     C     $checkmore    begsr
      *
     C     hghgsn        setll     hsj058a
     C                   z-add     0             newopdt
      *
     C                   dou       *in93 = *on or newopdt <> 0                  Do other
     C     hghgsn        reade     hsj058a                                93
     C                   if        *in93 = *off and memedt <> hgopdt            If not EOF
     C                             and newopdt = 0
     C                   z-add     memedt        newopdt
     C                   endif                                                  If not EOF
     C                   enddo                                                  Do other
      *
     C                   endsr
      /EJECT
      *------------------------------------------------------------------------
      * Check that changing the Received Date doesn't screw up open date
      *------------------------------------------------------------------------
      *
     C     $newgroup     begsr
      *
      * Retrieve the open date of the destination group. If the group's open
      * date is the same as the original Received Date, then this may have been
      * the movement that actually 'opened' the group---or maybe not. So, check
      * further.
      *
     C     dfdnhgcd      chain     hsp034                             92
     C                   if        *in92 = *off and                             If hit
     C                             hgopdt = svrcdt
      *
      * Is this the only movement into this group with the original Received Date?
      * There could, of course, have been more than one movement into this group
      * on this date. If there is more than 1, you're OK and can quit checking.
      *
     C                   move      yes           checkmore
     C                   exsr      $onlyone
      *
      *
      * Well, this was the only movement into the group on the group's open
      * date. So, changing the date of this transfer to a later date will
      * change the group's OPEN date to be A) the date of the next Transfer movement
      * into this group or B) the new date of this transfer.
      *
      * So, find the first transfer movement into this group after the group's
      * open date.
     C                   if        checkmore = yes                              If check more
     C                   exsr      $checkmore
      *
      * At this point, you have:
      * A) the changed date of this movement and
      * B) the date of the next transfer into the group.
      * The group's new Open date will ultimately be the earlier of these 2 dates
      *
     C                   if        newopdt = 0 or wkrcdt < newopdt
     C                   z-add     wkrcdt        newopdt
     C                   endif
      *
      * Now, determine if any Sales or Dead movements exist for this group prior
      * to what will ultimately be the group's new Open date.
      *
     C                   exsr      $somemoves
      *
     C                   endif                                                  If check more
      *
     C                   endif                                                  If hit
      *
      *
     C                   endsr
      /EJECT
      *------------------------------------------------------------------------
      * Check that removing a destination group hasn't screwed its open date
      *------------------------------------------------------------------------
      *
     C     $oldgroup     begsr
      *
      * Retrieve the open date of the old destination group. If the group's open
      * date is the same as the original Received Date, then this may have been
      * the movement that actually 'opened' the group---or maybe not. So, check
      * further.
      *
     C     hddnoldhg     chain     hsp034                             92
     C                   if        *in92 = *off and                             If hit
     C                             hgopdt = svrcdt
      *
      * Is this the only movement into this group with the original Received Date?
      * There could, of course, have been more than one movement into this group
      * on this date. If there is more than 1, you're OK and can quit checking.
      *
     C                   move      yes           checkmore
     C                   exsr      $onlyone
      *
      * Well, this was the only movement into the group on the group's open
      * date. So, removing the group from this movement will A) set the
      * group back to a status of CREATE or B) change the group's 'OPEN' date
      * to be the date of the next Transfer movement into this group.
      *
      * So, find the first transfer movement into this group after the group's
      * open date.
     C                   if        checkmore = yes                              If check more
     C                   exsr      $checkmore
      *
      * At this point, you will know:
      *    1) the group will revert to Create status once it is removed
      *       Check that no 'Dead' or 'Sales' movements exist for this group
      * or 2) the group will have a new open date
      *       Check that no 'Dead' or 'Sales' movements exist PRIOR to new date
      *
     C                   select
     C                   when      newopdt = 0
     C                   exsr      $anymoves
     C                   other
     C                   exsr      $somemoves
     C                   endsl
      *
     C                   endif                                                  If check more
      *
     C                   endif                                                  If hit
      *
     C                   endsr
      /EJECT
      *----------------------------------------------------------------
      * Check for any movements for a group
      *----------------------------------------------------------------
      *
     C     $anymoves     begsr
      *
      * Check for any sales movements against this group
      *
     C     hghgsn        chain     hsl085b                            92
     C                   if        *in92 = *off                                 If sales
      *
     C                   seton                                        46
     C                   if        error < maxmsg
     C                   add       1             error
     C                   movel     'HS00284'     mgid(e)
     C                   clear                   mgw
     C                   movea     hddnoldhg     mgw(1)
     C                   movea     mgw           mgdt(e)
     C                   exsr      $err1
     C                   endif
     C                   endif                                                  If sales
      *
      * Check for any dead movements against this group
      *
     C     hghgsn        chain     hsl068d                            92
     C                   if        *in92 = *off                                 If deads
     C                   seton                                        46
     C                   if        error < maxmsg
     C                   add       1             error
     C                   movel     'HS00285'     mgid(e)
     C                   clear                   mgw
     C                   movea     hddnoldhg     mgw(1)
     C                   movea     mgw           mgdt(e)
     C                   exsr      $err1
     C                   endif
     C                   endif                                                  If deads
      *
     C                   endsr
      /EJECT
      *----------------------------------------------------------------
      * Check for movements for a group prior to its open date
      *----------------------------------------------------------------
      *
     C     $somemoves    begsr
      *
      * Check for sales movements against this group that are prior to its
      * new open date.
      *
     C                   move      yes           ok
     C     hghgsn        setll     hsj085e
      *
     C                   dou       *in93 = *on or ok = no                       Do sales
     C     hghgsn        reade     hsj085e                                93
     C                   if        *in93 = *off and ok = yes and                If not EOF
     C                             shshdt < newopdt
     C                   move      no            ok
     C                   if        error < maxmsg
     C                   add       1             error
     C                   exsr      $err1
     C                   clear                   mgw
      *
     C                   select
     C                   when      dfdnhgcd <> hddnoldhg
     C                   seton                                        46
     C                   movel     'HS00286'     mgid(e)
     C                   movea     hddnoldhg     mgw(1)
     C                   movea     mgw           mgdt(e)
     C                   other
      *
     C                   seton                                        46
     C                   movel     'HS00335'     mgid(e)
     C                   movea     dfdnhgcd      mgw(1)
     C                   movea     mgw           mgdt(e)
     C                   endsl
      *
     C                   endif
     C                   endif                                                  If not EOF
     C                   enddo                                                  Do sales
      *
      * Check for any dead movements against this group that are prior
      * to its new open date.
      *
     C     hghgsn        chain     hsl068d                            92
     C                   if        *in92 = *off and kdkddt < newopdt            If prior deads
     C                   seton                                        46
      *
     C                   if        error < maxmsg
     C                   add       1             error
     C                   exsr      $err1
     C                   clear                   mgw
      *
     C                   select
     C                   when      dfdnhgcd <> hddnoldhg
     C                   movel     'HS00287'     mgid(e)
     C                   movea     hddnoldhg     mgw(1)
     C                   movea     mgw           mgdt(e)
     C                   other
      *
     C                   movel     'HS00336'     mgid(e)
     C                   movea     dfdnhgcd      mgw(1)
     C                   movea     mgw           mgdt(e)
     C                   endsl
      *
     C                   endif
     C                   endif                                                  If prior deads
      *
     C                   endsr
      /EJECT
      *----------------------------------------------------------------
      * RESET INDICATORS IN THE CONTROL RECORD
      *----------------------------------------------------------------
      *
     C     $C1IND        BEGSR
      *
      *
      * IF THE TRANSFER WAS DELETED OUT FROM UNDER THE USER, THEN SET
      * *IN90 BACK ON TO CONTROL AVAILABLE FUNCTION KEYS AND INPUT
      * FIE
      *
     C     NOTFLG        IFEQ      YES                                          IF NOT FOUND
     C                   SETON                                        90
     C                   ELSE
     C                   SETOFF                                       90
     C                   ENDIF                                                  IF NOT FOUND
      *
      *
      *  SET UP FOR USER'S ACTION
      *
     C                   SELECT
     C     DFMODE        WHENEQ    REVISE                                       WH REVISE
     C                   SETON                                        60
     C                   ENDSL
      *
     C                   ENDSR
      /EJECT
      *----------------------------------------------------------------
      * RESET INDICATORS IN THE SUBFILE RECORD
      *----------------------------------------------------------------
      *
     C     $SFIND        BEGSR
      *
      * THE DSPATR LOGIC USED IN THE DSPF REQUIRES AT LEAST ONE
      * INDICATOR TO BE ON.
     C                   SETON                                        42
      *
      * IF THE TRANSFER WAS DELETED OUT FROM UNDER THE USER, THEN SET
      * *IN90 BACK ON TO CONTROL AVAILABLE FUNCTION KEYS AND INPUT
      * FIELDS.
      *
     C     NOTFLG        IFEQ      YES                                          IF NOT FOUND
     C                   SETON                                        90
     C                   ELSE
     C                   SETOFF                                       90
     C                   ENDIF                                                  IF NOT FOUND
      *
      *
      *  SET UP FOR USER'S ACTION
      *
     C                   SELECT
     C     DFMODE        WHENEQ    REVISE                                       WH REVISE
     C                   SETON                                        60
     C                   ENDSL
      *
     C                   ENDSR
      /EJECT
      *----------------------------------------------------------------
      * SET OFF THE ERROR INDICATORS ON THE SUBFILE
      *----------------------------------------------------------------
      *
     C     $SETOF        BEGSR
      *
     C                   SETOFF                                       3037
     C                   SETOFF                                       444546
     C                   SETOFF                                       474849
     C                   SETOFF                                       545556
     C                   SETOFF                                       576869
     C                   SETOFF                                       707173
     C                   SETOFF                                       747577
      *
     C                   ENDSR
      /EJECT
      *----------------------------------------------------------------
      * MANIPULATE DATES WITH DATE UTILITY
      *----------------------------------------------------------------
      *
     C     $DATE         BEGSR
      *
     C                   CALL      'UT80060R'
     C                   PARM                    PFRM8             8 0
     C                   PARM                    PTO8              8 0
     C                   PARM                    PFRFMT            4
     C                   PARM                    PTOFMT            4
     C                   PARM                    PDAYS             4 0
     C                   PARM                    PCODE             1
     C                   PARM                    PRTRN             1
      *
     C                   ENDSR
      /EJECT
      *----------------------------------------------------------------
      * User took F9=Accept
      *----------------------------------------------------------------
      *
     C     $accept       begsr
      *
      *----------------------------------------------------------------
      * REVISING AN EXISTING TRANSFER MOVEMENT WHEN USER TOOK F9
      *----------------------------------------------------------------
      *
     C     MODE          IFEQ      REVISE
     C                   EXSR      $EDIT1
     C     ERROR         IFEQ      0
     C     ERROR         OREQ      WARMSG
     C                   EXSR      $REVISE
     C                   ELSE
     C                   MOVEL     SCRN1         ROUTNE
     C                   ENDIF
     C                   ENDIF
      *
     C                   endsr
      /EJECT
      *----------------------------------------------------------------
      * Revise a transfer movement
      *----------------------------------------------------------------
      *
     C     $revise       begsr
      *
      * DELETE EXISTING TRANSFER HEADER AND DETAIL RECORDS
      * DELETE MOVEMENT EVENT RECORD
      *
     C                   EXSR      $DLTTH
     C                   EXSR      $DLTTD
     C                   EXSR      $DLTME
      *
      * CREATE NEW TRANSFER HEADER AND DETAIL RECORDS AND A NEW
      * MOVEMENT EVENT RECORD.
      *
     C                   EXSR      $CRTTH
     C                   EXSR      $CRTTD
      *
      * CLEAN UP HOG GROUP STATUS CODES
      *
     C                   EXSR      $CLEAN
      *
     C                   MOVEL     EXIT          ROUTNE
      *
     C                   endsr
      /EJECT
      *----------------------------------------------------------------
      * DELETE THE TRANSFER MOVEMENT HEADER RECORD
      *----------------------------------------------------------------
      *
     C     $DLTTH        BEGSR
      *
     C     C1MVSN        CHAIN     HSP074                             95
     C     *IN95         IFEQ      *OFF                                         IF FOUND
     C                   DELETE    MHREC
     C                   ENDIF                                                  IF FOUND
      *
     C                   ENDSR
      /EJECT
      *----------------------------------------------------------------
      * DELETE THE TRANSFER MOVEMENT DETAIL RECORDS
      *----------------------------------------------------------------
      *
     C     $DLTTD        BEGSR
      *
     C     C1MVSN        SETLL     HSP075
     C                   SETOFF                                       95
     C     *IN95         DOUEQ     *ON                                          DO DETAIL
     C     C1MVSN        READE     HSP075                                 95
     C     *IN95         IFEQ      *OFF                                         IF FOUND
     C                   DELETE    MDREC
     C                   ENDIF                                                  IF FOUND
     C                   ENDDO                                                  DO DETAIL
      *
     C                   ENDSR
      /EJECT
      *----------------------------------------------------------------
      * DELETE ANY/ALL MOVEMENT EVENT RECORDS
      *----------------------------------------------------------------
      *
     C     $DLTME        BEGSR
      *
      * INITIALIZE THE DESTINATION GROUP ARRAY AND INDEXES
      *
     C                   Z-ADD     0             GRP
     C                   Z-ADD     0             Y
     C                   Z-ADD     0             X
      *
      * ALWAYS DELETE THE MOVEMENT EVENT RECORD FOR BOTH THE
      * ORIGIN AND DESTINATION HOG GROUPS.  HOWEVER, BEFORE
      * DELETING THE DESTINATION GROUP RECORDS, WRITE A TABLE
      * ENTRY FOR EACH GROUP. THIS TABLE WILL BE USED IN CLEANING
      * UP THE 'OPEN STATUS' AND 'OPEN DATE' FOR HOG GROUPS.
      *
     C                   SETOFF                                       95
     C     C1MVSN        SETLL     HSP058
      *
     C     *IN95         DOUEQ     *ON                                          DO EVENTS
     C     C1MVSN        READE     HSP058                                 95
     C     *IN95         IFEQ      *OFF                                         IF EVENT
      *
      * LOOK UP DESTINATION GROUP IN ARRAY.
      * IF NOT FOUND, MOVE GROUP TO NEXT ELEMENT IN ARRAY.
      *
     C     MEODFL        IFEQ      'D'                                          IF DEST
     C                   Z-ADD     1             X
     C     MEHGSN        LOOKUP    GRP(X)                                 98
     C     *IN98         IFEQ      *OFF
     C                   ADD       1             Y
     C                   Z-ADD     MEHGSN        GRP(Y)
     C                   ENDIF
     C                   ENDIF                                                  IF DEST
      *
     C                   DELETE    MEREC
     C                   ENDIF                                                  IF EVENT
     C                   ENDDO                                                  DO EVENTS
      *
     C                   ENDSR
      /EJECT
      *----------------------------------------------------------------
      * DELETE ALL REJECTED HEAD REASONS FOR A SPECIFIC MOVEMENT LINE
      *----------------------------------------------------------------
      *
     C     $DLTLR        BEGSR
      *
     C                   SETOFF                                       95
     C     key05         SETLL     HSP078
     C     *IN95         DOUEQ     *ON
     C     key05         READE     HSP078                                 95
     C     *IN95         IFEQ      *OFF
     C                   DELETE    RJREC
     C                   ENDIF
     C                   ENDDO
      *
     C                   ENDSR
      /EJECT
      *----------------------------------------------------------------
      * CREATE A TRANSFER HEADER RECORD
      *----------------------------------------------------------------
      *
     C     $CRTTH        BEGSR
      *
     C                   Z-ADD     C1MVSN        MHMVSN
      *
     C                   MOVEL     C1MSCD        MHMSCD
     C                   MOVEL     c1orfscd      MHORFS
     C                   MOVEL     WKORBO        MHORBO
     C                   MOVEL     SVORPTCD      MHORPT
     C                   MOVEL     SVORPPCD      MHORPP
      *
     C                   MOVEL     c1dnfscd      MHDNFS
     C                   MOVEL     WKDNBO        MHDNBO
     C                   MOVEL     SVDNPTCD      MHDNPT
     C                   MOVEL     SVDNPPCD      MHDNPP
      *
     C                   MOVEL     C1TICD        MHTICD
     C                   Z-ADD     WKSCDT        MHSCDT
     C                   Z-ADD     WKSHDT        MHSHDT
     C                   Z-ADD     C1SITM        MHSITM
     C                   Z-ADD     C1SOTM        MHSOTM
      *
     C                   Z-ADD     WKRCDT        MHRCDT
     C                   Z-ADD     C1RITM        MHRITM
     C                   Z-ADD     C1ROTM        MHROTM
      *
     C                   WRITE     MHREC
      *
      * SET THE PARM FOR STATUS TO RETURN TO THE CALLING
      * PROGRAM
     C                   MOVEL     C1MSCD        XXMSCD
      *
     C                   ENDSR
      /EJECT
      *----------------------------------------------------------------
      * CREATE TRANSFER DETAIL RECORDS
      *----------------------------------------------------------------
      *
     C     $CRTTD        BEGSR
      *
      * CALCULATE THE VALUES TO BE USED IN DISTRIBUTING SHIPPED POUNDS
      *
     C                   EXSR      $DSTSH
      *
      *  SETUP THE VALUES FOR FIELDS THAT WON'T CHANGE PER LINE
      *
     C                   Z-ADD     C1MVSN        MDMVSN
      *
      *---------------------------------------------------------------
      * READ/PROCESS ALL THE CHANGED SUBFILE RECORDS
      *---------------------------------------------------------------
      *
     C                   SETOFF                                       80
     C     *IN80         DOUEQ     *ON                                          DO READ C
     C                   READC     HP186S1                                80
     C     *IN80         IFEQ      *OFF                                         IF REC READ
     C     dforhgcd      ANDNE     *BLANK
      *
     C                   Z-ADD     HDLNNO        MDLNNO
     C                   Z-ADD     hdorhgsn      MDORSN
     C                   Z-ADD     hddnhgsn      MDDNSN
      *
     C                   Z-ADD     DFSCHD        MDSCHD
     C                   Z-ADD     DFSHHD        MDSHHD
     C                   Z-ADD     DFQLHD        MDQLHD
     C                   Z-ADD     DFRJHD        MDRJHD
     C                   Z-ADD     dfkoahd       MDKOAHD
     C                   Z-ADD     dfdoahd       MDDOAHD
     C     dfkoahd       add       dfdoahd       mddohd
      *
      * IF THE ORIGIN GROUP IS NOT PROTECTED, DISTRIBUTE SHIPPED
      * POUNDS; OTHERWISE, MOVE THE HIDDEN SUBFILE POUNDS TO RECORD.
      *
     C     HDSHLB        IFEQ      0
     C                   EXSR      $SHLB
     C                   ELSE
     C                   Z-ADD     HDSHLB        MDSHLB
     C                   ENDIF
      *
      * Distribute pounds
     C                   EXSR      $ARLB
      *
     C                   WRITE     MDREC
      *
      * CREATE MOVEMENT EVENT RECORDS FOR BOTH THE ORIGIN
      * THE DESTINATION GROUPS
      *
     C                   EXSR      $CRTME
      *
      * UPDATE THE HOG GROUP STATUS TO OPEN AND ENTER AN OPEN DATE
      * IF THIS IS NOT A 'SCHEDULED' MOVEMENT.
      *
     C                   EXSR      $OPEN
      *
     C                   ENDIF                                                  IF REC READ
     C                   ENDDO                                                  DO READ C
      *
      *----------------------------------------------------------------
      * LOGIC TO DUMP ANY POUNDS NOT DISTRIBUTED INTO A RECORD
      *----------------------------------------------------------------
      *
      * DUMP ALL SHIPPED POUNDS THAT HAVE NOT ALREADY BEEN
      * DISTRIBUTED INTO THE LAST UNPROTECTED DETAIL RECORD FOR THIS
      * MOVEMENT.
      *
     C     WKSHLB        IFNE      0                                            IF SHIP LBS
     C     key06         CHAIN     HSP075                             91
     C     *IN91         IFEQ      *OFF                                         IF DETAIL
     C                   ADD       WKSHLB        MDSHLB
     C                   UPDATE    MDREC
     C                   ENDIF                                                  IF DETAIL
     C                   ENDIF                                                  IF SHIP LBS
      *
      * DUMP ALL ARRIVED POUNDS THAT HAVE NOT ALREADY BEEN
      * BEEN DISTRIBUTED INTO THE LAST UNPROTECTED RECORD FOR THIS
      * MOVEMENT. THE PRIORITY FOR DUMPING ARRIVED POUNDS IS:
      * QUALITY, REJECTED, DEAD.
      *
      *
     C     WKARLB        IFNE      0                                            IF LEFTOVER
     C     key07         CHAIN     HSP075                             91
     C     *IN91         IFEQ      *OFF                                         IF DETAIL
      *
     C                   SELECT
     C     MDQLHD        WHENNE    0
     C                   ADD       WKARLB        MDQLLB
     C     MDRJHD        WHENNE    0
     C                   ADD       WKARLB        MDRJLB
     C     MDDOHD        WHENNE    0
     C                   ADD       WKARLB        MDDOLB
     C                   ENDSL
      *
     C                   UPDATE    MDREC
     C                   ENDIF                                                  IF DETAIL
     C                   ENDIF                                                  IF LEFTOVER
      *
     C                   ENDSR
      /EJECT
      *----------------------------------------------------------------
      * CALCULATE THE VALUES FOR DISTRIBUTING SHIPPED POUNDS
      *----------------------------------------------------------------
      *
     C     $DSTSH        BEGSR
      *
      *  CALCULATE THE SHIPPED POUNDS TO BE DISTRIBUTED TO THE TRANSFER
      *  DETAIL RECORDS.
      *
      *  CALCULATE THE SHIPPED VALUES FOR DISTRIBUTION  =  TOTAL VALUES
      *  LESS THE SAVED VALUES ASSOCIATED WITH PROTECTED RECORDS
      *
     C     C1SHLB        SUB       SVSHLB        WKSHLB
     C     C1SHHD        SUB       SVSHHD        WKSHHD
      *
      *  CALCULATE THE AVERAGE SHIPPED POUNDS TO DISTRIBUTE PER HEAD
      *
     C                   Z-ADD     0             WKASLB
     C     WKSHHD        IFNE      0
     C     WKSHLB        DIV(H)    WKSHHD        WKASLB
     C                   ENDIF
      *
     C                   ENDSR
      /EJECT
      *----------------------------------------------------------------
      * CALCULATE THE VALUES FOR DISTRIBUTING ARRIVED POUNDS
      *----------------------------------------------------------------
      *
     C     $DSTAR        BEGSR
      *
      *  CALCULATE THE ARRIVED POUNDS TO BE DISTRIBUTED TO THE TRANSFER
      *  DETAIL RECORDS.
      *
      *  CALCULATE THE ARRIVED VALUES FOR DISTRIBUTION  =  TOTAL VALUES
      *  LESS THE SAVED VALUES ASSOCIATED WITH PROTECTED RECORDS
      *
     C     C1ARLB        SUB       SVARLB        WKARLB
     C     C1ARHD        SUB       SVARHD        WKARHD
      *
      *  CALCULATE THE AVERAGE ARRIVED POUNDS TO DISTRIBUTE PER HEAD
      *
     C                   Z-ADD     0             WKAALB
     C     WKARHD        IFNE      0
     C     WKARLB        DIV(H)    WKARHD        WKAALB
     C                   ENDIF
      *
     C                   ENDSR
      /EJECT
      *----------------------------------------------------------------
      * CREATE MOVEMENT EVENT RECORDS
      *----------------------------------------------------------------
      *
     C     $CRTME        BEGSR
      *
      *
      * SET UP UPDATE TIME STAMP
      *
     C                   Z-ADD     WKUDAT        MEUPDT
     C                   TIME                    MEUPTM
     C                   MOVEL     SDUSR         MEUSCD
     C                   MOVEL     SDPGM         MEPGM
      *
      * SETUP THE MOVEMENT NUMBER AND STATUS
      *
     C                   Z-ADD     C1MVSN        MEMVSN
      *
     C                   Z-ADD     0             MECVNO
     C                   Z-ADD     HDLNNO        MELNNO
      *
      * WRITE AN EVENT RECORD FOR THE ORIGIN GROUP
      *
     C                   Z-ADD     hdorhgsn      MEHGSN
     C                   MOVEL     'T'           MEMTCD
     C                   MOVEL     'O'           MEODFL
     C                   Z-ADD     hddnhgsn      MEHSN
      *
     C                   SELECT
     C     C1MSCD        WHENEQ    'SH'
     C                   Z-ADD     WKSHDT        MEMEDT
     C                   ENDSL
      *
     C                   WRITE     MEREC
      *
      * WRITE AN EVENT RECORD FOR THE DESTINATION GROUP
      *
     C                   Z-ADD     hddnhgsn      MEHGSN
     C                   MOVEL     'T'           MEMTCD
     C                   MOVEL     'D'           MEODFL
     C                   Z-ADD     hdorhgsn      MEHSN
      *
     C                   SELECT
     C     C1MSCD        WHENEQ    'SH'
     C                   Z-ADD     WKRCDT        MEMEDT
     C                   ENDSL
      *
     C                   WRITE     MEREC
      *
     C                   ENDSR
      /EJECT
      *----------------------------------------------------------------
      * DISTRIBUTE SHIPPED POUNDS TO THIS DETAIL RECORD
      *----------------------------------------------------------------
      *
     C     $SHLB         BEGSR
      *
     C                   Z-ADD     0             MDSHLB
      *
     C     WKSHLB        IFGT      0                                            IF LBS LEFT
     C     MDSHHD        MULT      WKASLB        WKLB
     C     WKLB          IFGT      WKSHLB
     C                   Z-ADD     WKSHLB        MDSHLB
     C                   Z-ADD     0             WKSHLB
     C                   ELSE
     C                   Z-ADD     WKLB          MDSHLB
     C     WKSHLB        SUB       WKLB          WKSHLB
     C                   ENDIF
     C                   ENDIF                                                  IF LBS LEFT
      *
      * SAVE THE MOVEMENT/LINE NUMBER FOR POSSIBLE RETRIEVAL
      * OF THIS RECORD TO DUMP IN LEFTOVER SHIPPED POUNDS.
      *
     C                   Z-ADD     MDMVSN        SVMV1
     C                   Z-ADD     MDLNNO        SVLN1
      *
     C                   ENDSR
      /EJECT
      *----------------------------------------------------------------
      * DISTRIBUTE ARRIVED POUNDS TO THIS DETAIL RECORD
      *----------------------------------------------------------------
      *
     C     $ARLB         BEGSR
      *
     C                   Z-ADD     0             MDQLLB
     C                   Z-ADD     0             MDRJLB
     C                   Z-ADD     0             MDDOLB
      *
      * DISTRIBUTE POUNDS TO QUALITY HEAD
      *
     C     WKARLB        IFGT      0                                            IF LBS LEFT
     C     MDQLHD        IFNE      0                                            IF QUALITY
     C     MDQLHD        MULT(H)   WKAALB        WKLB
     C     WKLB          IFGT      WKARLB
     C                   Z-ADD     WKARLB        MDQLLB
     C                   Z-ADD     0             WKARLB
     C                   ELSE
     C                   Z-ADD     WKLB          MDQLLB
     C     WKARLB        SUB       WKLB          WKARLB
     C                   ENDIF
     C                   ENDIF                                                  IF QUALITY
     C                   ENDIF                                                  IF LBS LEFT
      *
      * DISTRIBUTE POUNDS TO REJECTED HEAD
      *
     C     WKARLB        IFGT      0                                            IF STILL LBS
     C     MDRJHD        IFNE      0                                            IF REJECT HD
     C     MDRJHD        MULT(H)   WKAALB        WKLB
     C     WKLB          IFGT      WKARLB
     C                   Z-ADD     WKARLB        MDRJLB
     C                   Z-ADD     0             WKARLB
     C                   ELSE
     C                   Z-ADD     WKLB          MDRJLB
     C     WKARLB        SUB       WKLB          WKARLB
     C                   ENDIF
     C                   ENDIF                                                  IF REJECT HD
     C                   ENDIF                                                  IF STILL LBS
      *
      * DISTRIBUTE POUNDS TO DEAD HEAD
      *
     C     WKARLB        IFGT      0                                            IF MORE LBS
     C     MDDOHD        IFNE      0                                            IF DEAD HD
     C     MDDOHD        MULT(H)   WKAALB        WKLB
     C     WKLB          IFGT      WKARLB
     C                   Z-ADD     WKARLB        MDDOLB
     C                   Z-ADD     0             WKARLB
     C                   ELSE
     C                   Z-ADD     WKLB          MDDOLB
     C     WKARLB        SUB       WKLB          WKARLB
     C                   ENDIF
     C                   ENDIF                                                  IF DEAD HEAD
     C                   ENDIF                                                  IF MORE LBS
      *
      * SAVE THE MOVEMENT/LINE NUMBER FOR POSSIBLE RETRIEVAL
      * OF THIS RECORD TO DUMP IN LEFTOVER ARRIVED POUNDS.
      *
     C                   Z-ADD     MDMVSN        SVMV2
     C                   Z-ADD     MDLNNO        SVLN2
      *
     C                   ENDSR
      /EJECT
      *----------------------------------------------------------------
      * SET GROUP STATUS TO 'OPEN' AND UPDATE THE OPENED DATE
      *----------------------------------------------------------------
      *
     C     $OPEN         BEGSR
      *
     C     hddnhgsn      CHAIN     HSL034D                            92
     C     *IN92         IFEQ      *OFF
      *
     C                   SELECT
     C     HGGSCD        WHENEQ    'CR'
     C                   MOVEL     'OP'          HGGSCD
     C                   Z-ADD     WKRCDT        HGOPDT
      *
     C     HGGSCD        WHENEQ    'OP'
     C     WKRCDT        ANDLT     HGOPDT
     C                   Z-ADD     WKRCDT        HGOPDT
     C                   ENDSL
      *
     C                   UPDATE    HGRECD
     C                   ENDIF
      *
     C                   ENDSR
      /EJECT
      *----------------------------------------------------------------
      * CLEAN UP HOG GROUP STATUS CODES
      *----------------------------------------------------------------
      *
      * THIS LOGIC READS THE ARRAY OF THE ORIGINAL DESTNATION HOG
      * GROUPS FOR A TRANSFER AND CHECKS THE OPEN STATUS AND OPEN DATE
      * OF THE GROUP TO DETERMINE IF IT NEEDS TO BE CHANGED.
      *
     C     $CLEAN        BEGSR
      *
     C     Y             IFNE      0                                            IF ELEMENTS
     C                   DO        Y             X                              DO ALL ENTRY
     C     GRP(X)        IFNE      0                                            IF ENTRY
      *
     C     GRP(X)        CHAIN     HSL034D                            92
     C     *IN92         IFEQ      *OFF                                         IF OPEN GRP
     C     HGGSCD        ANDEQ     'OP'
     C     HGPPCD        ANDNE     'BGF  '
      *
     C     GRP(X)        CHAIN     HSJ058A                            92
     C     *IN92         IFEQ      *ON                                          IF NO HOG IN
     C                   MOVEL     'CR'          HGGSCD
     C                   Z-ADD     0             HGOPDT
     C                   ELSE
     C                   Z-ADD     MEMEDT        HGOPDT
     C                   ENDIF                                                  IF NO HOG IN
      *
     C                   UPDATE    HGRECD
     C                   ENDIF                                                  IF OPEN GRP
      *
     C                   ENDIF                                                  IF ENTRY
     C                   ENDDO                                                  DO ALL ENTRY
     C                   ENDIF                                                  IF ELEMENTS
      *
     C                   ENDSR
      /EJECT
      *----------------------------------------------------------------
      * F4 PROMPT FOR SCREEN 1
      *----------------------------------------------------------------
      *
     C     $F4S1         BEGSR
      *
      *
      * SET OFF PROMPT INDICATORS IN ALL SUBFILE RECORDS
      *
      *
     C                   EXSR      $OFFIN
      *
      *----------------------------------------------------------------
      * PROMPTED FIELDS IN THE CONTROL RECORD
      *----------------------------------------------------------------
      *
     C                   SELECT
      *
      * TRUCKER ID
      *
     C     FLD           WHENEQ    'C1TICD'
     C                   CALL      'HP538'
     C                   PARM                    XXTICD
     C                   PARM                    XXTINM
     C                   PARM                    xxmtechref
     C                   SETON                                        53
     C     XXTICD        IFNE      *BLANK                                       IF SELECTED
     C                   MOVEL     XXTICD        C1TICD
     C                   ENDIF                                                  IF SELECTED
      *
      * ORIGIN FARM SITE
      *
     C     FLD           WHENEQ    'C1ORFSCD'
     C                   CALL      'HP5040'
     C                   PARM      *blank        xxaist
     C                   PARM      0             xxfscd
     C                   PARM      *blank        XXFSNM
     C                   SETON                                        51
     C     xxfscd        IFNE      0                                            IF SELECTED
     C                   Z-ADD     xxfscd        c1orfscd
     C                   MOVEL     XXFSNM        c1orfsnm
     C                   ENDIF                                                  IF SELECTED
      *
      * DESTINATION FARM SITE
      *
     C     FLD           WHENEQ    'C1DNFSCD'
     C                   CALL      'HP5040'
     C                   PARM      *blank        xxaist
     C                   PARM      0             xxfscd
     C                   PARM      *blank        XXFSNM
     C                   SETON                                        52
     C     xxfscd        IFNE      0                                            IF SELECTED
     C                   Z-ADD     xxfscd        c1dnfscd
     C                   MOVEL     XXFSNM        c1dnfsnm
     C                   ENDIF                                                  IF SELECTED
      *
      *----------------------------------------------------------------
      * PROMPTED FIELDS IN THE SUBFILE
      *----------------------------------------------------------------
      *
      *-----------------------
      * ORIGIN BUILDING
      *-----------------------
      *
     C     FLD           WHENEQ    'DFORBLCD'
     C                   EXSR      $RRN1
     C     *IN97         IFEQ      *OFF                                         IF HIT
     C                   call      'HP523'
     C                   parm                    c1orfscd
     C                   parm      *blank        xxblcd
     C                   parm      *blank        xxblds
     C                   if        xxblcd <> *blank
     C                   movel     xxblcd        dforblcd
     C                   endif
      *
      * RESET SUBFILE RECORD INDICATORS AND UPDATE SUBFILE
      * RECORD.
      *
     C                   EXSR      $SFIND
     C                   SETON                                        8555
     C                   UPDATE    HP186S1
     C                   SETOFF                                       8555
      *
      * RESET THE SUBFILE RELATIVE RECORD NUMBER TO WHAT IT WAS BEFORE
      * THE USER TOOK F4 (IT WILL BE OUT-OF-SYNCH IF THE USER HAS
      * SELECTED A RECORD THUS CAUSING THE SUBFILE RECORD TO BE
      * RETRIEVED AND UPDATED.)  BUT, SET THE PAGE OF THE SUBFILE TO
      * BE DISPLAYED TO THE PAGE ON WHICH THE USER TOOK F4.
      *
     C                   Z-ADD     COUNT         HDRRN1
     C                   Z-ADD     HDRR1         HDPAG1
     C                   ENDIF                                                  IF HIT
      *
      *-----------------------
      * ORIGIN ROOM
      *-----------------------
      *
     C     FLD           WHENEQ    'DFORRMCD'
     C                   EXSR      $RRN1
     C     *IN97         IFEQ      *OFF                                         IF HIT
     C                   call      'HP524'
     C                   parm                    c1orfscd
     C                   parm                    dforblcd
     C                   parm      *blank        xxrmcd
     C                   if        xxrmcd <> *blank
     C                   movel     xxrmcd        dforrmcd
     C                   endif
      *
      * RESET SUBFILE RECORD INDICATORS AND UPDATE SUBFILE
      * RECORD.
      *
     C                   EXSR      $SFIND
     C                   SETON                                        8557
     C                   UPDATE    HP186S1
     C                   SETOFF                                       8557
      *
      * RESET THE SUBFILE RELATIVE RECORD NUMBER TO WHAT IT WAS BEFORE
      * THE USER TOOK F4 (IT WILL BE OUT-OF-SYNCH IF THE USER HAS
      * SELECTED A RECORD THUS CAUSING THE SUBFILE RECORD TO BE
      * RETRIEVED AND UPDATED.)  BUT, SET THE PAGE OF THE SUBFILE TO
      * BE DISPLAYED TO THE PAGE ON WHICH THE USER TOOK F4.
      *
     C                   Z-ADD     COUNT         HDRRN1
     C                   Z-ADD     HDRR1         HDPAG1
     C                   ENDIF                                                  IF HIT
      *
      *-----------------------
      * ORIGIN HOG GROUP
      *-----------------------
      *
     C     FLD           WHENEQ    'DFORHGCD'
     C                   EXSR      $RRN1
     C     *IN97         IFEQ      *OFF                                         IF HIT
     C                   CALL      'HP5950'
     C                   PARM                    c1orfscd
     C                   PARM                    c1orfsnm
     C                   PARM      dforblcd      XXBLCD
     C                   PARM      dforrmcd      XXRMCD
     C                   PARM      *blank        XXHGCD
     C                   PARM      *blank        XXGSCD
     C                   PARM      *blank        XXPTCD
     C                   PARM      *blank        XXPPCD
     C     XXHGCD        IFNE      *BLANK                                       IF SELECTED
     C                   MOVEL     XXHGCD        dforhgcd
     C                   MOVEL     XXBLCD        DFORBLCD
     C                   MOVEL     XXRMCD        DFORRMCD
     C                   MOVEL     XXPTCD        DFORPTCD
     C                   MOVEL     XXPPCD        DFORPPCD
     C                   MOVEL     XXGSCD        DFORGSCD
     C                   ENDIF                                                  IF SELECTED
      *
      * RESET SUBFILE RECORD INDICATORS AND UPDATE SUBFILE
      * RECORD.
      *
     C                   EXSR      $SFIND
     C                   SETON                                        8554
     C                   UPDATE    HP186S1
     C                   SETOFF                                       8554
      *
      * RESET THE SUBFILE RELATIVE RECORD NUMBER TO WHAT IT WAS BEFORE
      * THE USER TOOK F4 (IT WILL BE OUT-OF-SYNCH IF THE USER HAS
      * SELECTED A RECORD THUS CAUSING THE SUBFILE RECORD TO BE
      * RETRIEVED AND UPDATED.)  BUT, SET THE PAGE OF THE SUBFILE TO
      * BE DISPLAYED TO THE PAGE ON WHICH THE USER TOOK F4.
      *
     C                   Z-ADD     COUNT         HDRRN1
     C                   Z-ADD     HDRR1         HDPAG1
     C                   ENDIF                                                  IF HIT
      *
      *
      *-----------------------
      * DESTINATION BUILDING
      *-----------------------
      *
     C     FLD           WHENEQ    'DFDNBLCD'
     C                   EXSR      $RRN1
     C     *IN97         IFEQ      *OFF                                         IF HIT
     C                   call      'HP523'
     C                   parm                    c1dnfscd
     C                   parm      *blank        xxblcd
     C                   parm      *blank        xxblds
     C                   if        xxblcd <> *blank
     C                   movel     xxblcd        dfdnblcd
     C                   endif
      *
      * RESET SUBFILE RECORD INDICATORS AND UPDATE SUBFILE
      * RECORD.
      *
     C                   EXSR      $SFIND
     C                   SETON                                        8550
     C                   UPDATE    HP186S1
     C                   SETOFF                                       8550
      *
      * RESET THE SUBFILE RELATIVE RECORD NUMBER TO WHAT IT WAS BEFORE
      * THE USER TOOK F4 (IT WILL BE OUT-OF-SYNCH IF THE USER HAS
      * SELECTED A RECORD THUS CAUSING THE SUBFILE RECORD TO BE
      * RETRIEVED AND UPDATED.)  BUT, SET THE PAGE OF THE SUBFILE TO
      * BE DISPLAYED TO THE PAGE ON WHICH THE USER TOOK F4.
      *
     C                   Z-ADD     COUNT         HDRRN1
     C                   Z-ADD     HDRR1         HDPAG1
     C                   ENDIF                                                  IF HIT
      *
      *
      *-----------------------
      * DESTINATION ROOM
      *-----------------------
      *
     C     FLD           WHENEQ    'DFDNRMCD'
     C                   EXSR      $RRN1
     C     *IN97         IFEQ      *OFF                                         IF HIT
     C                   call      'HP524'
     C                   parm                    c1dnfscd
     C                   parm                    dfdnblcd
     C                   parm      *blank        xxrmcd
     C                   if        xxrmcd <> *blank
     C                   movel     xxrmcd        dfdnrmcd
     C                   endif
      *
      * RESET SUBFILE RECORD INDICATORS AND UPDATE SUBFILE
      * RECORD.
      *
     C                   EXSR      $SFIND
     C                   SETON                                        8557
     C                   UPDATE    HP186S1
     C                   SETOFF                                       8557
      *
      * RESET THE SUBFILE RELATIVE RECORD NUMBER TO WHAT IT WAS BEFORE
      * THE USER TOOK F4 (IT WILL BE OUT-OF-SYNCH IF THE USER HAS
      * SELECTED A RECORD THUS CAUSING THE SUBFILE RECORD TO BE
      * RETRIEVED AND UPDATED.)  BUT, SET THE PAGE OF THE SUBFILE TO
      * BE DISPLAYED TO THE PAGE ON WHICH THE USER TOOK F4.
      *
     C                   Z-ADD     COUNT         HDRRN1
     C                   Z-ADD     HDRR1         HDPAG1
     C                   ENDIF                                                  IF HIT
      *
      *
      *-----------------------
      * DESTINATION HOG GROUP
      *-----------------------
      *
     C     FLD           WHENEQ    'DFDNHGCD'
     C                   EXSR      $RRN1
     C     *IN97         IFEQ      *OFF                                         IF HIT
     C                   CALL      'HP598'
     C                   PARM                    c1dnfscd
     C                   PARM                    c1dnfsnm
     C                   PARM      dfdnblcd      XXBLCD
     C                   PARM      dfdnrmcd      XXRMCD
     C                   PARM      *BLANK        XXHGCD
     C                   PARM      *BLANK        XXGSCD
     C                   PARM      *BLANK        XXPTCD
     C                   PARM      *BLANK        XXPPCD
     C     XXHGCD        IFNE      *BLANK                                       IF SELECTED
     C                   MOVEL     XXBLCD        dfdnblcd
     C                   MOVEL     XXRMCD        dfdnrmcd
     C                   MOVEL     XXHGCD        dfdnhgcd
     C                   MOVEL     XXPTCD        dfdnptcd
     C                   MOVEL     XXPPCD        dfdnppcd
     C                   ENDIF                                                  IF SELECTED
      *
      * RESET SUBFILE RECORD INDICATORS AND UPDATE SUBFILE
      * RECORD.
      *
     C                   EXSR      $SFIND
     C                   SETON                                        8556
     C                   UPDATE    HP186S1
     C                   SETOFF                                       8556
      *
      * RESET THE SUBFILE RELATIVE RECORD NUMBER TO WHAT IT WAS BEFORE
      * THE USER TOOK F4 (IT WILL BE OUT-OF-SYNCH IF THE USER HAS
      * SELECTED A RECORD THUS CAUSING THE SUBFILE RECORD TO BE
      * RETRIEVED AND UPDATED.)  BUT, SET THE PAGE OF THE SUBFILE TO
      * BE DISPLAYED TO THE PAGE ON WHICH THE USER TOOK F4.
      *
     C                   Z-ADD     COUNT         HDRRN1
     C                   Z-ADD     HDRR1         HDPAG1
     C                   ENDIF                                                  IF HIT
     C                   OTHER
      *
      * F4 NOT VALID FOR THIS FIELD SO ISSUE MESSAGE.
      * RESET THE SUBFILE RELATIVE RECORD NUMBER TO WHAT IT WAS BEFORE
      * THE USER TOOK F4 (IT WILL BE OUT-OF-SYNCH IF THE USER HAS
      * SELECTED A RECORD THUS CAUSING THE SUBFILE RECORD TO BE
      * RETRIEVED AND UPDATED.)  BUT, SET THE PAGE OF THE SUBFILE TO
      * BE DISPLAYED TO THE PAGE ON WHICH THE USER TOOK F4.
      *
      *
     C     ERROR         IFLT      MAXMSG                                       IF FIRST ERR
     C                   ADD       1             ERROR
     C                   MOVEL     'HS09011'     MGID(E)
     C                   ENDIF                                                  IF FIRST ERR
      *
     C                   ENDSL
      *
     C                   ENDSR
      /EJECT
      *-------------------------------------------------------------------------------
      * SUBROUTINE TO SET THE SUBFILE TO REDISPLAY AT THE FIRST SCREEN THAT HAS ERRORS
      *-------------------------------------------------------------------------------
      *
     C     $ERR1         BEGSR
      *
     C     ERROR         IFEQ      1
     C                   Z-ADD     HDRRN1        HDPAG1
     C                   ENDIF
      *
     C                   ENDSR
      *
      *---------------------------------------------------------------
      * SUBROUTINE TO SET ON LR AND END JOB
      *---------------------------------------------------------------
      *
     C     $EXIT         BEGSR
      *
     C                   SETON                                        LR
      *
     C                   ENDSR
      /EJECT
      *---------------------------------------------------------------
      * FLIP DATE FROM CCYYMMDD TO MMDDYY
      *---------------------------------------------------------------
      *
     C     $TOMDY        BEGSR
      *
     C                   Z-ADD     WKMON         WKMM
     C                   Z-ADD     WKDAY         WKDD
     C                   Z-ADD     WKYER         WKYY
      *
     C                   ENDSR
      /EJECT
      *---------------------------------------------------------------
      * SUBROUTINE TO WRITE ERROR MESSAGES
      *---------------------------------------------------------------
      *
     C     $WRMSG        BEGSR
      *
     C                   CALL      'UT80045J'                           43
     C                   PARM                    MGID
     C                   PARM                    MGDT
     C                   PARM                    ERROR
     C                   PARM      SDPGM         PGM
     C                   PARM      MSGFIL        MSGFL
      *
      * IF CALL TO UT80045J FAILED, A MESSAGE HARDCODED IN THE DSPF
      * COMMAND KEY RECORD WILL BE SET ON. SO, REDISPLAY SCREEN TO USER
      *
     C     *IN43         IFEQ      *ON
     C                   MOVEL     SET1          ROUTNE
     C                   ENDIF
      *
     C                   ENDSR
      *
      *---------------------------------------------------------------
      * SUBROUTINE TO CLEAR MESSAGES
      *---------------------------------------------------------------
      *
     C     $CLMSG        BEGSR
      *
     C                   CALL      'UT80045J'                           43
     C                   PARM      *BLANKS       MGI
     C                   PARM      *BLANKS       MGD
     C                   PARM      *ZEROS        ERROR
     C                   PARM      SDPGM         PGM
     C                   PARM      MSGFIL        MSGFL
      *
      * IF CALL TO UT80045J FAILED, A MESSAGE HARDCODED IN THE DSPF
      * COMMAND KEY RECORD WILL BE SET ON. SO, REDISPLAY SCREEN TO USER
      *
     C     *IN43         IFEQ      *ON
     C                   MOVEL     SET1          ROUTNE
     C                   ENDIF
      *
     C                   ENDSR
      /EJECT
      *------------------------------------------------------------------------------
      * ROUTINE TO FIND/RETRIEVE THE SUBFILE RECORD TO UPDATE WHEN RETURNING FROM A
      * SELECT PROGRAM ON SCREEN 1
      *------------------------------------------------------------------------------
      *
      * HDRR1 IS THE HIDDEN FIELD ASSOCIATED WITH THE KEYWORD SFLCSRRRN
      * ON THE CONTROL RECORD IN THE DSPF.
      * HDRRN1 IS THE VALUE ASSOCIATED WITH THE KEYWORD 'KSFILE' IN
      * THE F-SPECS FOR THE WORKSTATION.
      *
     C     $RRN1         BEGSR
      *
     C                   SETOFF                                       97
      *
     C     HDRR1         IFNE      0
     C                   Z-ADD     HDRR1         HDRRN1
     C     HDRRN1        CHAIN     HP186S1                            97
     C                   ENDIF
      *
     C                   ENDSR
      /EJECT
      *----------------------------------------------------------------
      * RETRIEVE THE USER-ASSIGNED ALPHA HOG GROUP CODE
      *----------------------------------------------------------------
      *
     C     $GRPCD        BEGSR
      *
      * ORIGIN GROUP
      *
     C     MDORSN        CHAIN(N)  HSL034D                            92
     C     *IN92         IFEQ      *ON
     C                   MOVEL     'UNKNOWN'     dforhgcd
     C                   ELSE
     C                   MOVEL     hgblcd        dforblcd
     C                   MOVEL     hgrmcd        dforrmcd
     C                   MOVEL     HGHGCD        dforhgcd
     C                   MOVEL     HGGSCD        dforgscd
     C                   MOVEL     HGPTCD        dforptcd
     C                   MOVEL     HGPPCD        dforppcd
     C                   ENDIF
      *
      * DESTINATION GROUP
      *
     C     MDDNSN        CHAIN(N)  HSL034D                            92
     C     *IN92         IFEQ      *ON
     C                   MOVEL     'UNKNOWN'     dfdnhgcd
     C                   ELSE
     C                   MOVEL     hgblcd        dfdnblcd
     C                   MOVEL     hgrmcd        dfdnrmcd
     C                   MOVEL     HGHGCD        dfdnhgcd
     C                   MOVEL     HGGSCD        dfdngscd
     C                   MOVEL     HGPTCD        dfdnptcd
     C                   MOVEL     HGPPCD        dfdnppcd
     C                   MOVEL     HGHGCD        hddnoldhg
     C                   ENDIF
      *
     C                   ENDSR
      /EJECT
      *---------------------------------------------------------------
      * INITIALIZATION SUBROUTINE
      *---------------------------------------------------------------
      *
     C     *INZSR        BEGSR
      *
      * PARM LISTS
      *
     C     *ENTRY        PLIST
     C                   PARM                    MODE
     C                   PARM                    C1MVSN
     C     C1MSCD        PARM                    XXMSCD
     C                   PARM                    RTNCD
      *
      * Parm lists
      *
     C     plist01       plist
     C                   parm                    hddnhgsn
     C                   parm                    zzcymd
      * Head
     C                   parm                    gpihd                          GROUP INV
     C                   parm                    pinhd                          PIG IN
     C                   parm                    tinhd                          TRSF IN
     C                   parm                    tisphd                         SAME PHASE
     C                   parm                    tidphd                         DIFF PHASE
     C                   parm                    pouhd                          PIGS OUT
     C                   parm                    touhd                          TRSF OUT
     C                   parm                    tosphd                         SAME PHASE
     C                   parm                    tosphd                         DIFF PHASE
     C                   parm                    rinhd                          REJECT IN
     C                   parm                    rouhd                          REJECT OUT
     C                   parm                    qinhd                          QUALITY IN
     C                   parm                    qouhd                          QUALITY OUT
     C                   parm                    morhd                          MORTALITY
     C                   parm                    inahd                          INV ADJ
      * Pounds
     C                   parm                    pinlb                          PIG IN
     C                   parm                    tinlb                          TRSF IN
     C                   parm                    tisplb                         SAME PHASE
     C                   parm                    tidplb                         DIFF PHASE
     C                   parm                    poulb                          PIG OUT
     C                   parm                    toulb                          TRSF OUT
     C                   parm                    tosplb                         SAME PHASE
     C                   parm                    todplb                         DIFF PHASE
     C                   parm                    rinlb                          REJECT IN
     C                   parm                    roulb                          REJECT OUT
     C                   parm                    qinlb                          QUALITY IN
     C                   parm                    qoulb                          QUALITY OUT
     C                   parm                    morlb                          MORTALITY
      *
      *
      * Key lists
      *
     C     key01         klist
     C                   kfld                    c1orfscd
     C                   kfld                    dforblcd
      *
     C     key02         klist
     C                   kfld                    c1orfscd
     C                   kfld                    dforblcd
     C                   kfld                    dforrmcd
      *
     C     key03         klist
     C                   kfld                    c1dnfscd
     C                   kfld                    dfdnblcd
      *
     C     key04         klist
     C                   kfld                    c1dnfscd
     C                   kfld                    dfdnblcd
     C                   kfld                    dfdnrmcd
      *
     C     key05         KLIST
     C                   KFLD                    C1MVSN
     C                   KFLD                    HDLNNO
      *
     C     key06         KLIST
     C                   KFLD                    SVMV1
     C                   KFLD                    SVLN1
      *
     C     key07         KLIST
     C                   KFLD                    SVMV2
     C                   KFLD                    SVLN2
      *
     C     key08         klist
     C                   kfld                    hghgsn
     C                   kfld                    hgopdt
      *
      *
      *
      * GLOBAL DEFINES
      *
     C                   MOVEL     *BLANK        PGM              10            USED IN MSG
     C                   MOVEL     *BLANK        MSGFL            10            USED IN MSG
     C                   MOVEL     *BLANK        ROUTNE            6            ROUTINE
     C                   Z-ADD     0             MAXRRN            4 0          REPOSITION
     C                   MOVEL     NO            RESET             1            REPOSITION
     C                   MOVEL     NO            NOTFLG            1
     C                   MOVEL     '00'          RTNCD             2            RETURN CODE
     C     *LIKE         DEFINE    DFMODE        MODE                           SFL POSITION
     C     *LIKE         DEFINE    IDFLOW        WKFLOW                         SFL POSITION
     C                   MOVEL     NO            EDITFL            1
     C                   Z-ADD     0             WARMSG            2 0
      *
      * ARRAY INDEXES
     C                   Z-ADD     0             X                 3 0
     C                   Z-ADD     0             Y                 3 0
      *
      * ALPHA AND NUMERIC FIELDS FOR USE AS PARMS
      *
     C                   MOVE      *BLANK        XXAIST            1
     C     *LIKE         DEFINE    C1MSCD        XXMSCD
     C                   MOVE      *BLANK        XXMVSN            7
     C     *LIKE         DEFINE    HGHGCD        XXHGCD
     C     *LIKE         DEFINE    FSFSCD        xxfscd
     C                   MOVE      *BLANK        xxalphfscd        5
     C     *LIKE         DEFINE    HGBLCD        XXBLCD
     C     *LIKE         DEFINE    fbblds        xxblds
     C     *LIKE         DEFINE    HGRMCD        XXRMCD
     C     *LIKE         DEFINE    HGGSCD        XXGSCD
     C     *LIKE         DEFINE    HGPTCD        XXPTCD
     C     *LIKE         DEFINE    HGPPCD        XXPPCD
     C     *LIKE         DEFINE    FSFSNM        XXFSNM
     C     *LIKE         DEFINE    TITICD        XXTICD
     C     *LIKE         DEFINE    TITINM        XXTINM
     C                   MOVE      *BLANK        XXRJHD            5
     C                   MOVE      *BLANK        XXHD              5
     C                   MOVE      *BLANK        XXHD6             6
     C                   MOVE      *BLANK        XXLB              5
     C                   MOVE      *BLANK        XXDT06            6
     C     *LIKE         DEFINE    FSMTECHREF    xxmtechref
      *
      * CONTROL FIELDS, FLAGS, COUNTERS, WORK FIELDS
      *
     C     *LIKE         DEFINE    hghgsn        svhgsn
     C     *LIKE         DEFINE    hgopdt        svopdt
     C     *LIKE         DEFINE    hggscd        svgscd
     C     *LIKE         DEFINE    HGPPCD        SVDNPPCD
     C     *LIKE         DEFINE    HGPPCD        SVORPPCD
      *
     C     *LIKE         DEFINE    FSFSBO        WKORBO
     C     *LIKE         DEFINE    FSPTCD        SVORPTCD
     C     *LIKE         DEFINE    FSFSBO        WKDNBO
     C     *LIKE         DEFINE    FSPTCD        SVDNPTCD
     C     *LIKE         DEFINE    fshdsqft      svhdsqft
      *
     C     *LIKE         DEFINE    MHSCDT        WKSCDT
     C     *LIKE         DEFINE    MHSHDT        WKSHDT
     C     *LIKE         DEFINE    MHRCDT        WKRCDT
     C     *LIKE         DEFINE    MHRCDT        SVRCDT
      *
      * ACCUMULATORS FOR SUBFILE HEAD (ARRIVED AND SHIPPED)
      *
     C     *LIKE         DEFINE    MDSCHD        WKTARGETHD
     C     *LIKE         DEFINE    MDSCHD        WKHD
     C     *LIKE         DEFINE    MDSCHD        WKSCHD          + 1
     C     *LIKE         DEFINE    MDSHHD        WKSHHD          + 1
     C     *LIKE         DEFINE    MDSHHD        WKARHD          + 1
     C     *LIKE         DEFINE    MDQLHD        WKQLHD
     C     *LIKE         DEFINE    MDRJHD        WKRJHD
     C     *LIKE         DEFINE    MDDOHD        WKDOHD
      *
     C     *LIKE         DEFINE    MDSHLB        WKLB            + 2
     C     *LIKE         DEFINE    MDSHLB        WKSHLB          + 2
     C     *LIKE         DEFINE    MDQLLB        WKARLB          + 2
     C     *LIKE         DEFINE    MDSHLB        WKTRUNLB        + 2
      *
      * SAVE FIELDS USED IN POUNDS DISTRIBUTION
      *
     C     *LIKE         DEFINE    MDMVSN        SVMV1
     C     *LIKE         DEFINE    MDLNNO        SVLN1
     C     *LIKE         DEFINE    MDMVSN        SVMV2
     C     *LIKE         DEFINE    MDLNNO        SVLN2
      *
     C     *LIKE         DEFINE    MDSHHD        SVSHHD
     C     *LIKE         DEFINE    MDQLHD        SVARHD
     C     *LIKE         DEFINE    MDQLHD        SVQLHD
     C     *LIKE         DEFINE    MDRJHD        SVRJHD
     C     *LIKE         DEFINE    MDQLHD        SVDOHD
      *
     C     *LIKE         DEFINE    MDDOLB        SVDOLB
     C     *LIKE         DEFINE    MDQLLB        SVARLB          + 2
     C     *LIKE         DEFINE    MDQLLB        SVRCLB          + 2
     C     *LIKE         DEFINE    MDSHLB        SVSHLB          + 2
      *
      * AVERAGE POUNDS (ARRIVED AND SHIPPED)
      *
     C                   Z-ADD     0             WKAALB           15 9
     C                   Z-ADD     0             WKASLB           15 9
      *
     C                   MOVEL     NO            CHECKMORE         1
     C                   MOVEL     NO            OK                1
     C                   MOVEL     NO            ENTRFL            1            SFL ENTRIES
     C                   MOVEL     NO            WKTMFL            1            TIME ERRORS
     C                   MOVE      *BLANK        WKTIME            2            TIME FIELD
     C                   MOVEL     YES           LNOKFL            1            LINE OK FLAG
     C                   Z-ADD     0             newopdt           8 0
      *
      * TO SUPPORT F5-REFRESH, LOGIC REQUIRES THE NUMBER OF LINES ON
      * THE SUBFILE PAGE AND ALSO THE NUMBER OF LINES LESS 1.  BY
      * SETTING THESE VALUES UP AS CONSTANT WORK FIELDS, THE PROCESSING
      * LOGIC CAN BE STANDARDIZED BETWEEN PROGRAMS. SINCE THIS DISPLAY
      * HAS FOLD/DROP LOGIC, DOUBLE THE SUBFILE PAGE VALUE.
      *
     C                   Z-ADD     04            WKPLIN            2 0          SFLPAG(0004)
     C     WKPLIN        SUB       1             WKRLIN            2 0          SFLPAG - 1
     C                   Z-ADD     0             COUNT             2 0
     C     *LIKE         DEFINE    COUNT         WKDIFF
     C     *LIKE         DEFINE    COUNT         WKRMDR
     C     *LIKE         DEFINE    COUNT         WKFLD
     C     *LIKE         DEFINE    MDLNNO        WKLNNO
      *
      * THIS PROGRAM DIFFERS FROM THE SHELL PROGRAMS IN THAT F5=REFRESH
      * ALWAYS PLACES THE USER AT THE FIRST PAGE OF THE SUBFILE
      *
     C                   Z-ADD     WKPLIN        MAXRRN
      *
      *
      * CHECK THE ENTRY MODE AND SET THE APPROPRIATE INDICATORS TO
      * CONTROL THE SCREEN DISPLAY.
      *
     C                   SELECT
     C     MODE          WHENEQ    REVISE
     C                   MOVEL     REVISE        DFMODE
     C                   SETON                                        60
     C                   ENDSL
      *
      * THE SYSTEM DATE IS REQUIRED IN CCYYMMDD FORMAT FOR
      * EDITING AND UPDATING; SO, FLIP THE DATE.
      *
     C                   Z-ADD     UDATE         PFRM8
     C                   Z-ADD     0             PTO8
     C                   MOVEL     'MDY '        PFRFMT
     C                   MOVEL     'CYMD'        PTOFMT
     C                   Z-ADD     0             PDAYS
     C                   MOVE      *BLANK        PCODE
     C                   MOVE      *BLANK        PRTRN
      *
     C                   EXSR      $DATE
      *
     C     PRTRN         IFEQ      *BLANK                                       IF VALID
     C                   Z-ADD     PTO8          WKUDAT            8 0
     C                   ELSE
     C                   Z-ADD     0             WKUDAT
     C                   ENDIF                                                  IF VALID
      *
      *
      * THE FOLLOWING STANDARD CODE MUST BE INCLUDED TO MAKE THE
      * STANDARD ERROR MESSAGE HANDLING PROGRAM FUNCTION PROPERLY.
      * THIS CODE SETS AND CLEARS THE PROGRAM MESSAGE QUEUE.
      *
     C                   Z-ADD     20            MAXMSG            2 0
     C                   MOVEL     '*'           MSGPGM                         SET QUEUE
     C                   EXSR      $CLMSG                                       CLEAR MSG
      *
     C                   ENDSR
      /EJECT
